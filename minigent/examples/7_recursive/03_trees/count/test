allocNode : [a]. Unit -> rec t { l: < Nil Unit | Cons { data: a, rest: t }# > take };

alloc : [a]. rec t { l: <Nil Unit | Cons {data: a, rest: t}# > } -> rec t { l: <Nil Unit | Cons {data: a, rest: t}#>}
alloc r =
  let newNode = allocNode Unit in
    put newNode.l := 
      Cons {
        data = True,
        rest = r
      } end
    end
  end;

list : rec t {l: < Nil Unit | Cons { data: Bool, rest: t! }# >}! -> U32;
list r =
  case r.l of
    Nil u -> 0
  | v2 ->
    case v2 of
      Cons s ->
        if s.data then
          let tail = list s.rest in
            1 + list s.rest
          end
        else
          let newNode = alloc s.rest in
            1 + list s.rest
            end
          end
        end
    end
  end;


ruinList r =
  r.l 
    | Nil -> Unit
    | Cons x ->
      if x.data != 0 then
        let _ = dealloc r in
        let r2 = alloc Unit in
        let r3 = (put r2.l := Cons { data: 0, rest: x.rest }) in
          ruinList r3
        end end end
      else
        let _ = dealloc r in
          ruinList r.rest
        end

  let newNode = alloc Unit in
    put newNode.l := 
      Cons {
        data = True, 
        rest = r
      } end
    end
  end;

-- Check current node, generate new node if needed
-- Recurse on rest of list
-- Put rest of list into current node
-- return current node

-- branch on value
-- either dealloc + alloc new, recurse on new
-- 

alloc 

put rest into newNode.rest
rec

ruinList r = 
  case r.l of
    Nil u -> Unit
    | r2 ->
      case r2 of 
        Cons list ->
          if list.data == 0 then
            let newNode = alloc Unit 
            in
              ruinList (Put newNode.l := Cons {data = 0, rest = list.rest} end)
            end
          else
            ruinList list.rest
          end
      end
  end;

ruinList r = 
  case r.l of
    Nil u -> Unit
    | r2 ->
      case r2 of 
        Cons list ->
          if list.data == 0 then
            let newNode = alloc Unit 
            in
              let newList = 
                Put newNode.l := 
                  Cons {
                    data = 0, 
                    rest = list.rest
                  } end
              in
                ruinList newList
              end
            end
          else
            ruinList list.rest
          end
      end
  end;
              