/*
 * Copyright 2017, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(NICTA_GPL)
 */

#define RET $ty:(R (ExState, WordArray a) ExState)
RET $id:wordarray_create($ty:((ExState, U32)) args) {
	$ty:(ExState) h = args.p1;
	u32 size = args.p2;
	RET ret;

	// TODO: work around type inference tool
	$ty:(WordArray a) array = ret.Success.p2;
	array = malloc(sizeof(*array));

	if (array == NULL) {
		ret.tag = TAG_ENUM_Error;
		ret.Error = h;
	} else {
		array->values = calloc (size, sizeof (*(array->values)));
		if (array->values == NULL) {
			free (array);
			ret.tag = TAG_ENUM_Error;
			ret.Error = h;
		} else {
			array->len = size;

			ret.tag = TAG_ENUM_Success;
			ret.Success.p1 = h;
			ret.Success.p2 = array;
		}
	}

	return ret;
}

$ty:(ExState) $id:wordarray_free($ty:((ExState, WordArray a)) args) {
	$ty:(WordArray a) array = args.p2;

	if (array->values) {
		free (array->values);
	}
	
	free (array);

	return args.p1;
}

unit_t $id:wordarray_print($ty:(CString!) args)
{
  unit_t ret;
  int len = args->len;
  if (len > 71)
    len = 71;
  printf("%.*s", len, args->values);
  return ret;
}
