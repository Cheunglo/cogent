(*
  This file contains the locale WordArray which includes the locale generated by AutoCorres from
  the C file containing the word array functions.
  
  This file also includes the proof that the WordArray locale is a subset of the top level 
  correspondence locale.

  This file also contains the various abstractions for the word array functions.
*)

theory WordArray_Abstractions
  imports Generated_AllRefine
begin

section "Helper Word Lemmas"

lemma word_mult_cancel_left: 
  fixes a b c :: "('a::len) word"
  assumes "0 \<le> a" "0 \<le> b" "0 \<le> c"
  assumes "uint c * uint a \<le> uint (max_word :: ('a::len) word)"
  assumes "uint c * uint b \<le> uint (max_word :: ('a::len) word)"
  shows "c * a = c * b \<longleftrightarrow> c = 0 \<or> a = b"
  apply (rule iffI)
   using assms
   apply (unfold word_mult_def word_of_int_def)
    apply (clarsimp simp:Abs_word_inject max_word_def uint_word_of_int m1mod2k uint_0_iff )
   apply fastforce
   done

fun is_prim_type :: "type \<Rightarrow> bool"
  where
"is_prim_type (TPrim _) = True" |
"is_prim_type _ = False"

fun is_num_type :: "prim_type \<Rightarrow> bool"
  where
"is_num_type (Num _) = True" |
"is_num_type _ = False"

fun size_of_num_type :: "num_type \<Rightarrow> ptrtyp"
  where
"size_of_num_type U8 = 1" |
"size_of_num_type U16 = 2" |
"size_of_num_type U32 = 4" |
"size_of_num_type U64 = 8"

fun zero_num_lit :: "num_type \<Rightarrow> lit"
  where
"zero_num_lit U8 = LU8 0" |
"zero_num_lit U16 = LU16 0" |
"zero_num_lit U32 = LU32 0" |
"zero_num_lit U64 = LU64 0"


section "WordArray Locale Definition"
locale WordArray = main_pp_inferred begin
  definition "wa_abs_repr a \<equiv> case a of
      UWA (TPrim (Num t)) _ _ \<Rightarrow> (''WordArray'', [RPrim (Num t)])
    | _ \<Rightarrow> (''Unknown Abstract Type'', [])"

  definition "wa_abs_typing_u a name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    (case a of
      UWA (TPrim (Num t)) len arr \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num t)] \<and> sig \<noteq> Unboxed \<and>
                      (sigil_perm sig = option.Some ReadOnly \<longrightarrow> w = {} \<and> 
                        r = {arr + size_of_num_type t * i | i. i < len}) \<and>
                      (sigil_perm sig = option.Some Writable \<longrightarrow> r = {} \<and> 
                        w = {arr + size_of_num_type t * i | i. i < len}) \<and>
                      (\<forall>i < len. \<exists>x. \<sigma>(arr + size_of_num_type t * i) = option.Some (UPrim x) \<and> lit_type x = Num t) \<and> 
                      unat (size_of_num_type t)  * unat len \<le> unat (max_word :: ptrtyp)
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [] \<and> r = {} \<and> w = {} \<and> sig = Unboxed)"

  definition "wa_abs_typing_v a name \<tau>s \<equiv>
    (case a of
      VWA (TPrim (Num t)) xs \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num t)] \<and> 
      (\<forall>i < length xs. \<exists>x. xs ! i = VPrim x \<and>  lit_type x = Num t)
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [])"

  definition  "wa_abs_upd_val au av name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    wa_abs_typing_u au name \<tau>s sig r w \<sigma> \<and> wa_abs_typing_v av name \<tau>s \<and>
    (case au of
      UWA (TPrim (Num t)) len arr \<Rightarrow>
        (case av of 
          VWA (TPrim (Num t)) xs \<Rightarrow> unat len = length xs \<and> \<tau>s = [TPrim (Num t)] \<and>
          (\<forall>i < len. \<exists>x. \<sigma> (arr + size_of_num_type t * i) = option.Some (UPrim x) \<and> xs ! unat i = VPrim x \<and> lit_type x = Num t)
          | _ \<Rightarrow> False)
      | _ \<Rightarrow> (case av of
                VTOther _ \<Rightarrow> True
             |  _ \<Rightarrow> False))"

lemma distinct_indices:
  "wa_abs_typing_u (UWA (TPrim (Num t)) len arr) n ts s r w \<sigma> \<Longrightarrow> 
    \<forall>i < len. \<forall>j < len. i = j \<longleftrightarrow> size_of_num_type t * i = size_of_num_type t * j"
  apply clarsimp
  apply (rule iffI)
   apply (clarsimp simp: wa_abs_typing_u_def)
  apply (clarsimp simp: wa_abs_typing_u_def)
  apply (subgoal_tac "0 \<le> i")
   apply (frule_tac b = j and c = "size_of_num_type t" in word_mult_cancel_left; clarsimp simp: uint_nat)
     apply (subgoal_tac "int (unat i) < int (unat len)")
      apply (case_tac t; clarsimp)
    apply (simp add: unat_mono)
    apply (subgoal_tac "int (unat j) < int (unat len)")
     apply (case_tac t; clarsimp)
    apply (simp add: unat_mono)
   apply (case_tac t; clarsimp)
  apply simp
  done      
end

section "Sublocale Proof"

sublocale WordArray \<subseteq> Generated_cogent_shallow _ wa_abs_repr wa_abs_typing_v wa_abs_typing_u wa_abs_upd_val
  apply (unfold wa_abs_repr_def[abs_def] wa_abs_typing_v_def[abs_def] wa_abs_typing_u_def[abs_def] wa_abs_upd_val_def[abs_def])
  apply (unfold_locales; clarsimp split: vatyp.splits atyp.splits)
              apply (case_tac x11; clarsimp; case_tac x5; clarsimp)
             apply (case_tac x11; clarsimp; case_tac x5; clarsimp; case_tac s; clarsimp; case_tac x11; clarsimp)
            apply (case_tac x11; clarsimp; case_tac x5; clarsimp; case_tac s; clarsimp; case_tac x11; clarsimp)
           apply (case_tac x11; clarsimp; case_tac x5; clarsimp; case_tac s; clarsimp; case_tac x11; clarsimp)
          apply (case_tac x11; clarsimp; case_tac x5; clarsimp; case_tac s; clarsimp; case_tac x11; clarsimp)
         apply (case_tac x11; clarsimp; case_tac x5; clarsimp; case_tac s; clarsimp; case_tac x11; clarsimp; blast)
        apply (case_tac x11; clarsimp; case_tac x5; clarsimp; case_tac s; clarsimp; case_tac x11; clarsimp; case_tac s'; clarsimp)
       apply (case_tac x11; clarsimp; case_tac x5; clarsimp)
      apply (case_tac x11; clarsimp; case_tac x5; clarsimp)
      apply (erule_tac x = i in allE; clarsimp)
      apply (rule_tac x = x in exI)
      apply (clarsimp simp: frame_def)
      apply (erule_tac x = "x13 + size_of_num_type x1 * i" in allE; clarsimp)
      apply (case_tac s; clarsimp; case_tac x11; clarsimp)
       apply (drule_tac x = "x13 + size_of_num_type x1 * i" in orthD1; clarsimp)
       apply (rule_tac x = i in exI; clarsimp)
      apply (drule_tac x = "x13 + size_of_num_type x1 * i" in orthD1; clarsimp)
      apply (rule_tac x = i in exI; clarsimp)
     apply (case_tac x11; clarsimp; case_tac x11b; clarsimp; case_tac x5; clarsimp; case_tac x5a; clarsimp; case_tac s; clarsimp; case_tac x11; clarsimp)
    apply (case_tac x11; clarsimp; case_tac x5; clarsimp)
   apply (case_tac x11; clarsimp; case_tac x11b; clarsimp; case_tac x5; clarsimp; case_tac x5a; clarsimp)
   apply (rule conjI; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)+
    apply (rule_tac x = x in exI)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = "x13 + size_of_num_type x1a * i" in allE; clarsimp)
    apply (case_tac s; clarsimp; case_tac x11; clarsimp)
     apply (drule_tac x = "x13 + size_of_num_type x1a * i" in orthD1; clarsimp)
     apply (rule_tac x = i in exI; clarsimp)
    apply (drule_tac x = "x13 + size_of_num_type x1a * i" in orthD1; clarsimp)
    apply (rule_tac x = i in exI; clarsimp)
   apply (erule_tac x = i in allE; clarsimp)+
   apply (clarsimp simp: frame_def)
   apply (erule_tac x = "x13 + size_of_num_type x1a * i" in allE; clarsimp)
   apply (case_tac s; clarsimp; case_tac x11; clarsimp)
    apply (drule_tac x = "x13 + size_of_num_type x1a * i" in orthD1; clarsimp)
    apply (rule_tac x = i in exI; clarsimp)
   apply (drule_tac x = "x13 + size_of_num_type x1a * i" in orthD1; clarsimp)
   apply (rule_tac x = i in exI; clarsimp)
  apply (case_tac x11; clarsimp; case_tac x5; clarsimp)
  done

section "Abstractions for Word Arrays"

subsection "Helper Functions and Lemmas"

fun myslice :: "nat \<Rightarrow> nat \<Rightarrow> 'a list \<Rightarrow> 'a list"
  where
"myslice frm to xs = List.take (to - frm) (List.drop frm xs)"

(*
lemma take_1_drop:
  "i < length xs \<Longrightarrow> List.take (Suc 0) (List.drop i xs) = [xs ! i]"
  apply (induct xs arbitrary: i)
   apply (simp add: take_Suc_conv_app_nth)
  by (simp add: drop_Suc_nth)

lemma take_drop_Suc:
  "i < l \<and> i < length xs \<Longrightarrow> 
    List.take (l - i) (List.drop i xs) = (xs ! i) # List.take (l - Suc i) (List.drop (Suc i) xs)"
  apply clarsimp
  by (metis Cons_nth_drop_Suc Suc_diff_Suc take_Suc_Cons)
*)

subsection "Shallow Word Array Value Relation"

overloading
  valRel_WordArrayU8 \<equiv> valRel
begin
  definition valRel_WordArrayU8: 
    "\<And>\<xi> x v. valRel_WordArrayU8 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (8 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA (TPrim (Num U8)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU8 (x ! i)))"
end

overloading
  valRel_WordArrayU16 \<equiv> valRel
begin
  definition valRel_WordArrayU16: 
    "\<And>\<xi> x v. valRel_WordArrayU16 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (16 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA (TPrim (Num U16)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU16 (x ! i)))"
end

overloading
  valRel_WordArrayU32 \<equiv> valRel
begin
  definition valRel_WordArrayU32: 
    "\<And>\<xi> x v. valRel_WordArrayU32 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (32 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA (TPrim (Num U32)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU32 (x ! i)))"
end

overloading
  valRel_WordArrayU64 \<equiv> valRel
begin
  definition valRel_WordArrayU64: 
    "\<And>\<xi> x v. valRel_WordArrayU64 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (64 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA (TPrim (Num U64)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU64 (x ! i)))"
end



subsection "Shallow Word Array Function Definitions"

overloading
  wordarray_put2' \<equiv> wordarray_put2
begin
definition wordarray_put2':
 "wordarray_put2' (x :: ('a WordArray, 32 word, 'a) WordArrayPutP) \<equiv> (WordArrayPutP.arr\<^sub>f x)[unat (WordArrayPutP.idx\<^sub>f x) := WordArrayPutP.val\<^sub>f x]" 
end

overloading
  wordarray_length' \<equiv> wordarray_length
begin
definition wordarray_length':
 "wordarray_length' (x :: 'a WordArray) \<equiv> (of_nat (length x) :: 32 word)" 
end

overloading
  wordarray_get' \<equiv> wordarray_get
begin
definition wordarray_get':
 "wordarray_get' (x :: (('a::len8) word WordArray, 32 word) RR) \<equiv> (if unat (RR.p2\<^sub>f x) < length (RR.p1\<^sub>f x) then (RR.p1\<^sub>f x) ! unat (RR.p2\<^sub>f x) else 0)" 
end


overloading
  wordarray_fold_no_break' \<equiv> wordarray_fold_no_break
begin
definition wordarray_fold_no_break':
 "wordarray_fold_no_break' (x :: ('a WordArray, 32 word, 32 word, ('a, 'acc, 'obsv) ElemAO \<Rightarrow> 'acc, 'acc, 'obsv) WordArrayMapP) \<equiv> 
    fold (\<lambda>a b. (WordArrayMapP.f\<^sub>f x) (ElemAO.make a b (WordArrayMapP.obsv\<^sub>f x))) 
         (myslice (unat (WordArrayMapP.frm\<^sub>f x)) (unat (WordArrayMapP.to\<^sub>f x)) (WordArrayMapP.arr\<^sub>f x)) 
         (WordArrayMapP.acc\<^sub>f x)" 
end
context WordArray begin

subsection "Level 0 \<xi> Abstractions"

\<comment>\<open> This section contains the abstractions for first order calls to word array functions \<close>

subsubsection "Update Semantics"

definition upd_wa_put2_0
  where
  "upd_wa_put2_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in (\<exists>p idx val t. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num t)]), RPtr (RCon ''WordArray'' [RPrim (Num t)])),
          (UPrim (LU32 idx), RPrim (Num U32)), (val, RPrim (Num t))] \<and>
          y2 = UPtr p (RCon ''WordArray'' [RPrim (Num t)]) \<and>
          y1 = (\<lambda>l. (if \<exists>len arr. x1 p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and> 
                        l = arr + size_of_num_type t * idx \<and> idx < len then option.Some val else x1 l))))"

definition upd_wa_get_0
  where
  "upd_wa_get_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p idx t len arr. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num t)]), RPtr (RCon ''WordArray'' [RPrim (Num t)])),
          (UPrim (LU32 idx), RPrim (Num U32))] \<and> x1 p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and>
          (idx < len \<longrightarrow> x1 (arr + size_of_num_type t * idx) = option.Some y2) \<and>
            (\<not> idx < len \<longrightarrow> y2 = UPrim (zero_num_lit t))))"

definition upd_wa_length_0
  where
  "upd_wa_length_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p t len arr. x2 = UPtr p (RCon ''WordArray'' [RPrim (Num t)]) \<and>
          x1 p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and> y2 = UPrim (LU32 len)))"

fun \<xi>0 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>0 x y z = 
    (if x = ''wordarray_put2_0'' then upd_wa_put2_0 y z
     else (if x = ''wordarray_get_0'' then upd_wa_get_0 y z
           else (if x = ''wordarray_length_0'' then upd_wa_length_0 y z
                 else False)))" 

subsubsection "Value Semantics"
\<comment>\<open> These definitions will have to change because for different word sizes because only using
    @{term "VWA xs"} means we cannot determine what word array it is meant to represent in the case
    that @{term "xs::(funtyp, vabstyp) vval list"} is empty. Either we need to define a new dataype
    or we modify the current type to include the word type. \<close>
definition val_wa_length
  where
  "val_wa_length x y = (\<exists>xs len t. x = VAbstract (VWA (TPrim (Num t)) xs) \<and> y = VPrim (LU32 len) \<and> 
                          length xs = unat len)" 

definition val_wa_get
  where
  "val_wa_get x y =
      (\<exists>xs t idx v. x = VRecord [VAbstract (VWA (TPrim (Num t)) xs), VPrim (LU32 idx)] \<and>
       y = VPrim v \<and> lit_type v = Num t \<and> (unat idx < length xs \<longrightarrow> xs ! unat idx = y) \<and> 
       (\<not> unat idx < length xs \<longrightarrow> zero_num_lit t = v))" 

definition val_wa_put2
  where
  "val_wa_put2 x y =
      (\<exists>xs t idx val. x = VRecord [VAbstract (VWA (TPrim (Num t)) xs), VPrim (LU32 idx), VPrim val] \<and>
       lit_type val = Num t \<and> y = VAbstract (VWA (TPrim (Num t)) (xs[unat idx := VPrim val])))" 


fun \<xi>m :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>m x y z = 
    (if x = ''wordarray_put2_0'' then val_wa_put2 y z
     else (if x = ''wordarray_get_0'' then val_wa_get y z
           else (if x = ''wordarray_length_0'' then val_wa_length y z
                 else False)))" 

fun \<xi>p :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>p x y z = 
    (if x = ''wordarray_put2'' then val_wa_put2 y z
     else (if x = ''wordarray_get'' then val_wa_get y z
           else (if x = ''wordarray_length'' then val_wa_length y z
                 else False)))" 

subsection "Level 1 \<xi> Abstractions"

\<comment>\<open> This section contains the abstractions for second order calls to word array functions.
    Note that in order to show termination, abstractions on this level can only call other
    abstractions from level 0. So far, this seems to be the best solution, however, when more
    levels are introduced, i.e. when third, fourth ... calls are introduced, these abstractions
    should probably be automatically generated. \<close>

subsubsection "Update Semantics"

type_synonym ('f, 'a, 'l) ufoldmapdef = "(char list, atyp, 32 word) uabsfuns \<Rightarrow> ('f, 'a, 'l) store \<Rightarrow> 
                                         32 word \<Rightarrow> 32 word \<Rightarrow> 32 word \<Rightarrow>
                                        'f expr \<Rightarrow> ('f, 'a, 'l) uval \<Rightarrow> ('f, 'a, 'l) uval \<Rightarrow> ptrtyp set\<Rightarrow>
                                        (('f, 'a, 'l) store \<times> ('f, 'a, 'l) uval) \<Rightarrow> bool"
(*
function upd_wa_mapnb_bod_0 :: "(char list, atyp, 32 word) ufoldmapdef"
  where
  "upd_wa_mapnb_bod_0 \<xi>\<^sub>u \<sigma> p frm to f acc (obsv, s) res = (\<exists>t len arr. 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim t) len arr)) \<and> 
    (if frm < min to len then (\<exists>v v' acc' \<sigma>'. \<sigma> (arr + 4 * frm) = option.Some (UPrim (LU32 v)) \<and> 
         (\<xi>\<^sub>u, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), (acc, upd.uval_repr acc), (obsv, upd.uval_repr obsv)])] \<turnstile> 
            (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>', URecord [(UPrim (LU32 v'), RPrim (Num U32)), (acc', upd.uval_repr acc')])) \<and>
          \<sigma> p = \<sigma>' p \<and> (\<forall>i<len. \<sigma> (arr + 4 * i) = \<sigma>' (arr + 4 * i)) \<and> (upd.uval_repr acc = upd.uval_repr  acc') \<and>
          upd_wa_mapnb_bod_0 \<xi>\<^sub>u (\<lambda>l.(if l = arr + 4 * frm then option.Some (UPrim (LU32 v')) else \<sigma>' l))
             p (frm + 1) to f acc' (obsv, s) res) 
    else (\<sigma>, URecord [(
        UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
         (acc, upd.uval_repr acc)]) = res))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, _, frm, to, _, _, _, _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done
*)

function upd_wa_foldnb_bod :: "(char list, atyp, 32 word) ufoldmapdef"
  where
  "upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s res = (\<exists>t len arr. 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and> 
    (\<forall>i<len. \<exists>v. \<sigma> (arr + size_of_num_type t * i) = option.Some v) \<and>
    (if frm < min to len then (\<exists>v acc' \<sigma>' w1 w2. \<sigma> (arr + size_of_num_type t * frm) = option.Some v \<and> 
          (\<xi>\<^sub>u, [(URecord [(v, upd.uval_repr v), (acc, upd.uval_repr acc), 
            (obsv, upd.uval_repr obsv)])] \<turnstile> (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>', acc')) \<and>
          frame \<sigma> w1 \<sigma>' w2 \<and> ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {} \<and>
          upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma>' p (frm + 1) to f acc' obsv s res) 
    else (\<sigma>, acc) = res))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, _, frm, to, _, _, _, _,  _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done

declare upd_wa_foldnb_bod.simps[simp del]

lemma upd_wa_foldnb_bod_to_geq_len:
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm len f acc obsv s (\<sigma>', r); \<sigma> p = option.Some (UAbstract (UWA t len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r)"
  apply (induct arbitrary: to arr t
                rule: upd_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>u and
                                                       ?a1.0 = \<sigma> and 
                                                       ?a2.0 = p and 
                                                       ?a3.0 = frm and 
                                                       ?a4.0 = len and
                                                       ?a5.0 = f and
                                                       ?a6.0 = acc and
                                                       ?a7.0 = obsv and
                                                       ?a8.0 = s and
                                                       ?a9.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = to in meta_spec)
  apply (subst (asm) upd_wa_foldnb_bod.simps)
  apply (clarsimp split: if_splits)
  apply (erule disjE; clarsimp)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply (drule_tac x = toa in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (drule_tac x = "TPrim (Num ta)" in meta_spec)
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule conjI; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>' in exI)
    apply clarsimp
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI; clarsimp)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = p in allE; clarsimp)
   apply (rule FalseE)
   apply auto[1]
  apply (subst upd_wa_foldnb_bod.simps)
  apply clarsimp
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = \<sigma>' in meta_spec)
  apply (drule_tac x = toa in meta_spec)
  apply (drule_tac x = arr in meta_spec)
  apply (drule_tac x = "TPrim (Num ta)" in meta_spec)
  apply clarsimp
  apply (rule_tac x = acc' in exI)
  apply (rule_tac x = \<sigma>' in exI)
  apply clarsimp
  apply (rule_tac x = w1 in exI)
  apply clarsimp
  apply (rule conjI)
   apply (rule_tac x = x in exI; clarsimp)
  apply (erule meta_mp)
  apply (clarsimp simp: frame_def)
  apply (erule_tac x = p in allE; clarsimp)
  done

lemma upd_wa_foldnb_bod_to_geq_lenD:
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); \<sigma> p = option.Some (UAbstract (UWA t len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm len f acc obsv s (\<sigma>', r)"
  apply (induct rule: upd_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>u and
                                                       ?a1.0 = \<sigma> and 
                                                       ?a2.0 = p and 
                                                       ?a3.0 = frm and 
                                                       ?a4.0 = to and
                                                       ?a5.0 = f and
                                                       ?a6.0 = acc and
                                                       ?a7.0 = obsv and
                                                       ?a8.0 = s and 
                                                       ?a9.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (subst (asm) upd_wa_foldnb_bod.simps)
  apply (clarsimp split: if_splits)
  apply (erule disjE; clarsimp)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule conjI)
    apply (rule_tac x = x in exI; clarsimp)
   apply (clarsimp simp: frame_def)
   apply (erule_tac x = p in allE; clarsimp)
  apply (case_tac "frm < to")
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule conjI)
    apply (rule_tac x = x in exI; clarsimp)
   apply (clarsimp simp: frame_def)
   apply (erule_tac x = p in allE; clarsimp)
  apply clarsimp
  apply (subgoal_tac "\<not> frm < len")
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
  apply auto
  done

lemma upd_wa_foldnb_bod_step:
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)); frm \<le> to; to < len; 
    \<sigma> (arr + size_of_num_type t * to) = option.Some v; frame \<sigma>' w1 \<sigma>'' w2; 
    ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {};
    \<xi>\<^sub>u, [URecord [(v, upd.uval_repr v), (r, upd.uval_repr r), (obsv, upd.uval_repr obsv)]] \<turnstile> (\<sigma>', App f (Var 0))\<Down>! (\<sigma>'', r')\<rbrakk> 
    \<Longrightarrow> upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm (to + 1) f acc obsv s (\<sigma>'', r')"
  apply (induct arbitrary: len arr v r r' \<sigma>' \<sigma>'' obsv s t w1 w2
                rule: upd_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>u and
                                                       ?a1.0 = \<sigma> and 
                                                       ?a2.0 = p and 
                                                       ?a3.0 = frm and 
                                                       ?a4.0 = to and
                                                       ?a5.0 = f and
                                                       ?a6.0 = acc and
                                                       ?a7.0 = obsv and
                                                       ?a8.0 = s and 
                                                       ?a9.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (erule upd_wa_foldnb_bod.elims)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>'''' in meta_spec)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (drule_tac x = v in meta_spec)
   apply (drule_tac x = b in meta_spec)
   apply (drule_tac x = r' in meta_spec)
   apply (drule_tac x = a in meta_spec)
   apply (drule_tac x = \<sigma>'' in meta_spec)
   apply (drule_tac x = obsv in meta_spec)
   apply (drule_tac x = s in meta_spec)
   apply (drule_tac x = t in meta_spec)
   apply (drule_tac x = w1 in meta_spec)
   apply (drule_tac x = w2 in meta_spec)
   apply clarsimp
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule conjI; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>'''' in exI)
    apply clarsimp
    apply (rule_tac x = w1a in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI; clarsimp)
    apply (case_tac "frma + 1 \<le> toa")
     apply clarsimp
     apply (erule_tac x = toa in allE; clarsimp)
     apply (thin_tac "frame _ _ _ _")
     apply (thin_tac "_ = {}")
     apply (clarsimp simp: frame_def)
     apply (frule_tac x = pa in spec)
     apply clarsimp
     apply (erule_tac x = "arr + size_of_num_type t * toa" in allE)
     apply clarsimp
     apply (drule_tac x = "arr + size_of_num_type t * toa" in orthD1; simp)
     apply (rule disjI2)
     apply (rule_tac x = toa in exI; clarsimp)
    apply (clarsimp simp: not_le)
    apply (drule_tac i = frma and m = toa in inc_le)
    apply (rule FalseE)
    apply simp
   apply (clarsimp simp: not_less)
   apply (rule FalseE)
   apply (simp add: less_is_non_zero_p1 plus_one_helper2 word_le_not_less)
  apply (erule disjE)
   apply (subst upd_wa_foldnb_bod.simps; clarsimp)
   apply (rule conjI; clarsimp)
    apply (rule_tac x = r' in exI)
    apply (rule_tac x = \<sigma>'' in exI)
    apply (subst upd_wa_foldnb_bod.simps; clarsimp)
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = w2 in exI; clarsimp)
    apply (rule_tac x =  t in exI)
    apply (rule_tac x = len in exI)
    apply (rule_tac x = arr in exI)
    apply (rule conjI)
     apply (clarsimp simp: frame_def)
     apply (erule_tac x = pa in allE; clarsimp)
    apply clarsimp
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = va in exI)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = "arr + size_of_num_type t * i" in allE; clarsimp)
    apply (drule_tac x = "arr + size_of_num_type t * i" in orthD1; simp)
    apply (rule disjI2)
    apply (rule_tac x = i in exI; clarsimp)
   apply (clarsimp simp: not_less)
   apply (meson less_is_non_zero_p1 word_le_not_less word_overflow)
  apply (clarsimp simp: not_less)
  by auto

lemma upd_wa_foldnb_bod_back_step:
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); to > 0; to \<le> len; frm < to - 1; 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr))\<rbrakk>
    \<Longrightarrow> \<exists>\<sigma>'' r'' w1 w2 v. upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm (to - 1) f acc obsv s (\<sigma>'', r'') \<and> 
        \<sigma> (arr + size_of_num_type t * (to - 1)) = option.Some v \<and>
        (\<xi>\<^sub>u, [URecord [(v, upd.uval_repr v), (r'', upd.uval_repr r''), 
          (obsv, upd.uval_repr obsv)]] \<turnstile> (\<sigma>'', App f (Var 0))\<Down>! (\<sigma>', r)) \<and>
        frame \<sigma>'' w1 \<sigma>' w2 \<and> ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {}"
  apply (induct arbitrary: len arr \<sigma>' r obsv s t
                rule: upd_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>u and
                                                       ?a1.0 = \<sigma> and 
                                                       ?a2.0 = p and 
                                                       ?a3.0 = frm and 
                                                       ?a4.0 = "to" and
                                                       ?a5.0 = f and
                                                       ?a6.0 = acc and
                                                       ?a7.0 = obsv and
                                                       ?a8.0 = s and
                                                       ?a9.0 = "(\<sigma>', r)"]; clarsimp)
  apply (erule upd_wa_foldnb_bod.elims)  
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>''' in meta_spec)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (drule_tac x = a in meta_spec)
   apply (drule_tac x = b in meta_spec)
   apply (drule_tac x = obsv in meta_spec)
   apply (drule_tac x = s in meta_spec)
   apply (drule_tac x = t in meta_spec)
   apply (case_tac "frma + 1 < toa - 1"; clarsimp)
    apply (drule meta_mp)
     apply (clarsimp simp: frame_def)
     apply (erule_tac x = pa in allE; clarsimp)
    apply clarsimp
    apply (rule_tac x = \<sigma>'''' in exI)
    apply (rule_tac x = r'' in exI)
    apply (rule conjI)
     apply (subst upd_wa_foldnb_bod.simps; clarsimp)
     apply (rule_tac x = acc' in exI)
     apply (rule_tac x = \<sigma>''' in exI)
     apply clarsimp
     apply (rule_tac x = w1 in exI)
     apply clarsimp
     apply (rule_tac x = x in exI)
     apply clarsimp
    apply (rule_tac x = w1a in exI)
    apply (rule_tac x = w2 in exI)
    apply (rule_tac x = va in exI)
    apply clarsimp
    apply (erule_tac x = "toa - 1" in allE)
    apply (erule impE)
     apply (simp add: minus_one_helper)
    apply clarsimp
    apply (subst (asm) frame_def)
    apply (erule_tac x = "arr + size_of_num_type t * (toa - 1)" in allE)
    apply clarsimp
    apply (drule_tac x = "arr + size_of_num_type t * (toa - 1)" in orthD1)
     apply (rule UnI2)
     apply clarsimp
     apply (rule_tac x = "toa - 1" in exI)
     apply clarsimp
     apply (simp add: less_1_simp)
    apply clarsimp
   apply (subgoal_tac "frma + 1  = toa - 1")
    apply (subgoal_tac "1 + frma < 2 + frma")
     apply (subgoal_tac "\<sigma>''' pa = option.Some (UAbstract (UWA (TPrim (Num t)) len arr))")
      apply (erule upd_wa_foldnb_bod.elims)  
      apply (clarsimp split: if_split_asm)
       apply (subst upd_wa_foldnb_bod.simps; clarsimp)
       apply (subst upd_wa_foldnb_bod.simps; clarsimp simp: add.commute)
       apply (rule_tac x = \<sigma> in exI)
       apply (rule_tac x = acc in exI)
       apply (rule conjI)
        apply (rule_tac x = acc in exI)
        apply (rule_tac x = \<sigma> in exI)
        apply clarsimp
        apply (rule_tac x = w1 in exI)
        apply clarsimp
        apply (rule_tac x = x in exI; clarsimp)
       apply (erule upd_wa_foldnb_bod.elims; clarsimp)
       apply (rule_tac x = w1a in exI)
       apply (rule_tac x = xa in exI)
       apply (rule_tac x = va in exI)
       apply clarsimp
       apply (erule_tac x =  "frma + 1" in allE; clarsimp)+
       apply (subst (asm) frame_def)
       apply (erule_tac x = "arr + size_of_num_type t * (frma + 1)" in allE)
       apply clarsimp
       apply (drule_tac x = "arr + size_of_num_type t * (frma + 1)" in orthD1; simp)
       apply (rule disjI2)
       apply (rule_tac x = "frma + 1" in exI; clarsimp)
      apply (rule FalseE)
      apply auto[1]
     apply (clarsimp simp: frame_def)
     apply (erule_tac x = pa in allE; clarsimp)
    apply (simp add: minus_one_helper5 word_le_less_eq)
   apply (meson inc_le word_le_less_eq)
  apply (erule impE)
   apply (metis less_1_simp word_le_less_eq word_le_not_less)
  apply (rule FalseE)
  by (metis (no_types, hide_lams) less_1_simp less_trans order_less_irrefl)

lemma upd_wa_foldnb_bod_back_step':
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); 
    \<sigma> p = option.Some (UAbstract (UWA t len arr)); len < to\<rbrakk>
    \<Longrightarrow> upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm (to - 1) f acc obsv s (\<sigma>', r)"
  apply (induct arbitrary: len arr t
                rule: upd_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>u and
                                                       ?a1.0 = \<sigma> and 
                                                       ?a2.0 = p and 
                                                       ?a3.0 = frm and 
                                                       ?a4.0 = "to" and
                                                       ?a5.0 = f and
                                                       ?a6.0 = acc and
                                                       ?a7.0 = obsv and
                                                       ?a8.0 = s and
                                                       ?a9.0 = "(\<sigma>', r)"]; clarsimp)
  apply (drule_tac x = len in meta_spec)
  apply (erule upd_wa_foldnb_bod.elims)  
  apply (subst upd_wa_foldnb_bod.simps)
  apply (clarsimp split: if_split_asm)
  apply (rule_tac x = ta in exI)
  apply (rule conjI; clarsimp)
  apply (erule disjE; clarsimp)
    apply (drule_tac x = acc' in meta_spec)
    apply (drule_tac x = \<sigma>'' in meta_spec)
    apply (drule_tac x = len in meta_spec)
    apply (drule_tac x = arr in meta_spec)
    apply (drule_tac x = "TPrim (Num ta)" in meta_spec)
    apply clarsimp
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>'' in exI)
    apply clarsimp
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI; clarsimp)
    apply (erule meta_mp)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = pa in allE; clarsimp)
   apply (erule impE)
   apply simp
   apply clarsimp
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (drule_tac x = "TPrim (Num ta)" in meta_spec)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule conjI)
    apply (rule_tac x = x in exI; clarsimp)
   apply (erule meta_impE)
    apply simp
   apply (erule meta_impE)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = pa in allE; clarsimp)
   apply simp
  apply (rule FalseE)
  by (metis (no_types, hide_lams) less_1_simp word_le_less_eq word_not_le)


fun is_uval_fun :: "('f, 'a, 'l) uval \<Rightarrow> bool"
  where
"is_uval_fun (UFunction _ _) = True" |
"is_uval_fun (UAFunction _ _) = True" |
"is_uval_fun _ = False"

fun uvalfun_to_exprfun :: "('f, 'a, 'l) uval \<Rightarrow> 'f expr"
  where
"uvalfun_to_exprfun (UFunction f ts) = Fun f ts" |
"uvalfun_to_exprfun (UAFunction f ts) = AFun f ts" |
"uvalfun_to_exprfun _ = undefined"

(* We will need to define a different wrapper for each type of accumulator so that we can prove
   that the frame constraints still hold when proving the proc_env_matches_ptrs constraint.
   This is because we do not know what the set of writeable pointers are unless we know the
   type of the accumulator *)

definition upd_wa_foldnb_0  :: "(char list, atyp, 32 word) ufundef" 
  where
  "upd_wa_foldnb_0 y z = 
    (let (y1, y2) = y;
         (z1, z2) = z
      in (\<exists>p frm to acc r x.
        y2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), 
                      RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
                      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
                      (x, RFun), (UPrim (LU32 acc), RPrim (Num U32)), (UUnit, RUnit)] \<and> 
        y1 = z1 \<and> y1 p = z1 p \<and> (\<exists>len arr. y1 p = option.Some (UAbstract (UWA (TPrim (Num U32)) len arr)) \<and> 
          (\<forall>i<len. y1 (arr + 4 * i) = z1 (arr + 4 * i))) \<and> z2 = UPrim (LU32 r) \<and> is_uval_fun x \<and> 
        (\<Xi>, [], [option.Some abbreviatedType1] \<turnstile> (App (uvalfun_to_exprfun x) (Var 0)) : TPrim (Num U32)) \<and> 
        upd_wa_foldnb_bod \<xi>0 y1 p frm to (uvalfun_to_exprfun x) (UPrim (LU32 acc)) UUnit {} z))"
\<comment>\<open> It is hard to generalise the definition for wordarray_fold because we require the type mapping
    for functions which is only defined at compiled time, however since this doesn't change for each
    level then it should actually be fine. However, we should change the definition to take the
    abstract function relation as an argument so that we can generalise it. Another issue is
    determining the read-only pointer sets. If we determine this by doing the uval_typing relation,
    we would then need to show that 
      \<lbrakk>uval_typing \<Xi> \<sigma> v t r w; uval_typing \<Xi> \<sigma> v t r' w'\<rbrakk> \<Longrightarrow> (r \<subseteq> r' \<or> r' \<subseteq> r)
    or something along those lines. \<close>
(*
function extract_ptr :: "(char list, atyp, ptrtyp) store \<Rightarrow> (char list, atyp, ptrtyp) uval \<Rightarrow> ptrtyp set \<Rightarrow> ptrtyp set"
  where
"extract_ptr _ UUnit A = A" |
"extract_ptr _ (UPrim _) A = A" |
"extract_ptr s (UProduct a b) A = (extract_ptr s a A) \<union> (extract_ptr s b A)" |
"extract_ptr s (USum _ a _) A = extract_ptr s a A" |
"extract_ptr s (URecord fs) A = \<Union> (set (map ((\<lambda>a. extract_ptr s a A) \<circ> prod.fst) fs))" |
"extract_ptr _ (UFunction _ _) A = A" | 
"extract_ptr _ (UAFunction _ _) A = A" |
"extract_ptr s (UAbstract a) A = 
  (case a of (UWA (TPrim (Num t)) len arr) \<Rightarrow> A \<union> {arr + size_of_num_type t * i | i. i < len}
      | _ \<Rightarrow> A)" |
"extract_ptr s (UPtr p _) A = (if p \<in> A then A else 
  (case s p of
      option.Some a \<Rightarrow> extract_ptr s a (insert p A)
    |  _  \<Rightarrow> insert p A))"
  by pat_completeness auto
term set
termination
  apply (relation "mlex_prod a undefined")
  sorry
*)
(*
definition upd_wa_foldnb  :: "(char list, atyp, 32 word) uabsfuns \<Rightarrow> (char list, atyp, 32 word) ufundef" 
  where
  "upd_wa_foldnb \<xi>\<^sub>u y z = 
    (let (y1, y2) = y;
         (z1, z2) = z
      in (\<exists>p frm to acc r x t u v.
        y2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num t)]), 
                      RPtr (RCon ''WordArray'' [RPrim (Num t)])),
                      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
                      (x, RFun), (acc, upd.uval_repr acc), (UUnit, RUnit)] \<and> 
        y1 = z1 \<and> y1 p = z1 p \<and> (\<exists>len arr. y1 p = option.Some (UAbstract (UWA (TPrim (Num U32)) len arr)) \<and> 
          (\<forall>i<len. y1 (arr + size_of_num_type t * i) = z1 (arr + size_of_num_type t * i))) \<and> z2 = UPrim (LU32 r) \<and>
        (case x of
            UFunction f ts \<Rightarrow> (\<Xi>, [], [option.Some abbreviatedType1] \<turnstile> (App (Fun f ts) (Var 0)) : 
                                TPrim (Num U32)) \<and> 
                              upd_wa_foldnb_bod \<xi>\<^sub>u y1 p frm to (Fun f ts) acc (UUnit, {}) z
          | UAFunction f ts \<Rightarrow> (\<Xi>, [], [option.Some abbreviatedType1] \<turnstile> (App (AFun f ts) (Var 0)) : 
                                TPrim (Num U32)) \<and>
                              upd_wa_foldnb_bod \<xi>\<^sub>u y1 p frm to (AFun f ts) acc (UUnit, {}) z
          | _ \<Rightarrow> False)))"
*)
(*
definition upd_wa_mapnb_0  :: "(char list, atyp, 32 word) ufundef" 
  where
  "upd_wa_mapnb_0 y z = 
    (let (y1, y2) = y;
         (z1, z2) = z 
    in (\<exists>p frm to x.
        y2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]),
                      RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
                      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
                      (x, RFun),
                      (UUnit, RUnit), (UUnit, RUnit)] \<and>
        y1 p = z1 p \<and> (\<exists>len arr. y1 p = option.Some (UAbstract (UWA (TPrim (Num U32)) len arr)) \<and> 
          frame y1 ({p} \<union> {arr + 4 * i | i. i < len}) z1 ({p} \<union> {arr + 4 * i | i. i < len})) \<and>
        (case x of
            UFunction f ts \<Rightarrow> upd_wa_mapnb_bod_0 \<xi>0 y1 p frm to (Fun f ts) (UUnit) (UUnit, {}) z
          | UAFunction f ts \<Rightarrow> upd_wa_mapnb_bod_0 \<xi>0 y1 p frm to (AFun f ts) (UUnit) (UUnit, {}) z
          | _ \<Rightarrow> False)))"
*)
fun \<xi>1 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' then upd_wa_foldnb_0 y z
     else (if x = ''wordarray_map_no_break_0'' then False 
           else \<xi>0 x y z))" 

subsubsection "Value Semantics"

type_synonym ('f, 'a) vfoldmapdef = "(char list, vatyp) vabsfuns \<Rightarrow> ('f, 'a) vval list \<Rightarrow> nat \<Rightarrow> 
                                      nat \<Rightarrow> 'f expr \<Rightarrow> ('f, 'a) vval \<Rightarrow> ('f, 'a) vval \<Rightarrow> 
                                      ('f, 'a) vval \<Rightarrow> bool"

function val_wa_foldnb_bod :: "(char list, vatyp) vfoldmapdef"
  where
  "val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv res = 
    (if frm < min to (length xs)
      then (\<exists>acc'. (\<xi>\<^sub>v, [(VRecord [xs ! frm, acc, obsv])] \<turnstile> App f (Var 0) \<Down> acc') \<and>
          val_wa_foldnb_bod \<xi>\<^sub>v xs (Suc frm) to f acc' obsv res)
    else acc = res)"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, frm, to, _, _, _, _). to - frm)"; clarsimp)
  apply linarith
  done
print_theorems
declare val_wa_foldnb_bod.simps[simp del]

lemma val_wa_foldnb_bod_append:
  "\<lbrakk>to \<le> length xs; val_wa_foldnb_bod \<xi>\<^sub>v (xs @ [x]) frm to f acc obsv r\<rbrakk>
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv r"
  apply (induct arbitrary: x 
                rule: val_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>v and
                                                       ?a1.0 = xs and
                                                       ?a2.0 = frm and
                                                       ?a3.0 = to and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = x in meta_spec)
   apply clarsimp
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (clarsimp simp: nth_append)
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_append_incl_to:
  "\<lbrakk>frm < length (xs @ [x]); to > length xs; val_wa_foldnb_bod \<xi>\<^sub>v (xs @ [x]) frm to f acc obsv r\<rbrakk>
    \<Longrightarrow> \<exists>r'. val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv r' \<and> (\<xi>\<^sub>v, [VRecord [x, r', obsv]] \<turnstile> (App f (Var 0)) \<Down> r)"
  apply (induct arbitrary: x
                rule: val_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>v and
                                                       ?a1.0 = xs and
                                                       ?a2.0 = frm and
                                                       ?a3.0 = to and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = r])
  apply clarsimp
  apply (case_tac "frm = length xs")
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (erule val_wa_foldnb_bod.elims)
   apply clarsimp
   apply (erule val_wa_foldnb_bod.elims)
   apply (clarsimp split: if_splits)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_splits)
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = x in meta_spec)
  apply clarsimp
  apply (rule_tac x = r' in exI)
  apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply (clarsimp simp: nth_append)
  apply (rule_tac x = acc' in exI)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_step:
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv r; frm \<le> to; to < length xs; 
    \<xi>\<^sub>v, [VRecord [xs ! to, r, obsv]] \<turnstile> (App f (Var 0)) \<Down> (r')\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v xs frm (Suc to) f acc obsv r'"
  apply (induct arbitrary: r'
                rule: val_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>v and
                                                       ?a1.0 = xs and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to and 
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = r])
  apply clarsimp
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = r' in meta_spec)
   apply clarsimp
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  apply (rule_tac x = r' in exI)
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_to_geq_len:
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v xs frm (length xs) f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>v and
                                                       ?a1.0 = xs and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to  and 
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_to_geq_lenD:
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v xs frm (length xs) f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>v and
                                                       ?a1.0 = xs and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to and 
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_back_step':
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v xs frm (Suc to) f acc obsv r; length xs < Suc to\<rbrakk>
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>v and
                                                       ?a1.0 = xs and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to  and 
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_back_step:
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v xs frm (Suc to) f acc obsv r; Suc to \<le> length xs; frm < to\<rbrakk>
    \<Longrightarrow> \<exists>r'. val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv r' \<and>
        (\<xi>\<^sub>v, [VRecord [xs ! to, r', obsv]] \<turnstile> (App f (Var 0)) \<Down> r)"
  apply (induct arbitrary: 
                rule: val_wa_foldnb_bod.induct[where ?a0.0 = \<xi>\<^sub>v and 
                                                       ?a1.0 =xs and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to  and 
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
  apply (erule_tac x = acc' in meta_allE)
  apply clarsimp
  apply (case_tac "Suc frma < to")
   apply clarsimp
   apply (rule_tac x = r' in exI)
   apply clarsimp
   apply (subst val_wa_foldnb_bod.simps; clarsimp)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply clarsimp
  apply (subgoal_tac "to = Suc frma")
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule conjI)
    apply (subst val_wa_foldnb_bod.simps; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply clarsimp
    apply (subst val_wa_foldnb_bod.simps; clarsimp)
   apply (erule val_wa_foldnb_bod.elims; clarsimp)
   apply (erule val_wa_foldnb_bod.elims; clarsimp)
  by linarith

lemma val_wa_foldnb_bod_preservation:
  "\<lbrakk>proc_ctx_wellformed \<Xi>'; val.proc_env_matches \<xi>\<^sub>v \<Xi>'; val_wa_foldnb_bod \<xi>\<^sub>v xs frm to f acc obsv r; 
    wa_abs_typing_v (VWA t xs) ''WordArray'' [t]; val.vval_typing \<Xi>' acc u; val.vval_typing \<Xi>' obsv v;
    \<Xi>', [], [option.Some (TRecord [(a0, (t, Present)), (a1, (u, Present)), 
      (a2, (v, Present))] Unboxed)] \<turnstile> App f (Var 0) : u; distinct [a0, a1, a2]\<rbrakk>
    \<Longrightarrow> val.vval_typing \<Xi>' r u"
  apply (induct to arbitrary: r)
   apply (erule val_wa_foldnb_bod.elims; clarsimp)
  apply (case_tac "length xs < Suc to")
   apply (drule val_wa_foldnb_bod_back_step'; simp)
  apply (case_tac "to \<le> frm")
   apply (erule val_wa_foldnb_bod.elims; clarsimp split: if_splits)
   apply (erule val_wa_foldnb_bod.elims; clarsimp)
   apply (drule val.preservation(1)[of "[]" "[]" _ _ _  \<xi>\<^sub>v, simplified]; simp?)
   apply (clarsimp simp: val.matches_def)
   apply (rule val.v_t_record; simp?)
   apply (rule val.v_t_r_cons1)
    apply (clarsimp simp: wa_abs_typing_v_def)
    apply (case_tac t; clarsimp)
    apply (case_tac x5; clarsimp)
    apply (erule allE[where x = frm]; clarsimp)
    apply (rule val.v_t_prim'; clarsimp)
   apply (rule val.v_t_r_cons1; simp?)
   apply (rule val.v_t_r_cons1; simp?)
   apply (rule val.v_t_r_empty)
  apply (clarsimp simp: not_less not_le)
  apply (clarsimp simp: wa_abs_typing_v_def)
  apply (case_tac t; clarsimp)
  apply (case_tac x5; clarsimp)
  apply (erule_tac x = to in allE; clarsimp)
  apply (drule val_wa_foldnb_bod_back_step; simp?)
  apply clarsimp
  apply (drule_tac x = r' in meta_spec)
  apply clarsimp
  apply (drule val.preservation(1)[of "[]" "[]" _ _ _  \<xi>\<^sub>v, simplified]; simp?)
  apply (clarsimp simp: val.matches_def)
  apply (rule val.v_t_record; simp?)
  apply (rule val.v_t_r_cons1; simp?)
  apply (rule val.v_t_prim'; clarsimp)
  apply (rule val.v_t_r_cons1; simp?)
  apply (rule val.v_t_r_cons1; simp?)
  apply (rule val.v_t_r_empty)
  done

fun is_vval_fun :: "('f, 'a) vval \<Rightarrow> bool"
  where
"is_vval_fun (VFunction _ _) = True" |
"is_vval_fun (VAFunction _ _) = True" |
"is_vval_fun _ = False"

fun vvalfun_to_exprfun :: "('f, 'a) vval \<Rightarrow> 'f expr"
  where
"vvalfun_to_exprfun (VFunction f ts) = Fun f ts" |
"vvalfun_to_exprfun (VAFunction f ts) = AFun f ts" |
"vvalfun_to_exprfun _ = undefined"

definition val_wa_foldnb_0
  where
  "val_wa_foldnb_0 x y = (\<exists>xs frm to acc r func. 
      x = VRecord [VAbstract (VWA (TPrim (Num U32)) xs), VPrim (LU32 frm), VPrim (LU32 to), func, VPrim (LU32 acc),
                   VUnit] \<and> y = VPrim (LU32 r) \<and> (\<forall>i < length xs. \<exists>v. xs ! i = VPrim (LU32 v)) \<and>
      is_vval_fun func \<and> 
      (\<Xi>, [], [option.Some abbreviatedType1] \<turnstile> (App (vvalfun_to_exprfun func) (Var 0)) : TPrim (Num U32)) \<and>
      (val_wa_foldnb_bod \<xi>m xs (unat frm) (unat to) (vvalfun_to_exprfun func) (VPrim (LU32 acc)) (VUnit) y))"


definition val_wa_foldnb_0p
  where
  "val_wa_foldnb_0p x y = (\<exists>xs frm to func acc obsv. 
      x = VRecord [VAbstract (VWA (TPrim (Num U32)) xs), VPrim (LU32 frm), VPrim (LU32 to), func, acc, obsv] \<and>
      is_vval_fun func \<and> val_wa_foldnb_bod \<xi>p xs (unat frm) (unat to) (vvalfun_to_exprfun func) acc obsv y)"

fun \<xi>m1 :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>m1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' 
      then val_wa_foldnb_0 y z
     else \<xi>m x y z)" 

fun \<xi>p1 :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>p1 x y z = 
    (if x = ''wordarray_fold_no_break'' 
      then val_wa_foldnb_0p y z
     else \<xi>p x y z)" 
end (* of context *)
end