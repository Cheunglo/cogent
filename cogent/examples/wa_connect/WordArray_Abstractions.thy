(*
  This file contains the locale WordArray which includes the locale generated by AutoCorres from
  the C file containing the word array functions.
  
  This file also includes the proof that the WordArray locale is a subset of the top level 
  correspondence locale.

  This file also contains the various abstractions for the word array functions.
*)

theory WordArray_Abstractions
  imports Generated_AllRefine
begin

section "Helper Word Lemmas"

lemma word_mult_cancel_left: 
  fixes a b c :: "('a::len) word"
  assumes "0 \<le> a" "0 \<le> b" "0 \<le> c"
  assumes "uint c * uint a \<le> uint (max_word :: ('a::len) word)"
  assumes "uint c * uint b \<le> uint (max_word :: ('a::len) word)"
  shows "c * a = c * b \<longleftrightarrow> c = 0 \<or> a = b"
  apply (rule iffI)
   using assms
   apply (unfold word_mult_def word_of_int_def)
    apply (clarsimp simp:Abs_word_inject max_word_def uint_word_of_int m1mod2k uint_0_iff )
   apply fastforce
   done

section "WordArray Locale Definition"

locale WordArray = main_pp_inferred begin
  definition "abs_repr_u a \<equiv> case a of
      WAU32 _ _ \<Rightarrow> (''WordArray'', [RPrim (Num U32)])
    | _ \<Rightarrow> (''Unknown Abstract Type'', [])"

  definition "abs_typing_u a name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    (case a of
      WAU32 len arr \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num U32)] \<and> sig \<noteq> Unboxed \<and>
                      (sigil_perm sig = option.Some ReadOnly \<longrightarrow> w = {} \<and> r = {arr + 4 * i | i. i < len}) \<and>
                      (sigil_perm sig = option.Some Writable \<longrightarrow> r = {} \<and> w = {arr + 4 * i | i. i < len}) \<and>
                      (\<forall>i < len. \<exists>x. \<sigma>(arr + 4 * i) = option.Some (UPrim (LU32 x))) \<and> 4 * unat len \<le> unat (max_word :: ptrtyp)
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [] \<and> r = {} \<and> w = {} \<and> sig = Unboxed)"

  definition "abs_typing_v a name \<tau>s \<equiv>
    (case a of
      VWA xs \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num U32)] \<and> (\<forall>i < length xs. \<exists>x. xs ! i = VPrim (LU32 x))
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [])"

  definition  "abs_upd_val' au av name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    abs_typing_u au name \<tau>s sig r w \<sigma> \<and> abs_typing_v av name \<tau>s \<and>
    (case au of
      WAU32 len arr \<Rightarrow>
        (case av of 
          VWA xs \<Rightarrow> unat len = length xs \<and> 
                      (\<forall>i < len. \<exists>x. \<sigma>(arr + 4 * i) = option.Some (UPrim (LU32 x)) \<and> 
                                     xs ! (unat i) = VPrim (LU32 x))
          | _ \<Rightarrow> False)
      | _ \<Rightarrow> (case av of
                VTOther _ \<Rightarrow> True
             |  _ \<Rightarrow> False))"

lemma distinct_indices:
  "abs_typing_u (WAU32 len arr) n ts s r w \<sigma> \<Longrightarrow> \<forall>i < len. \<forall>j < len. i = j \<longleftrightarrow> 4 * i = 4 * j"
  apply clarsimp
  apply (rule iffI)
   apply (clarsimp simp: abs_typing_u_def)
  apply (clarsimp simp: abs_typing_u_def)
  apply (subgoal_tac "0 \<le> i")
   apply (frule_tac b = j and c = 4 in word_mult_cancel_left; clarsimp simp: uint_nat)
    apply (subgoal_tac "int (unat i) < int (unat len)")
     apply linarith
    apply (simp add: unat_mono)
   apply (subgoal_tac "int (unat j) < int (unat len)")
    apply linarith
   apply (simp add: unat_mono)
  apply simp
  done      
end

section "Sublocale Proof"

sublocale WordArray \<subseteq> Generated_cogent_shallow _ abs_repr_u abs_typing_v abs_typing_u abs_upd_val'
  apply (unfold abs_repr_u_def[abs_def] abs_typing_v_def[abs_def] abs_typing_u_def[abs_def] abs_upd_val'_def[abs_def])
  apply (unfold_locales; clarsimp split: vatyp.splits atyp.splits)
          apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
         apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
        apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
       apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
      apply (case_tac s; clarsimp; case_tac x11a; clarsimp; erule_tac x = i in allE; clarsimp)
     apply (case_tac s, (case_tac s', simp_all)+)[]
    apply (unfold UpdateSemantics.frame_def)
    apply (erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply (case_tac s; clarsimp; case_tac x11a; clarsimp;
           drule_tac x = "x12 + 4 * i" in orthD1; simp; rule_tac x = i in exI; simp)
   apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
  apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
   apply (rule conjI; clarsimp; erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply auto[1]
   apply (erule_tac x = i in allE; clarsimp)
   apply auto[1]
  apply (rule conjI; clarsimp; erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply auto[1]
   apply (erule_tac x = i in allE; clarsimp)
   apply auto[1]
  done

section "Abstractions for Word Arrays"
section "Shallow Word Array Value Relation"

overloading
  valRel_WordArrayU32 \<equiv> valRel
begin
  definition valRel_WordArrayU32: 
    "\<And>\<xi> x v. valRel_WordArrayU32 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (32 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU32 (x ! i)))"
end

subsection "Shallow Word Array Function Definitions"

overloading
  wordarray_put2' \<equiv> wordarray_put2
begin
definition wordarray_put2':
 "wordarray_put2' (x :: ('a WordArray, 32 word, 'a) WordArrayPutP) \<equiv> (WordArrayPutP.arr\<^sub>f x)[unat (WordArrayPutP.idx\<^sub>f x) := WordArrayPutP.val\<^sub>f x]" 
end

overloading
  wordarray_length' \<equiv> wordarray_length
begin
definition wordarray_length':
 "wordarray_length' (x :: 'a WordArray) \<equiv> (of_nat (length x) :: 32 word)" 
end

overloading
  wordarray_get' \<equiv> wordarray_get
begin
definition wordarray_get':
 "wordarray_get' (x :: (32 word WordArray, 32 word) RR) \<equiv> (if unat (RR.p2\<^sub>f x) < length (RR.p1\<^sub>f x) then (RR.p1\<^sub>f x) ! unat (RR.p2\<^sub>f x) else 0)" 
end

subsection "\<xi> Abstractions"

definition upd_wa_put2_0
  where
  "upd_wa_put2_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in (\<exists>p idx val. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 idx), RPrim (Num U32)), (UPrim (LU32 val), RPrim (Num U32))] \<and>
          y2 = UPtr p (RCon ''WordArray'' [RPrim (Num U32)]) \<and>
          y1 = (\<lambda>l. (if \<exists>len arr. x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
                        l = arr + 4 * idx \<and> idx < len then option.Some (UPrim (LU32 val)) else x1 l))))"

definition upd_wa_get_0
  where
  "upd_wa_get_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p idx len arr. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 idx), RPrim (Num U32))] \<and> x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
            (idx < len \<longrightarrow> x1 (arr + 4 * idx) = option.Some y2) \<and>
            (\<not> idx < len \<longrightarrow> y2 = UPrim (LU32 0))))"

definition upd_wa_length_0
  where
  "upd_wa_length_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p len arr. x2 = UPtr p (RCon ''WordArray'' [RPrim (Num U32)]) \<and>
          x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> y2 = UPrim (LU32 len)))"

definition val_wa_length_0
  where
  "val_wa_length_0 x y = (\<exists>xs len. x = VAbstract (VWA xs) \<and> y = VPrim (LU32 len) \<and> 
                                length xs = unat len)" 


definition val_wa_get_0
  where
  "val_wa_get_0 x y =
      (\<exists>xs idx v. x = VRecord [VAbstract (VWA xs), VPrim (LU32 idx)] \<and> y = VPrim (LU32 v) \<and>
       (unat idx < length xs \<longrightarrow> xs ! unat idx = y) \<and> (\<not> unat idx < length xs \<longrightarrow> v = 0))" 

definition val_wa_put2_0
  where
  "val_wa_put2_0 x y =
      (\<exists>xs idx val. x = VRecord [VAbstract (VWA xs), VPrim (LU32 idx), VPrim (LU32 val)] \<and>
       y = VAbstract (VWA (xs[unat idx := VPrim (LU32 val)])))" 


fun \<xi>0 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>0 x y z = 
    (if x = ''wordarray_put2_0'' then upd_wa_put2_0 y z
     else (if x = ''wordarray_get_0'' then upd_wa_get_0 y z
           else (if x = ''wordarray_length_0'' then upd_wa_length_0 y z
                 else False)))" 

fun \<xi>m :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>m x y z = 
    (if x = ''wordarray_put2_0'' then val_wa_put2_0 y z
     else (if x = ''wordarray_get_0'' then val_wa_get_0 y z
           else (if x = ''wordarray_length_0'' then val_wa_length_0 y z
                 else False)))" 

fun \<xi>p :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>p x y z = 
    (if x = ''wordarray_put2'' then val_wa_put2_0 y z
     else (if x = ''wordarray_get'' then val_wa_get_0 y z
           else (if x = ''wordarray_length'' then val_wa_length_0 y z
                 else False)))" 

(*
fun upd_wa_foldnb_0'  :: "(char list, atyp, 32 word) ufundef" 
  where
"upd_wa_foldnb_0' (b1, b2) c = (\<exists>p frm to f ts acc len arr. 
    b2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
      (UFunction f ts, RFun), (UPrim (LU32 acc), RPrim (Num U32)), (UUnit, RUnit)] \<and> 
    b1 p = option.Some (UAbstract (WAU32 len arr)) \<and>
    (if frm < min to frm 
      then (\<exists>v b1' acc' \<xi>. (b1 (arr + 4 * frm) = option.Some (UPrim (LU32 v))) \<and> 
        (\<xi>, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), (UPrim (LU32 acc), RPrim (Num U32)), 
          (UUnit, RUnit)])] \<turnstile> (b1, App (Fun f ts) (Var 0)) \<Down>! (b1', UPrim (LU32 acc'))) \<and>
        upd_wa_foldnb_0' (b1', URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 (frm + 1)), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
          (UFunction f ts, RFun), (UPrim (LU32 acc'), RPrim (Num U32)), (UUnit, RUnit)]) c)
    else (b1, b2) = c))"
(*
fun upd_wa_foldnb_body
*)
definition upd_wa_fold_nb_0 :: "(char list, atyp, 32 word) ufundef" 
  where
"upd_wa_fold_nb_0 x y =
     (let (x1, x2) = x;
          (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p frm to f ts acc len arr. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
          (UFunction f ts, RFun), (UPrim (LU32 acc), RPrim (Num U32)), (UUnit, RUnit)] \<and> 
          x1 p = option.Some (UAbstract (WAU32 len arr))))"


value "[7 ..(min 3 5)]"
term "SOME (x:: nat). x = 0"
term "THE x. x"
term fold
(*
  bad_\<sigma> ptr = None
  \<sigma> p = option.Some (UAbstract (WAU32 len arr))
  xs = [frm .. (min to len)]
  acc_f = (\<sigma>, acc)
  f = (\<lambda>i (\<sigma>, acc).
        (case \<sigma> (arr + i) of
            option.Some (UPrim (LU32 v)) \<Rightarrow>
            | _ \<Rightarrow> (bad_\<sigma>, UUnit)))
*)
*)

end