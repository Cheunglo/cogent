(*
  This file contains the locale WordArray which includes the locale generated by AutoCorres from
  the C file containing the word array functions.
  
  This file also includes the proof that the WordArray locale is a subset of the top level 
  correspondence locale.

  This file also contains the various abstractions for the word array functions.
*)

theory WordArray_Abstractions
  imports Generated_AllRefine
begin

section "Helper Word Lemmas"

lemma word_mult_cancel_left: 
  fixes a b c :: "('a::len) word"
  assumes "uint c * uint a \<le> uint (max_word :: ('a::len) word)"
  assumes "uint c * uint b \<le> uint (max_word :: ('a::len) word)"
  shows "c * a = c * b \<longleftrightarrow> c = 0 \<or> a = b"
  apply (rule iffI)
   using assms
   apply (unfold word_mult_def word_of_int_def)
    apply (clarsimp simp:Abs_word_inject max_word_def uint_word_of_int m1mod2k uint_0_iff )
   apply fastforce
   done

lemma word_mult_cancel_left_bounded: 
  fixes a b c d :: "('a::len) word"
  assumes "a \<le> d" "b \<le> d"
  assumes "unat c * unat d \<le> unat (max_word :: ('a::len) word)"
  shows "c * a = c * b \<longleftrightarrow> c = 0 \<or> a = b"
  using assms
  apply -
  apply (clarsimp simp: word_le_nat_alt)
  apply (frule_tac i = "unat a" and j = "unat d" and k = "unat c" in mult_le_mono2)
  apply (drule_tac i = "unat b" and j = "unat d" and k = "unat c" in mult_le_mono2)
  by (metis (mono_tags, hide_lams) assms(3) le_unat_uoi mult_left_cancel mult_zero_left not_less_iff_gr_or_eq unat_0 unat_mono word_arith_nat_mult)


fun is_prim_type :: "type \<Rightarrow> bool"
  where
"is_prim_type (TPrim _) = True" |
"is_prim_type _ = False"

fun is_num_type :: "prim_type \<Rightarrow> bool"
  where
"is_num_type (Num _) = True" |
"is_num_type _ = False"

fun size_of_num_type :: "num_type \<Rightarrow> ptrtyp"
  where
"size_of_num_type U8 = 1" |
"size_of_num_type U16 = 2" |
"size_of_num_type U32 = 4" |
"size_of_num_type U64 = 8"

lemma size_of_num_type_not_zero:
  "size_of_num_type t \<noteq> 0"
  by (case_tac t; clarsimp)

fun zero_num_lit :: "num_type \<Rightarrow> lit"
  where
"zero_num_lit U8 = LU8 0" |
"zero_num_lit U16 = LU16 0" |
"zero_num_lit U32 = LU32 0" |
"zero_num_lit U64 = LU64 0"


section "WordArray Locale Definition"
locale WordArray = main_pp_inferred begin
  definition "wa_abs_repr a \<equiv> case a of
      UWA (TPrim (Num t)) _ _ \<Rightarrow> (''WordArray'', [RPrim (Num t)])
    | _ \<Rightarrow> (''Unknown Abstract Type'', [])"

  definition "wa_abs_typing_u a name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    (case a of
      UWA (TPrim (Num t)) len arr \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num t)] \<and> sig \<noteq> Unboxed \<and>
                      (sigil_perm sig = option.Some ReadOnly \<longrightarrow> w = {} \<and> 
                        r = {arr + size_of_num_type t * i | i. i < len}) \<and>
                      (sigil_perm sig = option.Some Writable \<longrightarrow> r = {} \<and> 
                        w = {arr + size_of_num_type t * i | i. i < len}) \<and>
                      (\<forall>i < len. \<exists>x. \<sigma>(arr + size_of_num_type t * i) = option.Some (UPrim x) \<and> lit_type x = Num t) \<and> 
                      unat (size_of_num_type t)  * unat len \<le> unat (max_word :: ptrtyp)
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [] \<and> r = {} \<and> w = {} \<and> sig = Unboxed)"

  definition "wa_abs_typing_v a name \<tau>s \<equiv>
    (case a of
      VWA (TPrim (Num t)) xs \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num t)] \<and> 
      (\<forall>i < length xs. \<exists>x. xs ! i = VPrim x \<and>  lit_type x = Num t)
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [])"

  definition  "wa_abs_upd_val au av name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    wa_abs_typing_u au name \<tau>s sig r w \<sigma> \<and> wa_abs_typing_v av name \<tau>s \<and>
    (case au of
      UWA (TPrim (Num t)) len arr \<Rightarrow>
        (case av of 
          VWA (TPrim (Num t)) xs \<Rightarrow> unat len = length xs \<and> \<tau>s = [TPrim (Num t)] \<and>
          (\<forall>i < len. \<exists>x. \<sigma> (arr + size_of_num_type t * i) = option.Some (UPrim x) \<and> xs ! unat i = VPrim x \<and> lit_type x = Num t)
          | _ \<Rightarrow> False)
      | _ \<Rightarrow> (case av of
                VTOther _ \<Rightarrow> True
             |  _ \<Rightarrow> False))"

lemma distinct_indices:
  "wa_abs_typing_u (UWA (TPrim (Num t)) len arr) n ts s r w \<sigma> \<Longrightarrow> 
    \<forall>i < len. \<forall>j < len. i = j \<longleftrightarrow> size_of_num_type t * i = size_of_num_type t * j"
  apply clarsimp
  apply (rule iffI)
   apply clarsimp
  apply (clarsimp simp: wa_abs_typing_u_def)
  apply (cut_tac a = i and b = j and c = "size_of_num_type t" and d = len in word_mult_cancel_left_bounded; simp)
  apply (erule disjE; clarsimp)
  apply (case_tac t; clarsimp)
  done      
end

section "Sublocale Proof"
sublocale WordArray \<subseteq> Generated_cogent_shallow _ wa_abs_repr wa_abs_typing_v wa_abs_typing_u wa_abs_upd_val
  apply (unfold wa_abs_repr_def[abs_def] wa_abs_typing_v_def[abs_def] wa_abs_typing_u_def[abs_def] wa_abs_upd_val_def[abs_def])
  apply (unfold_locales; clarsimp split: vatyp.splits atyp.splits)
               apply (clarsimp split: type.splits prim_type.splits)
              apply (clarsimp split: type.splits prim_type.splits)
              apply (rename_tac s r w \<sigma> len arr t)
              apply (case_tac s; clarsimp; rename_tac perm ptrl; case_tac perm; clarsimp)
             apply (clarsimp split: type.splits prim_type.splits)
             apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp)
            apply (clarsimp split: type.splits prim_type.splits) 
            apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp)
           apply (clarsimp split: type.splits prim_type.splits)
           apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp)
          apply (clarsimp split: type.splits prim_type.splits)
          apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp; blast)
         apply (clarsimp split: type.splits prim_type.splits)
         apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp; case_tac s'; clarsimp)
        apply (clarsimp split: type.splits prim_type.splits)
       apply (clarsimp split: type.splits prim_type.splits)
       apply (rename_tac len arr t i)
       apply (erule_tac x = i in allE; clarsimp)
       apply (rule_tac x = x in exI)
       apply (clarsimp simp: frame_def)
       apply (erule_tac x = "arr + size_of_num_type t * i" in allE; clarsimp)
       apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp)
        apply (drule_tac x = "arr + size_of_num_type t * i" in orthD1; clarsimp)
        apply (rule_tac x = i in exI; clarsimp)
       apply (drule_tac x = "arr + size_of_num_type t * i" in orthD1; clarsimp)
       apply (rule_tac x = i in exI; clarsimp)
      apply (clarsimp split: type.splits prim_type.splits)
      apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp)
     apply (clarsimp split: type.splits prim_type.splits)
     apply (case_tac s; clarsimp; rename_tac perm ptrl; case_tac perm; clarsimp)
    apply (clarsimp split: type.splits prim_type.splits)
   apply (clarsimp split: type.splits prim_type.splits)
   apply (rename_tac xs len arr t)
   apply (rule conjI; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)+
    apply (rule_tac x = x in exI)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = "arr + size_of_num_type t * i" in allE; clarsimp)
    apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp)
     apply (drule_tac x = "arr + size_of_num_type t * i" in orthD1; clarsimp)
     apply (rule_tac x = i in exI; clarsimp)
    apply (drule_tac x = "arr + size_of_num_type t * i" in orthD1; clarsimp)
    apply (rule_tac x = i in exI; clarsimp)
   apply (erule_tac x = i in allE; clarsimp)+
   apply (clarsimp simp: frame_def)
   apply (erule_tac x = "arr + size_of_num_type t * i" in allE; clarsimp)
   apply (case_tac s; clarsimp; rename_tac perm; case_tac perm; clarsimp)
    apply (drule_tac x = "arr + size_of_num_type t * i" in orthD1; clarsimp)
    apply (rule_tac x = i in exI; clarsimp)
   apply (drule_tac x = "arr + size_of_num_type t * i" in orthD1; clarsimp)
   apply (rule_tac x = i in exI; clarsimp)
  apply (clarsimp split: type.splits prim_type.splits)
  done

section "Abstractions for Word Arrays"

subsection "Helper Functions and Lemmas"

fun myslice :: "nat \<Rightarrow> nat \<Rightarrow> 'a list \<Rightarrow> 'a list"
  where
"myslice frm to xs = List.take (to - frm) (List.drop frm xs)"

subsection "Shallow Word Array Value Relation"

overloading
  valRel_WordArrayUX \<equiv> valRel
begin
  definition valRel_WordArrayUX: 
    "\<And>\<xi> x v. valRel_WordArrayUX (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (('a :: len8) word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      (if len_of TYPE('a) = 8 then 
        \<exists>xs. v = VAbstract (VWA (TPrim (Num U8)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. (xs ! i) = VPrim (LU8 (ucast (x ! i))))
      else if len_of TYPE('a) = 16 then 
        \<exists>xs. v = VAbstract (VWA (TPrim (Num U16)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. (xs ! i) = VPrim (LU16 (ucast (x ! i))))
      else if len_of TYPE('a) = 32 then 
        \<exists>xs. v = VAbstract (VWA (TPrim (Num U32)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. (xs ! i) = VPrim (LU32 (ucast (x ! i))))
      else if len_of TYPE('a) = 64 then 
        \<exists>xs. v = VAbstract (VWA (TPrim (Num U64)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. (xs ! i) = VPrim (LU64 (ucast (x ! i))))
      else False)"
end

(* Alternate definitions for the valRel relations for word arrays


overloading
  valRel_WordArrayU8 \<equiv> valRel
begin
  definition valRel_WordArrayU8: 
    "\<And>\<xi> x v. valRel_WordArrayU8 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (8 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA (TPrim (Num U8)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU8 (x ! i)))"
end

overloading
  valRel_WordArrayU16 \<equiv> valRel
begin
  definition valRel_WordArrayU16: 
    "\<And>\<xi> x v. valRel_WordArrayU16 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (16 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA (TPrim (Num U16)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU16 (x ! i)))"
end

overloading
  valRel_WordArrayU32 \<equiv> valRel
begin
  definition valRel_WordArrayU32: 
    "\<And>\<xi> x v. valRel_WordArrayU32 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (32 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA (TPrim (Num U32)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU32 (x ! i)))"
end

overloading
  valRel_WordArrayU64 \<equiv> valRel
begin
  definition valRel_WordArrayU64: 
    "\<And>\<xi> x v. valRel_WordArrayU64 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (64 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA (TPrim (Num U64)) xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU64 (x ! i)))"
end


*)
subsection "Shallow Word Array Function Definitions"

overloading
  wordarray_put2' \<equiv> wordarray_put2
begin
definition wordarray_put2':
 "wordarray_put2' (x :: ('a WordArray, 32 word, 'a) WordArrayPutP) \<equiv> (WordArrayPutP.arr\<^sub>f x)[unat (WordArrayPutP.idx\<^sub>f x) := WordArrayPutP.val\<^sub>f x]" 
end

overloading
  wordarray_length' \<equiv> wordarray_length
begin
definition wordarray_length':
 "wordarray_length' (x :: 'a WordArray) \<equiv> (of_nat (length x) :: 32 word)" 
end

overloading
  wordarray_get' \<equiv> wordarray_get
begin
definition wordarray_get':
 "wordarray_get' (x :: (('a::len8) word WordArray, 32 word) RR) \<equiv> (if unat (RR.p2\<^sub>f x) < length (RR.p1\<^sub>f x) then (RR.p1\<^sub>f x) ! unat (RR.p2\<^sub>f x) else 0)" 
end


overloading
  wordarray_fold_no_break' \<equiv> wordarray_fold_no_break
begin
definition wordarray_fold_no_break':
 "wordarray_fold_no_break' (x :: ('a WordArray, 32 word, 32 word, ('a, 'acc, 'obsv) ElemAO \<Rightarrow> 'acc, 'acc, 'obsv) WordArrayMapP) \<equiv> 
    fold (\<lambda>a b. (WordArrayMapP.f\<^sub>f x) (ElemAO.make a b (WordArrayMapP.obsv\<^sub>f x))) 
         (myslice (unat (WordArrayMapP.frm\<^sub>f x)) (unat (WordArrayMapP.to\<^sub>f x)) (WordArrayMapP.arr\<^sub>f x)) 
         (WordArrayMapP.acc\<^sub>f x)" 
end


fun mapAccum :: "('a \<Rightarrow> 'b  \<Rightarrow> ('c \<times> 'b)) \<Rightarrow> 'a list \<Rightarrow> 'b \<Rightarrow> ('c list \<times> 'b)"
  where
"mapAccum _ [] acc = ([], acc)" |
"mapAccum f (x#xs) acc = 
  (let (a, b) = f x acc;
       (as, b') = mapAccum f xs b
   in (a#as, b'))"

fun listAccumStep :: "('a \<Rightarrow> 'b  \<Rightarrow> ('c \<times> 'b)) \<Rightarrow> 'a \<Rightarrow> ('c list \<times> 'b) \<Rightarrow> ('c list \<times> 'b)"
  where
"listAccumStep f x (ys, acc) = (let (y, acc') = f x acc in (ys @ [y], acc'))"

lemma mapAccum_step:
  "mapAccum f (xs @ [x]) acc = listAccumStep f x (mapAccum f xs acc)"
  apply (induct arbitrary: x acc rule: list.induct)
   apply clarsimp
  apply (clarsimp split: prod.split)
  done


lemma mapAccum_length:
  "length (prod.fst (mapAccum f xs acc)) = length xs"
  apply (induct arbitrary: acc rule: rev_induct)
   apply simp
  apply (subst mapAccum_step)
  apply clarsimp
  apply (drule_tac x = acc in meta_spec)
  by (metis (no_types, lifting) Product_Type.split_def fst_conv length_append_singleton listAccumStep.simps prod.collapse)


lemma 
  "map f xs = prod.fst (mapAccum (\<lambda>a b. (f a, b)) xs ())"
  by (induct xs; clarsimp split: prod.split)

lemma
  "fold f xs acc = prod.snd (mapAccum (\<lambda>a b. (a, f a b)) xs acc)"
  apply (induct rule: rev_induct; clarsimp split: prod.split)
  apply (subst mapAccum_step)
  by (metis (no_types, lifting) case_prod_beta listAccumStep.simps prod.collapse snd_conv)



fun cogent_isa_pair :: "('a, 'b) RR \<Rightarrow> ('a \<times> 'b)"
  where
"cogent_isa_pair x = (RR.p1\<^sub>f x, RR.p2\<^sub>f x)"

term "mapAccum 
          (\<lambda>a b. cogent_isa_pair ((WordArrayMapP.f\<^sub>f x) (ElemAO.make a b (WordArrayMapP.obsv\<^sub>f x)))) 
          (myslice (unat (WordArrayMapP.frm\<^sub>f x)) (unat (WordArrayMapP.to\<^sub>f x)) (WordArrayMapP.arr\<^sub>f x)) 
          (WordArrayMapP.acc\<^sub>f x)"
overloading
  wordarray_map_no_break' \<equiv> wordarray_map_no_break
begin
definition wordarray_map_no_break':
 "wordarray_map_no_break' (x :: ('a WordArray, 32 word, 32 word, ('a, 'acc, 'obsv) ElemAO \<Rightarrow> ('a, 'acc) RR, 'acc, 'obsv) WordArrayMapP) \<equiv> 
    (let xs = List.take (unat (WordArrayMapP.frm\<^sub>f x)) (WordArrayMapP.arr\<^sub>f x);
         zs = List.drop (unat (WordArrayMapP.to\<^sub>f x)) (WordArrayMapP.arr\<^sub>f x);
        (ys, acc) = mapAccum 
          (\<lambda>a b. cogent_isa_pair ((WordArrayMapP.f\<^sub>f x) (ElemAO.make a b (WordArrayMapP.obsv\<^sub>f x)))) 
          (myslice (unat (WordArrayMapP.frm\<^sub>f x)) (unat (WordArrayMapP.to\<^sub>f x)) (WordArrayMapP.arr\<^sub>f x)) 
          (WordArrayMapP.acc\<^sub>f x)
    in (if (WordArrayMapP.frm\<^sub>f x) \<le> (WordArrayMapP.to\<^sub>f x) 
        then RR.make (xs @ ys @ zs) acc 
        else RR.make (WordArrayMapP.arr\<^sub>f x) acc))" 
end

context WordArray begin

subsection "Abbreviations"

abbreviation upd_store :: "('f, 'a, 'l) store \<Rightarrow> 'l \<Rightarrow> ('f, 'a, 'l) uval \<Rightarrow> ('f, 'a, 'l) store"
  where
"upd_store \<sigma> p v \<equiv> (\<lambda>l. (if l = p then option.Some v else \<sigma> l))" 

subsection "Level 0 \<xi> Abstractions"

\<comment>\<open> This section contains the abstractions for first order calls to word array functions \<close>

subsubsection "Update Semantics"

definition upd_wa_put2_0
  where
  "upd_wa_put2_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in (\<exists>p idx val t len arr. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num t)]), RPtr (RCon ''WordArray'' [RPrim (Num t)])),
          (UPrim (LU32 idx), RPrim (Num U32)), (val, RPrim (Num t))] \<and>
          x1 p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and>
          y2 = UPtr p (RCon ''WordArray'' [RPrim (Num t)]) \<and>
          (if idx < len 
              then y1 = upd_store x1 (arr + size_of_num_type t * idx) val
              else y1 = x1)))"

definition upd_wa_get_0
  where
  "upd_wa_get_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p idx t len arr. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num t)]), RPtr (RCon ''WordArray'' [RPrim (Num t)])),
          (UPrim (LU32 idx), RPrim (Num U32))] \<and> x1 p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and>
          (idx < len \<longrightarrow> x1 (arr + size_of_num_type t * idx) = option.Some y2) \<and>
            (\<not> idx < len \<longrightarrow> y2 = UPrim (zero_num_lit t))))"

definition upd_wa_length_0
  where
  "upd_wa_length_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p t len arr. x2 = UPtr p (RCon ''WordArray'' [RPrim (Num t)]) \<and>
          x1 p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and> y2 = UPrim (LU32 len)))"

fun \<xi>0 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>0 x y z = 
    (if x = ''wordarray_put2_0'' then upd_wa_put2_0 y z
     else if x = ''wordarray_get_0'' then upd_wa_get_0 y z
     else if x = ''wordarray_length_0'' then upd_wa_length_0 y z
     else False)" 

subsubsection "Value Semantics"

definition val_wa_length
  where
  "val_wa_length x y = (\<exists>xs len t. x = VAbstract (VWA (TPrim (Num t)) xs) \<and> y = VPrim (LU32 len) \<and> 
                          length xs = unat len)" 

definition val_wa_get
  where
  "val_wa_get x y =
      (\<exists>xs t idx v. x = VRecord [VAbstract (VWA (TPrim (Num t)) xs), VPrim (LU32 idx)] \<and>
       y = VPrim v \<and> lit_type v = Num t \<and> (unat idx < length xs \<longrightarrow> xs ! unat idx = y) \<and> 
       (\<not> unat idx < length xs \<longrightarrow> zero_num_lit t = v))" 

definition val_wa_put2
  where
  "val_wa_put2 x y =
      (\<exists>xs t idx val. x = VRecord [VAbstract (VWA (TPrim (Num t)) xs), VPrim (LU32 idx), VPrim val] \<and>
       lit_type val = Num t \<and> y = VAbstract (VWA (TPrim (Num t)) (xs[unat idx := VPrim val])))" 


fun \<xi>m :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>m x y z = 
    (if x = ''wordarray_put2_0'' then val_wa_put2 y z
     else if x = ''wordarray_get_0'' then val_wa_get y z
     else if x = ''wordarray_length_0'' then val_wa_length y z
     else False)" 

fun \<xi>p :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>p x y z = 
    (if x = ''wordarray_put2'' then val_wa_put2 y z
     else if x = ''wordarray_get'' then val_wa_get y z
     else if x = ''wordarray_length'' then val_wa_length y z
     else False)" 

subsection "Level 1 \<xi> Abstractions"

\<comment>\<open> This section contains the abstractions for second order calls to word array functions.
    Note that in order to show termination, abstractions on this level can only call other
    abstractions from level 0. So far, this seems to be the best solution, however, when more
    levels are introduced, i.e. when third, fourth ... calls are introduced, these abstractions
    should probably be automatically generated. \<close>

subsubsection "Update Semantics"

lemma valid_ptr_not_in_frame_same:
  "\<lbrakk>frame \<sigma> w \<sigma>' w'; p \<notin> w; \<sigma> p = option.Some x\<rbrakk> \<Longrightarrow> \<sigma>' p = option.Some x"
  apply (clarsimp simp: frame_def)
  apply (erule_tac x = p in allE)
  apply clarsimp
  done

lemma frame_single_update:
  "frame \<sigma> {l} (upd_store \<sigma> l v) {l}"
  by (clarsimp simp: frame_def)

type_synonym ('f, 'a, 'l) ufoldmapdef = "(char list, atyp, 32 word) uabsfuns \<Rightarrow> ('f, 'a, 'l) store \<Rightarrow> 
                                         32 word \<Rightarrow> 32 word \<Rightarrow> 32 word \<Rightarrow>
                                        'f expr \<Rightarrow> ('f, 'a, 'l) uval \<Rightarrow> ('f, 'a, 'l) uval \<Rightarrow> ptrtyp set\<Rightarrow>
                                        (('f, 'a, 'l) store \<times> ('f, 'a, 'l) uval) \<Rightarrow> bool"
(*
function upd_wa_mapnb_bod_0 :: "(char list, atyp, 32 word) ufoldmapdef"
  where
  "upd_wa_mapnb_bod_0 \<xi>\<^sub>u \<sigma> p frm to f acc (obsv, s) res = (\<exists>t len arr. 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim t) len arr)) \<and> 
    (if frm < min to len then (\<exists>v v' acc' \<sigma>'. \<sigma> (arr + 4 * frm) = option.Some (UPrim (LU32 v)) \<and> 
         (\<xi>\<^sub>u, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), (acc, upd.uval_repr acc), (obsv, upd.uval_repr obsv)])] \<turnstile> 
            (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>', URecord [(UPrim (LU32 v'), RPrim (Num U32)), (acc', upd.uval_repr acc')])) \<and>
          \<sigma> p = \<sigma>' p \<and> (\<forall>i<len. \<sigma> (arr + 4 * i) = \<sigma>' (arr + 4 * i)) \<and> (upd.uval_repr acc = upd.uval_repr  acc') \<and>
          upd_wa_mapnb_bod_0 \<xi>\<^sub>u (\<lambda>l.(if l = arr + 4 * frm then option.Some (UPrim (LU32 v')) else \<sigma>' l))
             p (frm + 1) to f acc' (obsv, s) res) 
    else (\<sigma>, URecord [(
        UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
         (acc, upd.uval_repr acc)]) = res))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, _, frm, to, _, _, _, _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done
*)

function upd_wa_foldnb_bod :: "(char list, atyp, 32 word) ufoldmapdef"
  where
  "upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s res = (\<exists>t len arr. 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and> 
    (\<forall>i<len. \<exists>v. \<sigma> (arr + size_of_num_type t * i) = option.Some v) \<and>
    (if frm < min to len then (\<exists>v acc' \<sigma>' w1 w2. \<sigma> (arr + size_of_num_type t * frm) = option.Some v \<and> 
          (\<xi>\<^sub>u, [(URecord [(v, upd.uval_repr v), (acc, upd.uval_repr acc), 
            (obsv, upd.uval_repr obsv)])] \<turnstile> (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>', acc')) \<and>
          frame \<sigma> w1 \<sigma>' w2 \<and> ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {} \<and>
          upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma>' p (frm + 1) to f acc' obsv s res) 
    else (\<sigma>, acc) = res))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, _, frm, to, _, _, _, _,  _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done

declare upd_wa_foldnb_bod.simps[simp del]

lemma upd_wa_foldnb_bod_to_geq_len:
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm len f acc obsv s (\<sigma>', r); \<sigma> p = option.Some (UAbstract (UWA t len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r)"
  apply (induct rule: upd_wa_foldnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (subst (asm) upd_wa_foldnb_bod.simps)
  apply (clarsimp split: if_splits)
  apply (erule disjE; clarsimp)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule conjI; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>' in exI)
    apply clarsimp
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI; clarsimp)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = p in allE; clarsimp)
   apply (rule FalseE)
   apply auto[1]
  apply (subst upd_wa_foldnb_bod.simps)
  apply clarsimp
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = \<sigma>' in meta_spec)
  apply clarsimp
  apply (rule_tac x = acc' in exI)
  apply (rule_tac x = \<sigma>' in exI)
  apply clarsimp
  apply (rule_tac x = w1 in exI)
  apply clarsimp
  apply (rule conjI)
   apply (rule_tac x = x in exI; clarsimp)
  apply (erule meta_mp)
  apply (drule_tac p = p in valid_ptr_not_in_frame_same; simp)
  done

lemma upd_wa_foldnb_bod_to_geq_lenD:
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); \<sigma> p = option.Some (UAbstract (UWA t len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm len f acc obsv s (\<sigma>', r)"
  apply (induct rule: upd_wa_foldnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (subst (asm) upd_wa_foldnb_bod.simps)
  apply (clarsimp split: if_splits)
  apply (erule disjE; clarsimp)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule conjI)
    apply (rule_tac x = x in exI; clarsimp)
   apply (drule_tac p = p in valid_ptr_not_in_frame_same; simp?)
   apply (erule meta_impE; simp)
  apply (case_tac "frm < to")
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule conjI)
    apply (rule_tac x = x in exI; clarsimp)
   apply (drule_tac p = p in valid_ptr_not_in_frame_same; simp?)
   apply (erule meta_impE; simp)
  apply clarsimp
  apply (subgoal_tac "\<not> frm < len")
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
  apply auto
  done

lemma upd_wa_foldnb_bod_step:
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)); frm \<le> to; to < len; 
    \<sigma> (arr + size_of_num_type t * to) = option.Some v; frame \<sigma>' w1 \<sigma>'' w2; 
    ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {};
    \<xi>\<^sub>u, [URecord [(v, upd.uval_repr v), (r, upd.uval_repr r), (obsv, upd.uval_repr obsv)]] \<turnstile> (\<sigma>', App f (Var 0))\<Down>! (\<sigma>'', r')\<rbrakk> 
    \<Longrightarrow> upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm (to + 1) f acc obsv s (\<sigma>'', r')"
  apply (induct arbitrary: r  \<sigma>'
                rule: upd_wa_foldnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (erule upd_wa_foldnb_bod.elims)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>'''' in meta_spec)
   apply (drule_tac x = b in meta_spec)
   apply (drule_tac x = a in meta_spec)
   apply clarsimp
   apply (subst upd_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule conjI; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>'''' in exI)
    apply clarsimp
    apply (rule_tac x = w1a in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI; clarsimp)
    apply (case_tac "frma + 1 \<le> toa")
     apply clarsimp
     apply (frule_tac p = pa and w = w1a in valid_ptr_not_in_frame_same; simp?)
     apply (frule_tac p = "arr + size_of_num_type t * toa" and w = w1a in valid_ptr_not_in_frame_same; simp?)
      apply blast
     apply clarsimp
    apply (clarsimp simp: not_le)
    apply (drule_tac i = frma and m = toa in inc_le)
    apply (rule FalseE)
    apply simp
   apply (clarsimp simp: not_less)
   apply (rule FalseE)
   apply (simp add: less_is_non_zero_p1 plus_one_helper2 word_le_not_less)
  apply (erule disjE)
   apply (subst upd_wa_foldnb_bod.simps; clarsimp)
   apply (rule conjI; clarsimp)
    apply (rule_tac x = r' in exI)
    apply (rule_tac x = \<sigma>'' in exI)
    apply (subst upd_wa_foldnb_bod.simps; clarsimp)
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = w2 in exI; clarsimp)
    apply (rule_tac x =  t in exI)
    apply (rule_tac x = len in exI)
    apply (rule_tac x = arr in exI)
    apply (rule conjI)
     apply (drule_tac p = pa in valid_ptr_not_in_frame_same; simp)
    apply clarsimp
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = va in exI)
    apply (drule_tac p = "arr + size_of_num_type t * i" in valid_ptr_not_in_frame_same; simp?)
    apply blast
   apply (clarsimp simp: not_less)
   apply (meson less_is_non_zero_p1 word_le_not_less word_overflow)
  apply (clarsimp simp: not_less)
  by auto

lemma upd_wa_foldnb_bod_back_step':
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); 
    \<sigma> p = option.Some (UAbstract (UWA t len arr)); len < to\<rbrakk>
    \<Longrightarrow> upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm (to - 1) f acc obsv s (\<sigma>', r)"
  apply (induct rule: upd_wa_foldnb_bod.induct[of _  \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', r)"]; clarsimp)
  apply (drule_tac x = len in meta_spec)
  apply (erule upd_wa_foldnb_bod.elims)  
  apply (subst upd_wa_foldnb_bod.simps)
  apply (clarsimp split: if_split_asm)
  apply (rule_tac x = ta in exI)
  apply (rule conjI; clarsimp)
   apply (cut_tac x = frma and n = "toa - 1" in plus_one_helper2; simp)
    apply auto[1]
   apply clarsimp
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>'' in meta_spec)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>'' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule conjI)
    apply (rule_tac x = x in exI; clarsimp)
   apply (erule meta_mp)
   apply (drule_tac p = pa in valid_ptr_not_in_frame_same; simp)
  apply (rule FalseE)
  by (metis (no_types, hide_lams) less_1_simp word_le_less_eq word_not_le)

lemma upd_wa_foldnb_bod_back_step:
  "\<lbrakk>upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm (1 + to) f acc obsv s (\<sigma>', r); 1 + to \<le> len; frm < 1 + to; 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr))\<rbrakk>
    \<Longrightarrow> \<exists>\<sigma>'' r'' w1 w2 v. upd_wa_foldnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>'', r'') \<and> 
        \<sigma> (arr + size_of_num_type t * to) = option.Some v \<and>
        (\<xi>\<^sub>u, [URecord [(v, upd.uval_repr v), (r'', upd.uval_repr r''), 
          (obsv, upd.uval_repr obsv)]] \<turnstile> (\<sigma>'', App f (Var 0))\<Down>! (\<sigma>', r)) \<and>
        frame \<sigma>'' w1 \<sigma>' w2 \<and> ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {}"
  apply (induct arbitrary: \<sigma>' r
                rule: upd_wa_foldnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', r)"]; clarsimp)
  apply (erule upd_wa_foldnb_bod.elims)  
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>''' in meta_spec)
   apply (drule_tac x = a in meta_spec)
   apply (drule_tac x = b in meta_spec)
   apply clarsimp
   apply (case_tac "frma < to"; clarsimp)
    apply (drule meta_mp)
     apply (metis (no_types, hide_lams) add.commute inc_le plus_le_left_cancel_wrap word_le_less_eq word_le_not_less word_plus_strict_mono_right)
    apply (drule meta_mp)
     apply (drule_tac p = pa in valid_ptr_not_in_frame_same; simp)
    apply clarsimp
    apply (rule_tac x = \<sigma>'''' in exI)
    apply (rule_tac x = r'' in exI)
    apply (rule conjI)
     apply (subst upd_wa_foldnb_bod.simps; clarsimp)
     apply (rule_tac x = acc' in exI)
     apply (rule_tac x = \<sigma>''' in exI)
     apply clarsimp
     apply (rule_tac x = w1 in exI)
     apply clarsimp
     apply (rule_tac x = x in exI)
     apply clarsimp
    apply (rule_tac x = w1a in exI)
    apply (rule_tac x = w2 in exI)
    apply (erule_tac x = to in allE; clarsimp)
    apply (erule impE)
     apply (metis (no_types, hide_lams) add.commute less_is_non_zero_p1 plus_one_helper plus_one_helper2 word_neq_0_conv word_not_le)
    apply (rule_tac x = va in exI)
    apply clarsimp
    apply (drule_tac p = "arr + size_of_num_type t * to" in valid_ptr_not_in_frame_same; simp; clarsimp)
    apply (drule_tac x = "arr + size_of_num_type t * to" in orthD1; simp)
    apply (rule disjI2)
    apply (rule_tac x = to in exI)
    apply clarsimp
    apply (metis (no_types, hide_lams) add.commute plus_one_helper2  word_not_le word_not_simps(1))
   apply (subgoal_tac "frma = to")
    apply clarsimp
    apply (subst upd_wa_foldnb_bod.simps; clarsimp simp: add.commute)
    apply (erule upd_wa_foldnb_bod.elims; clarsimp simp: add.commute)
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule_tac x = x in exI)
    apply clarsimp
   apply (metis add.commute le_step)
  apply (rule FalseE)
  by auto

function upd_wa_mapAccumnb_bod :: "(char list, atyp, ptrtyp) ufoldmapdef"
  where
  "upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s res = (\<exists>t len arr. 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and> 
    (\<forall>i<len. \<exists>v. \<sigma> (arr + size_of_num_type t * i) = option.Some v) \<and>
    (\<forall>i<len. p \<noteq> (arr + size_of_num_type t * i)) \<and>
    (if frm < min to len then 
      (\<exists>v v' acc' \<sigma>' w1 w2. \<sigma> (arr + size_of_num_type t * frm) = option.Some v \<and>
      (\<xi>\<^sub>u, [(URecord [(v, upd.uval_repr v), (acc, upd.uval_repr acc), (obsv, upd.uval_repr obsv)])]
        \<turnstile> (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>', URecord [ (v', upd.uval_repr v'), (acc', upd.uval_repr acc')])) \<and>
      frame \<sigma> w1 \<sigma>' w2 \<and> ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {} \<and>
      upd_wa_mapAccumnb_bod \<xi>\<^sub>u (upd_store \<sigma>'(arr + size_of_num_type t * frm) v') p (frm + 1) to f 
        acc' obsv s res) 
    else res = (\<sigma>, URecord [
      (UPtr p (RCon ''WordArray'' [RPrim (Num t)]), RPtr (RCon ''WordArray'' [RPrim (Num t)])), 
      (acc, upd.uval_repr acc)])))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, _, frm, to, _, _, _, _,  _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done

declare upd_wa_mapAccumnb_bod.simps[simp del]

lemma upd_wa_mapAccumnb_bod_to_geq_len:
  "\<lbrakk>upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm len f acc obsv s (\<sigma>', r); \<sigma> p = option.Some (UAbstract (UWA t len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r)"
  apply (induct rule: upd_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', r)"])
  apply clarsimp
  apply (case_tac "frm \<ge> len")
   apply (erule upd_wa_mapAccumnb_bod.elims; clarsimp split: if_splits)
   apply (drule_tac x = frma in leD; clarsimp)
   apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
  apply (erule upd_wa_mapAccumnb_bod.elims)
  apply (clarsimp split: if_split_asm)
  apply (drule_tac x = frma in not_le_imp_less; clarsimp)
  apply (drule_tac x = ta in meta_spec)
  apply (drule_tac x = len in meta_spec)
  apply (drule_tac x = arr in meta_spec)
  apply (drule_tac x = v' in meta_spec)
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = \<sigma>'' in meta_spec)
  apply clarsimp
  apply (drule meta_mp)
   apply (drule_tac c = to in order.strict_trans2; simp)
  apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
  apply (frule_tac c = to in order.strict_trans2; simp)
  apply (rule_tac x = v' in exI)
  apply (rule_tac x = acc' in exI)
  apply (rule_tac x = \<sigma>'' in exI)
  apply clarsimp
  apply (rule_tac x = w1 in exI)
  apply clarsimp
  apply (rule conjI)
   apply (rule_tac x = x in exI)
   apply clarsimp
  apply (erule meta_impE; simp?)
  apply (drule_tac p = pa in valid_ptr_not_in_frame_same; simp)
  done

lemma upd_wa_mapAccumnb_bod_to_geq_lenD:
  "\<lbrakk>upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); \<sigma> p = option.Some (UAbstract (UWA t len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm len f acc obsv s (\<sigma>', r)"
  apply (induct rule: upd_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', r)"])
  apply clarsimp
 apply (case_tac "frm \<ge> len")
   apply (erule upd_wa_mapAccumnb_bod.elims; clarsimp split: if_splits)
   apply (drule_tac x = frma in leD; clarsimp)
   apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
  apply (erule upd_wa_mapAccumnb_bod.elims)
  apply (clarsimp split: if_split_asm)
  apply (drule_tac x = frma in not_le_imp_less; clarsimp)
  apply (frule_tac c = toa in order.strict_trans2; clarsimp)
  apply (drule_tac x = ta in meta_spec)
  apply (drule_tac x = len in meta_spec)
  apply (drule_tac x = arr in meta_spec)
  apply (drule_tac x = v' in meta_spec)
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = \<sigma>'' in meta_spec)
  apply clarsimp
  apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
  apply (rule_tac x = v' in exI)
  apply (rule_tac x = acc' in exI)
  apply (rule_tac x = \<sigma>'' in exI)
  apply clarsimp
  apply (rule_tac x = w1 in exI)
  apply clarsimp
  apply (rule conjI)
   apply (rule_tac x = x in exI)
   apply clarsimp
  apply (erule meta_impE; simp?)
  apply (drule_tac p = pa in valid_ptr_not_in_frame_same; simp)
  done

lemma upd_wa_mapAccumnb_bod_preservation':
  "\<lbrakk>upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s r; \<sigma> p = option.Some (UAbstract (UWA t len arr))\<rbrakk>
    \<Longrightarrow> \<exists>\<sigma>' racc. r = (\<sigma>', URecord [
      (UPtr p (RCon ''WordArray'' [type_repr t]), RPtr (RCon ''WordArray'' [type_repr t])),
      (racc, upd.uval_repr racc)])"
  apply (induct rule: upd_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s r])
  apply (erule upd_wa_mapAccumnb_bod.elims; clarsimp split: if_splits)
  apply (erule disjE; clarsimp)
  apply (drule_tac x = ta in meta_spec)
  apply (drule_tac x = len in meta_spec)
  apply (drule_tac x = arr in meta_spec)
  apply (drule_tac x = v' in meta_spec)
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = \<sigma>'' in meta_spec)
  apply clarsimp
  apply (drule_tac p = pa in valid_ptr_not_in_frame_same; simp?)
  apply clarsimp
  done

lemma upd_wa_mapAccumnb_bod_step:
  "\<lbrakk>upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', URecord [rp, (r, upd.uval_repr r)]); 
    \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)); frm \<le> to; to < len;
    unat (size_of_num_type t) * unat len \<le> unat (max_word :: ptrtyp);
    \<sigma> (arr + size_of_num_type t * to) = option.Some v; frame \<sigma>' w1 \<sigma>'' w2; 
    ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {};
    \<xi>\<^sub>u, [URecord [(v, upd.uval_repr v), (r, upd.uval_repr r), (obsv, upd.uval_repr obsv)]] \<turnstile> 
      (\<sigma>', App f (Var 0))\<Down>! (\<sigma>'', URecord [ (v', upd.uval_repr v'), (r', upd.uval_repr r')])\<rbrakk> 
    \<Longrightarrow> upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm (to + 1) f acc obsv s 
      (upd_store \<sigma>'' (arr + size_of_num_type t * to) v', URecord [rp, (r', upd.uval_repr r')])"
  apply (induct arbitrary: r \<sigma>'
                rule: upd_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', URecord [rp, (r, upd.uval_repr r)])"])
  apply clarsimp
  apply (drule_tac x = t in meta_spec)
  apply (drule_tac x = len in meta_spec)
  apply (drule_tac x = arr in meta_spec)
  apply (erule upd_wa_mapAccumnb_bod.elims; clarsimp split: if_splits)
   apply (drule_tac x = v'a in meta_spec)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>'''' in meta_spec)
   apply (drule_tac x = r in meta_spec)
   apply (drule_tac x = a in meta_spec)
   apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
   apply (rule conjI; clarsimp)
    apply (rule_tac x = v'a in exI)
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>'''' in exI)
    apply clarsimp
    apply (rule_tac x = w1a in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI)
     apply clarsimp
    apply (drule meta_mp)
     apply (drule_tac p = pa and w = w1a in valid_ptr_not_in_frame_same; simp)
    apply (drule meta_mp)
     apply (simp add: inc_le)
    apply (drule meta_mp; simp)
    apply (rule conjI; clarsimp)
     apply (drule_tac a = frma and b = toa in word_mult_cancel_left_bounded[rotated 2]; simp)
     apply (erule disjE)
      apply (case_tac t; clarsimp)
     apply (rule FalseE)
     apply blast
    apply (drule_tac p = "arr + size_of_num_type t * toa" and w = w1a in valid_ptr_not_in_frame_same; simp)
    apply blast
   apply (rule FalseE)
   apply (simp add: less_is_non_zero_p1 plus_one_helper2)
  apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
  apply (rule conjI; clarsimp)
   apply (rule_tac x = v' in exI)
   apply (rule_tac x = r' in exI)
   apply (rule_tac x = \<sigma>'' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule conjI)
    apply (rule_tac x = w2 in exI)
    apply clarsimp
   apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
   apply (rule_tac x = len in exI)
   apply (rule_tac x = arr in exI)
   apply clarsimp
   apply (rule conjI)
    apply (drule_tac p = pa in valid_ptr_not_in_frame_same; simp)
   apply clarsimp
   apply (erule_tac x = i in allE)
   apply clarsimp
   apply (rule_tac x = va in exI)
   apply (drule_tac p = "arr + size_of_num_type t * i" in valid_ptr_not_in_frame_same; simp?)
   apply blast
  apply (erule impE)
   apply (metis (no_types, hide_lams) add.commute dual_order.strict_trans less_le max_word_max word_Suc_le word_le_less_eq word_not_le)
  apply (rule FalseE)
  apply clarsimp
  by auto

lemma upd_wa_mapAccumnb_bod_back_step':
  "\<lbrakk>upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>', r); 
    \<sigma> p = option.Some (UAbstract (UWA t len arr)); len < to\<rbrakk>
    \<Longrightarrow> upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm (to - 1) f acc obsv s (\<sigma>', r)"
  apply (induct rule: upd_wa_mapAccumnb_bod.induct[of _  \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', r)"]; clarsimp)
  apply (erule upd_wa_mapAccumnb_bod.elims)
  apply (subst upd_wa_mapAccumnb_bod.simps)
  apply (clarsimp split: if_split_asm)
  apply (rule_tac x = ta in exI)
  apply (drule_tac x = ta in meta_spec)
  apply (drule_tac x = len in meta_spec)
  apply (drule_tac x = arr in meta_spec)
  apply (rule conjI; clarsimp)
   apply (cut_tac x = frma and n = "toa - 1" in plus_one_helper2; simp)
    apply auto[1]
   apply clarsimp
   apply (drule_tac x = v' in meta_spec)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>'' in meta_spec)
   apply (frule_tac p = pa in valid_ptr_not_in_frame_same; simp)
   apply clarsimp
   apply (rule_tac x = v' in exI)
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>'' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule_tac x = x in exI; clarsimp)
  apply (rule FalseE)
  apply (metis (no_types, hide_lams) not_less_iff_gr_or_eq word_less_cases)
  done

lemma upd_wa_mapAccumnb_bod_back_step:
  "\<lbrakk>upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm (1 + to) f acc obsv s (\<sigma>', URecord [rp, (r, upd.uval_repr r)]);
    unat (size_of_num_type t) * unat len \<le> unat (max_word :: ptrtyp);
    1 + to \<le> len; frm < 1 + to; \<sigma> p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr))\<rbrakk>
    \<Longrightarrow> \<exists>\<sigma>'' \<sigma>''' r'' w1 w2 v v'.
      upd_wa_mapAccumnb_bod \<xi>\<^sub>u \<sigma> p frm to f acc obsv s (\<sigma>'', URecord [rp, (r'', upd.uval_repr r'')]) \<and>
      \<sigma> (arr + size_of_num_type t * to) = option.Some v \<and>
      (\<xi>\<^sub>u, [URecord [(v, upd.uval_repr v), (r'', upd.uval_repr r''), (obsv, upd.uval_repr obsv)]] 
        \<turnstile> (\<sigma>'', App f (Var 0))\<Down>! (\<sigma>''', URecord [(v', upd.uval_repr v'), (r, upd.uval_repr r)])) \<and> 
      \<sigma>' = upd_store \<sigma>''' (arr + size_of_num_type t * to) v' \<and> frame \<sigma>'' w1 \<sigma>''' w2 \<and> 
      ({p} \<union> s \<union> {arr + size_of_num_type t * i | i. i < len}) \<inter> w1 = {}"
  apply (induct arbitrary: \<sigma>' r
                rule: upd_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>u \<sigma> p frm to f acc obsv s "(\<sigma>', URecord [rp, (r, upd.uval_repr r)])"]; clarsimp)
  apply (erule upd_wa_mapAccumnb_bod.elims)
  apply (drule_tac x = t in meta_spec)
  apply (drule_tac x = len in meta_spec)
  apply (drule_tac x = arr in meta_spec)
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = v' in meta_spec)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>''' in meta_spec)
   apply (drule_tac x = a in meta_spec)
   apply (drule_tac x = r in meta_spec)
   apply clarsimp
   apply (case_tac "frma < to"; clarsimp)
    apply (drule meta_mp)
     apply (metis (no_types, hide_lams) add.commute inc_le plus_le_left_cancel_wrap word_le_less_eq word_le_not_less word_plus_strict_mono_right)
    apply (drule meta_mp)
     apply (drule_tac p = pa in valid_ptr_not_in_frame_same; simp)
    apply clarsimp
    apply (rule_tac x = \<sigma>'''' in exI)
    apply (rule_tac x = \<sigma>''''' in exI)
    apply (rule_tac x = r'' in exI)
    apply (rule conjI)
     apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
     apply (rule_tac x = v' in exI)
     apply (rule_tac x = acc' in exI)
     apply (rule_tac x = \<sigma>''' in exI)
     apply clarsimp
     apply (rule_tac x = w1 in exI)
     apply clarsimp
     apply (rule_tac x = x in exI)
     apply clarsimp
    apply (rule_tac x = w1a in exI)
    apply (rule_tac x = w2 in exI)
    apply (rule_tac x = va in exI)
    apply clarsimp
    apply (rule conjI)
     apply (clarsimp split: if_splits)
     apply (drule_tac a = frma and b = to in word_mult_cancel_left_bounded[rotated 2]; simp?)
       apply (metis (no_types, hide_lams) add.commute less_imp_le plus_one_helper2 word_not_le word_not_simps(1))
      apply (erule disjE)
       apply (case_tac t; clarsimp)
      apply (rule FalseE)
      apply blast
     apply (erule_tac x = to in allE)
     apply (erule impE)
      apply (metis (no_types) add.commute plus_one_helper2 word_not_le word_not_simps(1))
     apply clarsimp
     apply (drule_tac p = "arr + size_of_num_type t * to" and w = w1 in valid_ptr_not_in_frame_same; simp)
      apply (drule_tac x = "arr + size_of_num_type t * to"  and S' = w1 in orthD1; simp)
      apply (rule disjI2)
      apply (rule_tac x = to in exI)
      apply clarsimp
      apply (metis (no_types) add.commute plus_one_helper2 word_not_le word_not_simps(1))
     apply clarsimp
    apply (rule_tac x = v'a in exI)
    apply clarsimp
   apply (rule_tac x = \<sigma>'' in exI)
   apply (rule_tac x = \<sigma>''' in exI)
   apply (rule_tac x = acca in exI)
   apply (subst upd_wa_mapAccumnb_bod.simps; clarsimp)
   apply (frule_tac p = pa in valid_ptr_not_in_frame_same; simp?)
   apply (rule conjI)
    apply (frule_tac t = "(TPrim (Num t))" and len = len and arr = arr 
      in upd_wa_mapAccumnb_bod_preservation'; simp?)
   apply (rule_tac x = w1 in exI)
   apply (rule_tac x = x in exI)
   apply (rule_tac x = v in exI)
   apply clarsimp
   apply (rule conjI)
    apply (drule linorder_class.antisym_conv1)
    apply (cut_tac x = frma and n = to in plus_one_helper; simp add: add.commute)
   apply (rule_tac x = v' in exI)
   apply (subgoal_tac "frma = to")
    apply (erule upd_wa_mapAccumnb_bod.elims)
    apply (clarsimp simp: add.commute)
   apply (metis (mono_tags, hide_lams) add.commute not_less_iff_gr_or_eq plus_one_helper word_le_not_less)
  apply (rule FalseE)
  by auto

fun is_uval_fun :: "('f, 'a, 'l) uval \<Rightarrow> bool"
  where
"is_uval_fun (UFunction _ _) = True" |
"is_uval_fun (UAFunction _ _) = True" |
"is_uval_fun _ = False"

fun uvalfun_to_exprfun :: "('f, 'a, 'l) uval \<Rightarrow> 'f expr"
  where
"uvalfun_to_exprfun (UFunction f ts) = Fun f ts" |
"uvalfun_to_exprfun (UAFunction f ts) = AFun f ts" |
"uvalfun_to_exprfun _ = undefined"

(* We will need to define a different wrapper for each type of accumulator so that we can prove
   that the frame constraints still hold when proving the proc_env_matches_ptrs constraint.
   This is because we do not know what the set of writeable pointers are unless we know the
   type of the accumulator *)

definition upd_wa_foldnb_0
  where
  "upd_wa_foldnb_0 \<Xi>' \<xi>\<^sub>u \<tau> y z = 
    (let (y1, y2) = y
      in (\<exists>p frm to func acc obsv t u v a0 a1 a2 ra wa rb.
        y2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num t)]), RPtr (RCon ''WordArray'' [RPrim (Num t)])),
                      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
                      (func, RFun), (acc, upd.uval_repr acc), (obsv, upd.uval_repr obsv)] \<and> 
        (\<exists>len arr. y1 p = option.Some (UAbstract (UWA (TPrim (Num t)) len arr)) \<and> 
          (\<forall>i<len. \<exists>x. y1 (arr + size_of_num_type t * i) = option.Some (UPrim x) \<and> lit_type x = Num t)) \<and> 
        is_uval_fun func \<and> upd.uval_typing \<Xi>' y1 acc u ra wa \<and> upd.uval_typing \<Xi>' y1 obsv v rb {} \<and>
        \<tau> = TRecord [(a0, TPrim (Num t), Present), (a1, u, Present), (a2, v, Present)] Unboxed \<and>
        (\<Xi>', [], [option.Some \<tau>] \<turnstile> (App (uvalfun_to_exprfun func) (Var 0)) : TPrim (Num U32)) \<and> 
        upd_wa_foldnb_bod \<xi>\<^sub>u y1 p frm to (uvalfun_to_exprfun func) acc obsv (ra \<union> rb) z))"


fun \<xi>1 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' then upd_wa_foldnb_0 \<Xi> \<xi>0 abbreviatedType1 y z
     else if x = ''wordarray_map_no_break_0'' then False 
     else \<xi>0 x y z)" 

subsubsection "Value Semantics"

type_synonym ('f, 'a) vfoldmapdef = "(char list, vatyp) vabsfuns \<Rightarrow> type \<Rightarrow> ('f, 'a) vval list \<Rightarrow> nat \<Rightarrow> 
                                      nat \<Rightarrow> 'f expr \<Rightarrow> ('f, 'a) vval \<Rightarrow> ('f, 'a) vval \<Rightarrow> 
                                      ('f, 'a) vval \<Rightarrow> bool"

function val_wa_foldnb_bod :: "(char list, vatyp) vfoldmapdef"
  where
  "val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv res = 
    (if frm < min to (length xs)
      then (\<exists>acc'. (\<xi>\<^sub>v, [(VRecord [xs ! frm, acc, obsv])] \<turnstile> App f (Var 0) \<Down> acc') \<and>
          val_wa_foldnb_bod \<xi>\<^sub>v t xs (Suc frm) to f acc' obsv res)
    else acc = res)"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, _, frm, to, _, _, _, _). to - frm)"; clarsimp)
  apply linarith
  done
print_theorems
declare val_wa_foldnb_bod.simps[simp del]

lemma val_wa_foldnb_bod_append:
  "\<lbrakk>to \<le> length xs; val_wa_foldnb_bod \<xi>\<^sub>v t (xs @ [x]) frm to f acc obsv r\<rbrakk>
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r"
  apply (induct arbitrary: x 
                rule: val_wa_foldnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = x in meta_spec)
   apply clarsimp
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (clarsimp simp: nth_append)
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_append_incl_to:
  "\<lbrakk>frm < length (xs @ [x]); to > length xs; val_wa_foldnb_bod \<xi>\<^sub>v t (xs @ [x]) frm to f acc obsv r\<rbrakk>
    \<Longrightarrow> \<exists>r'. val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r' \<and> (\<xi>\<^sub>v, [VRecord [x, r', obsv]] \<turnstile> (App f (Var 0)) \<Down> r)"
  apply (induct arbitrary: x
                rule: val_wa_foldnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (case_tac "frm = length xs")
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (erule val_wa_foldnb_bod.elims)
   apply clarsimp
   apply (erule val_wa_foldnb_bod.elims)
   apply (clarsimp split: if_splits)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_splits)
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = x in meta_spec)
  apply clarsimp
  apply (rule_tac x = r' in exI)
  apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply (clarsimp simp: nth_append)
  apply (rule_tac x = acc' in exI)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_step:
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r; frm \<le> to; to < length xs; 
    \<xi>\<^sub>v, [VRecord [xs ! to, r, obsv]] \<turnstile> (App f (Var 0)) \<Down> (r')\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v t xs frm (Suc to) f acc obsv r'"
  apply (induct arbitrary: r'
                rule: val_wa_foldnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = r' in meta_spec)
   apply clarsimp
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  apply (rule_tac x = r' in exI)
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_to_geq_len:
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v t xs frm (length xs) f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_to_geq_lenD:
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v t xs frm (length xs) f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_back_step':
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v t xs frm (Suc to) f acc obsv r; length xs < Suc to\<rbrakk>
    \<Longrightarrow> val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_back_step:
  "\<lbrakk>val_wa_foldnb_bod \<xi>\<^sub>v t xs frm (Suc to) f acc obsv r; Suc to \<le> length xs; frm < Suc to\<rbrakk>
    \<Longrightarrow> \<exists>r'. val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r' \<and>
        (\<xi>\<^sub>v, [VRecord [xs ! to, r', obsv]] \<turnstile> (App f (Var 0)) \<Down> r)"
  apply (induct rule: val_wa_foldnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_foldnb_bod.elims)
  apply (clarsimp split: if_split_asm)
  apply (erule_tac x = acc' in meta_allE)
  apply clarsimp
  apply (case_tac "frma < to")
   apply clarsimp
   apply (rule_tac x = r' in exI)
   apply clarsimp
   apply (subst val_wa_foldnb_bod.simps; clarsimp)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply clarsimp
  apply (subgoal_tac "to = frma")
   apply clarsimp
   apply (erule val_wa_foldnb_bod.elims; clarsimp)
   apply (rule_tac x = acca in exI; clarsimp)
   apply (subst val_wa_foldnb_bod.simps; clarsimp)
  apply linarith
  done


lemma val_wa_foldnb_bod_preservation:
  "\<lbrakk>proc_ctx_wellformed \<Xi>'; val.proc_env_matches \<xi>\<^sub>v \<Xi>'; val_wa_foldnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r; 
    wa_abs_typing_v (VWA t xs) ''WordArray'' [t]; val.vval_typing \<Xi>' acc u; val.vval_typing \<Xi>' obsv v;
    \<Xi>', [], [option.Some (TRecord [(a0, (t, Present)), (a1, (u, Present)), 
      (a2, (v, Present))] Unboxed)] \<turnstile> App f (Var 0) : u; distinct [a0, a1, a2]\<rbrakk>
    \<Longrightarrow> val.vval_typing \<Xi>' r u"
  apply (induct to arbitrary: r)
   apply (erule val_wa_foldnb_bod.elims; clarsimp)
  apply (case_tac "length xs < Suc to")
   apply (drule val_wa_foldnb_bod_back_step'; simp)
  apply (case_tac "Suc to \<le> frm")
   apply (erule val_wa_foldnb_bod.elims; clarsimp)
  apply (drule val_wa_foldnb_bod_back_step; clarsimp)
  apply (drule_tac x = r' in meta_spec)
  apply (drule val.preservation(1)[of "[]" "[]" _ _ _  \<xi>\<^sub>v, simplified]; simp?)
  apply (clarsimp simp: val.matches_def)
  apply (rule val.v_t_record; simp?)
  apply (rule val.v_t_r_cons1)
   apply (clarsimp simp: wa_abs_typing_v_def)
   apply (case_tac t; clarsimp)
   apply (case_tac x5; clarsimp)
   apply (erule_tac x = to in allE; clarsimp)
   apply (rule val.v_t_prim'; clarsimp)
  apply (rule val.v_t_r_cons1; simp?)
  apply (rule val.v_t_r_cons1; simp?)
  apply (rule val.v_t_r_empty)
  done

function val_wa_mapAccumnb_bod :: "(char list, vatyp) vfoldmapdef"
  where
  "val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm to f acc obsv res = 
    (if frm < min to (length xs)
      then (\<exists>v acc'. (\<xi>\<^sub>v, [(VRecord [xs ! frm, acc, obsv])] \<turnstile> App f (Var 0) \<Down> VRecord [v, acc']) \<and>
          val_wa_mapAccumnb_bod \<xi>\<^sub>v t (xs[frm := v]) (Suc frm) to f acc' obsv res)
    else res = VRecord [VAbstract (VWA t xs), acc])"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, _, frm, to, _, _, _, _). to - frm)"; clarsimp)
  apply linarith
  done
print_theorems
declare val_wa_mapAccumnb_bod.simps[simp del]

lemma val_wa_mapAccumnb_bod_to_geq_len:
  "\<lbrakk>val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm (length xs) f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r"
  apply (induct rule: val_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_mapAccumnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = v in meta_allE)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_mapAccumnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = v in exI)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_mapAccumnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_mapAccumnb_bod_to_geq_lenD:
  "\<lbrakk>val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm (length xs) f acc obsv r"
  apply (induct rule: val_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_mapAccumnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = v in meta_allE)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_mapAccumnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = v in exI)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_mapAccumnb_bod.simps)
  apply clarsimp
  done


lemma val_wa_mapAccumnb_bod_step:
  "\<lbrakk>val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm to f acc obsv (VRecord [VAbstract (VWA t rxs), racc]); frm \<le> to;
    to < length xs; \<xi>\<^sub>v, [VRecord [xs ! to, racc, obsv]] \<turnstile> (App f (Var 0)) \<Down> VRecord [v, racc']\<rbrakk> 
    \<Longrightarrow> val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm (Suc to) f acc obsv (VRecord [VAbstract (VWA t (rxs[to := v])), racc'])"
  apply (induct arbitrary:rxs racc v racc'
                rule: val_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv 
                  "(VRecord [VAbstract (VWA t rxs), racc])"])
  apply clarsimp
  apply (erule val_wa_mapAccumnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = va in meta_spec)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = rxs in meta_spec)
   apply (drule_tac x = racc in meta_spec)
   apply (drule_tac x = v in meta_spec)
   apply (drule_tac x = racc' in meta_spec)
   apply clarsimp
   apply (subst val_wa_mapAccumnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = va in exI)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_mapAccumnb_bod.simps)
  apply clarsimp
  apply (rule_tac x = v in exI)
  apply (rule_tac x = racc' in exI)
  apply (subst val_wa_mapAccumnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_mapAccumnb_bod_back_step':
  "\<lbrakk>val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm (Suc to) f acc obsv r; length xs < Suc to\<rbrakk>
    \<Longrightarrow> val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r"
  apply (induct rule: val_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r]; clarsimp)
  apply (erule val_wa_mapAccumnb_bod.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = v in meta_allE)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_mapAccumnb_bod.simps)
   apply clarsimp
   apply (rule_tac x = v in exI)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_mapAccumnb_bod.simps)
  apply clarsimp
  done

lemma val_wa_mapAccumnb_bod_back_step:
  "\<lbrakk>val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm (Suc to) f acc obsv (VRecord [VAbstract (VWA t rxs), racc]); 
    Suc to \<le> length xs; frm < Suc to\<rbrakk>
    \<Longrightarrow> \<exists>racc'.
      val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm to f acc obsv (VRecord [VAbstract (VWA t (rxs[to := xs ! to])), racc']) \<and>
      (\<xi>\<^sub>v, [VRecord [xs ! to, racc', obsv]] \<turnstile> (App f (Var 0)) \<Down> VRecord [rxs ! to, racc])"
  apply (induct arbitrary: rxs racc
                rule: val_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv 
                  "VRecord [VAbstract (VWA t rxs), racc]"])
  apply clarsimp
  apply (erule val_wa_mapAccumnb_bod.elims)
  apply (clarsimp split: if_split_asm)
  apply (erule_tac x = v in meta_allE)
  apply (erule_tac x = acc' in meta_allE)
  apply (erule_tac x = rxs in meta_allE)
  apply (erule_tac x = racc in meta_allE)
  apply clarsimp
  apply (case_tac "frma < to")
   apply clarsimp
   apply (rule_tac x = racc' in exI)
   apply clarsimp
   apply (subst val_wa_mapAccumnb_bod.simps; clarsimp)
   apply (rule_tac x = v in exI)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply clarsimp
  apply (subgoal_tac "to = frma")
   apply clarsimp
   apply (erule val_wa_mapAccumnb_bod.elims; clarsimp)
   apply (rule_tac x = acca in exI; clarsimp)
   apply (subst val_wa_mapAccumnb_bod.simps; clarsimp)
  apply linarith
  done

lemma val_wa_mapAccumnb_bod_preservation':
  "val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r 
    \<Longrightarrow> \<exists>rxs racc. r = VRecord [VAbstract(VWA t rxs), racc] \<and> length rxs = length xs"
  apply (induct rule: val_wa_mapAccumnb_bod.induct[of _ \<xi>\<^sub>v t xs frm to f acc obsv r])
  apply (erule val_wa_mapAccumnb_bod.elims; clarsimp split: if_split_asm)
  done

lemma val_wa_mapAccumnb_bod_preservation:
  "\<lbrakk>proc_ctx_wellformed \<Xi>'; val.proc_env_matches \<xi>\<^sub>v \<Xi>'; val_wa_mapAccumnb_bod \<xi>\<^sub>v t xs frm to f acc obsv r; 
    wa_abs_typing_v (VWA t xs) ''WordArray'' [t]; val.vval_typing \<Xi>' acc u; val.vval_typing \<Xi>' obsv v;
    \<Xi>', [], [option.Some (TRecord [(a0, (t, Present)), (a1, (u, Present)), 
      (a2, (v, Present))] Unboxed)] \<turnstile> App f (Var 0) : 
      TRecord [(b0, (t, Present)), (b1, (u, Present))] Unboxed; 
    distinct [a0, a1, a2]; distinct [b0, b1]\<rbrakk>
    \<Longrightarrow> val.vval_typing \<Xi>' r (TRecord [
      (b0, (TCon ''WordArray'' [t] (Boxed Writable ptrl), Present)),
      (b1, (u, Present))] Unboxed)"
  apply (induct to arbitrary: r)
   apply (erule val_wa_mapAccumnb_bod.elims; clarsimp)
   apply (rule val.v_t_record; simp?)
   apply (rule val.v_t_r_cons1; simp?)
    apply (rule val.v_t_abstract; simp)
    apply (clarsimp simp: wa_abs_typing_v_def)
    apply (case_tac t; clarsimp)
   apply (rule val.v_t_r_cons1; simp?)
   apply (rule val.v_t_r_empty)
  apply (case_tac "length xs < Suc to")
   apply (drule val_wa_mapAccumnb_bod_back_step'; simp)
  apply (case_tac "Suc to \<le> frm")
   apply (erule val_wa_mapAccumnb_bod.elims; clarsimp)
   apply (rule val.v_t_record; simp?)
   apply (rule val.v_t_r_cons1; simp?)
    apply (rule val.v_t_abstract; simp)
    apply (clarsimp simp: wa_abs_typing_v_def)
    apply (case_tac t; clarsimp)
   apply (rule val.v_t_r_cons1; simp?)
   apply (rule val.v_t_r_empty)
  apply (frule val_wa_mapAccumnb_bod_preservation'; clarsimp)
  apply (drule val_wa_mapAccumnb_bod_back_step; clarsimp)
  apply (drule_tac x = "VRecord [VAbstract (VWA t (rxs[to := xs ! to])), racc']" in meta_spec)
  apply clarsimp
  apply (erule val.v_t_recordE; clarsimp)
  apply (erule val.v_t_r_consE; clarsimp)+
  apply (erule val.v_t_r_emptyE; simp)
   apply (drule_tac e = "App f (Var 0)" and
      v = "VRecord [rxs ! to, racc]" and
      \<gamma> = "[VRecord [xs ! to, racc', obsv]]" and
      \<Gamma> = "[option.Some (TRecord [(a0, t, Present), (a1, u, Present), (a2, v, Present)] Unboxed)]" 
      in val.preservation(1)[of "[]" "[]" _ _ _  \<xi>\<^sub>v, simplified]; simp?)
  apply (clarsimp simp: val.matches_def)
  apply (rule val.v_t_record; simp?)
  apply (rule val.v_t_r_cons1)
   apply (clarsimp simp: wa_abs_typing_v_def split: type.splits prim_type.splits)
   apply (erule_tac x = to in allE; clarsimp)
   apply (rule val.v_t_prim'; clarsimp)
  apply (rule val.v_t_r_cons1; simp?)
  apply (rule val.v_t_r_cons1; simp?)
    apply (rule val.v_t_r_empty)
   apply (erule val.v_t_recordE; clarsimp)
   apply (erule val.v_t_r_consE; clarsimp)+
   apply (erule val.v_t_r_emptyE; simp)
  apply (rule val.v_t_abstractE; simp)
  apply (rule val.v_t_record; simp)
  apply (rule val.v_t_r_cons1)
   apply (rule val.v_t_abstract; simp?)
    apply (clarsimp simp: wa_abs_typing_v_def split: type.splits prim_type.splits)
   apply (case_tac "i = to"; simp?)
    apply (clarsimp simp: val.vval_typing.simps[of _ _ "TPrim _", simplified])
   apply (erule_tac x = i in allE; clarsimp)+
  apply (rule val.v_t_r_cons1; simp?)
  apply (rule val.v_t_r_empty)
  done

fun is_vval_fun :: "('f, 'a) vval \<Rightarrow> bool"
  where
"is_vval_fun (VFunction _ _) = True" |
"is_vval_fun (VAFunction _ _) = True" |
"is_vval_fun _ = False"

fun vvalfun_to_exprfun :: "('f, 'a) vval \<Rightarrow> 'f expr"
  where
"vvalfun_to_exprfun (VFunction f ts) = Fun f ts" |
"vvalfun_to_exprfun (VAFunction f ts) = AFun f ts" |
"vvalfun_to_exprfun _ = undefined"

definition val_wa_foldnb_0
  where
  "val_wa_foldnb_0 \<Xi>' \<xi>\<^sub>v \<tau> x y = (\<exists>xs frm to acc obsv func t u v a0 a1 a2. 
      x = VRecord [VAbstract (VWA t xs), VPrim (LU32 frm), VPrim (LU32 to), func, acc, obsv] \<and> 
      wa_abs_typing_v (VWA t xs) ''WordArray'' [t]  \<and>
      is_vval_fun func \<and> \<tau> = TRecord [(a0, t, Present), (a1, u, Present), (a2, v, Present)] Unboxed \<and>
      val.vval_typing \<Xi>' acc u \<and> val.vval_typing \<Xi>' obsv v \<and> 
      (\<Xi>', [], [option.Some \<tau>] \<turnstile> (App (vvalfun_to_exprfun func) (Var 0)) : u) \<and>
      (val_wa_foldnb_bod \<xi>\<^sub>v t xs (unat frm) (unat to) (vvalfun_to_exprfun func) acc obsv y))"


definition val_wa_foldnbp
  where
  "val_wa_foldnbp \<xi>\<^sub>p x y = (\<exists>t xs frm to func acc obsv. 
      x = VRecord [VAbstract (VWA t xs), VPrim (LU32 frm), VPrim (LU32 to), func, acc, obsv] \<and>
      is_vval_fun func \<and> val_wa_foldnb_bod \<xi>\<^sub>p t xs (unat frm) (unat to) (vvalfun_to_exprfun func) acc obsv y)"

definition val_wa_mapAccumnbp
  where
  "val_wa_mapAccumnbp \<xi>\<^sub>p x y = (\<exists>t xs frm to func acc obsv. 
      x = VRecord [VAbstract (VWA t xs), VPrim (LU32 frm), VPrim (LU32 to), func, acc, obsv] \<and>
      is_vval_fun func \<and> val_wa_mapAccumnb_bod \<xi>\<^sub>p t xs (unat frm) (unat to) (vvalfun_to_exprfun func) acc obsv y)"

fun \<xi>m1 :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>m1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' 
      then val_wa_foldnb_0 \<Xi> \<xi>m abbreviatedType1 y z
     else \<xi>m x y z)" 

fun \<xi>p1 :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>p1 x y z = 
    (if x = ''wordarray_fold_no_break'' 
      then val_wa_foldnbp \<xi>p y z
     else if x = ''wordarray_map_no_break''
      then val_wa_mapAccumnbp \<xi>p y z
     else \<xi>p x y z)" 
end (* of context *)
end