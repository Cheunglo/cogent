(*
  This file contains the locale WordArray which includes the locale generated by AutoCorres from
  the C file containing the word array functions.
  
  This file also includes the proof that the WordArray locale is a subset of the top level 
  correspondence locale.

  This file also contains the various abstractions for the word array functions.
*)

theory WordArray_Abstractions
  imports Generated_AllRefine
begin

section "Helper Word Lemmas"

lemma word_mult_cancel_left: 
  fixes a b c :: "('a::len) word"
  assumes "0 \<le> a" "0 \<le> b" "0 \<le> c"
  assumes "uint c * uint a \<le> uint (max_word :: ('a::len) word)"
  assumes "uint c * uint b \<le> uint (max_word :: ('a::len) word)"
  shows "c * a = c * b \<longleftrightarrow> c = 0 \<or> a = b"
  apply (rule iffI)
   using assms
   apply (unfold word_mult_def word_of_int_def)
    apply (clarsimp simp:Abs_word_inject max_word_def uint_word_of_int m1mod2k uint_0_iff )
   apply fastforce
   done

section "WordArray Locale Definition"

locale WordArray = main_pp_inferred begin
  definition "abs_repr_u a \<equiv> case a of
      WAU32 _ _ \<Rightarrow> (''WordArray'', [RPrim (Num U32)])
    | _ \<Rightarrow> (''Unknown Abstract Type'', [])"

  definition "abs_typing_u a name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    (case a of
      WAU32 len arr \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num U32)] \<and> sig \<noteq> Unboxed \<and>
                      (sigil_perm sig = option.Some ReadOnly \<longrightarrow> w = {} \<and> r = {arr + 4 * i | i. i < len}) \<and>
                      (sigil_perm sig = option.Some Writable \<longrightarrow> r = {} \<and> w = {arr + 4 * i | i. i < len}) \<and>
                      (\<forall>i < len. \<exists>x. \<sigma>(arr + 4 * i) = option.Some (UPrim (LU32 x))) \<and> 4 * unat len \<le> unat (max_word :: ptrtyp)
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [] \<and> r = {} \<and> w = {} \<and> sig = Unboxed)"

  definition "abs_typing_v a name \<tau>s \<equiv>
    (case a of
      VWA xs \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num U32)] \<and> (\<forall>i < length xs. \<exists>x. xs ! i = VPrim (LU32 x))
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [])"

  definition  "abs_upd_val' au av name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    abs_typing_u au name \<tau>s sig r w \<sigma> \<and> abs_typing_v av name \<tau>s \<and>
    (case au of
      WAU32 len arr \<Rightarrow>
        (case av of 
          VWA xs \<Rightarrow> unat len = length xs \<and> 
                      (\<forall>i < len. \<exists>x. \<sigma>(arr + 4 * i) = option.Some (UPrim (LU32 x)) \<and> 
                                     xs ! (unat i) = VPrim (LU32 x))
          | _ \<Rightarrow> False)
      | _ \<Rightarrow> (case av of
                VTOther _ \<Rightarrow> True
             |  _ \<Rightarrow> False))"

lemma distinct_indices:
  "abs_typing_u (WAU32 len arr) n ts s r w \<sigma> \<Longrightarrow> \<forall>i < len. \<forall>j < len. i = j \<longleftrightarrow> 4 * i = 4 * j"
  apply clarsimp
  apply (rule iffI)
   apply (clarsimp simp: abs_typing_u_def)
  apply (clarsimp simp: abs_typing_u_def)
  apply (subgoal_tac "0 \<le> i")
   apply (frule_tac b = j and c = 4 in word_mult_cancel_left; clarsimp simp: uint_nat)
    apply (subgoal_tac "int (unat i) < int (unat len)")
     apply linarith
    apply (simp add: unat_mono)
   apply (subgoal_tac "int (unat j) < int (unat len)")
    apply linarith
   apply (simp add: unat_mono)
  apply simp
  done      
end

section "Sublocale Proof"

sublocale WordArray \<subseteq> Generated_cogent_shallow _ abs_repr_u abs_typing_v abs_typing_u abs_upd_val'
  apply (unfold abs_repr_u_def[abs_def] abs_typing_v_def[abs_def] abs_typing_u_def[abs_def] abs_upd_val'_def[abs_def])
  apply (unfold_locales; clarsimp split: vatyp.splits atyp.splits)
          apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
         apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
        apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
       apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
      apply (case_tac s; clarsimp; case_tac x11a; clarsimp; erule_tac x = i in allE; clarsimp)
     apply (case_tac s, (case_tac s', simp_all)+)[]
    apply (unfold UpdateSemantics.frame_def)
    apply (erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply (case_tac s; clarsimp; case_tac x11a; clarsimp;
           drule_tac x = "x12 + 4 * i" in orthD1; simp; rule_tac x = i in exI; simp)
   apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
  apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
   apply (rule conjI; clarsimp; erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply auto[1]
   apply (erule_tac x = i in allE; clarsimp)
   apply auto[1]
  apply (rule conjI; clarsimp; erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply auto[1]
   apply (erule_tac x = i in allE; clarsimp)
   apply auto[1]
  done

section "Abstractions for Word Arrays"

subsection "Helper Functions and Lemmas"

fun myslice :: "nat \<Rightarrow> nat \<Rightarrow> 'a list \<Rightarrow> 'a list"
  where
"myslice frm to xs = List.take (to - frm) (List.drop frm xs)"

(*
lemma take_1_drop:
  "i < length xs \<Longrightarrow> List.take (Suc 0) (List.drop i xs) = [xs ! i]"
  apply (induct xs arbitrary: i)
   apply (simp add: take_Suc_conv_app_nth)
  by (simp add: drop_Suc_nth)

lemma take_drop_Suc:
  "i < l \<and> i < length xs \<Longrightarrow> 
    List.take (l - i) (List.drop i xs) = (xs ! i) # List.take (l - Suc i) (List.drop (Suc i) xs)"
  apply clarsimp
  by (metis Cons_nth_drop_Suc Suc_diff_Suc take_Suc_Cons)
*)

subsection "Shallow Word Array Value Relation"

overloading
  valRel_WordArrayU32 \<equiv> valRel
begin
  definition valRel_WordArrayU32: 
    "\<And>\<xi> x v. valRel_WordArrayU32 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (32 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU32 (x ! i)))"
end

subsection "Shallow Word Array Function Definitions"

overloading
  wordarray_put2' \<equiv> wordarray_put2
begin
definition wordarray_put2':
 "wordarray_put2' (x :: ('a WordArray, 32 word, 'a) WordArrayPutP) \<equiv> (WordArrayPutP.arr\<^sub>f x)[unat (WordArrayPutP.idx\<^sub>f x) := WordArrayPutP.val\<^sub>f x]" 
end

overloading
  wordarray_length' \<equiv> wordarray_length
begin
definition wordarray_length':
 "wordarray_length' (x :: 'a WordArray) \<equiv> (of_nat (length x) :: 32 word)" 
end

overloading
  wordarray_get' \<equiv> wordarray_get
begin
definition wordarray_get':
 "wordarray_get' (x :: (32 word WordArray, 32 word) RR) \<equiv> (if unat (RR.p2\<^sub>f x) < length (RR.p1\<^sub>f x) then (RR.p1\<^sub>f x) ! unat (RR.p2\<^sub>f x) else 0)" 
end

overloading
  wordarray_fold_no_break' \<equiv> wordarray_fold_no_break
begin
definition wordarray_fold_no_break':
 "wordarray_fold_no_break' (x :: ('a WordArray, 32 word, 32 word, ('a, 'acc, 'obsv) ElemAO \<Rightarrow> 'acc, 'acc, 'obsv) WordArrayMapP) \<equiv> 
    fold (\<lambda>a b. (WordArrayMapP.f\<^sub>f x) (ElemAO.make a b (WordArrayMapP.obsv\<^sub>f x))) 
         (myslice (unat (WordArrayMapP.frm\<^sub>f x)) (unat (WordArrayMapP.to\<^sub>f x)) (WordArrayMapP.arr\<^sub>f x)) 
         (WordArrayMapP.acc\<^sub>f x)" 
end
context WordArray begin

subsection "Level 0 \<xi> Abstractions"

\<comment>\<open> This section contains the abstractions for first order calls to word array functions \<close>

subsubsection "Update Semantics"

definition upd_wa_put2_0
  where
  "upd_wa_put2_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in (\<exists>p idx val. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 idx), RPrim (Num U32)), (UPrim (LU32 val), RPrim (Num U32))] \<and>
          y2 = UPtr p (RCon ''WordArray'' [RPrim (Num U32)]) \<and>
          y1 = (\<lambda>l. (if \<exists>len arr. x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
                        l = arr + 4 * idx \<and> idx < len then option.Some (UPrim (LU32 val)) else x1 l))))"

definition upd_wa_get_0
  where
  "upd_wa_get_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p idx len arr. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 idx), RPrim (Num U32))] \<and> x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
            (idx < len \<longrightarrow> x1 (arr + 4 * idx) = option.Some y2) \<and>
            (\<not> idx < len \<longrightarrow> y2 = UPrim (LU32 0))))"

definition upd_wa_length_0
  where
  "upd_wa_length_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p len arr. x2 = UPtr p (RCon ''WordArray'' [RPrim (Num U32)]) \<and>
          x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> y2 = UPrim (LU32 len)))"

fun \<xi>0 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>0 x y z = 
    (if x = ''wordarray_put2_0'' then upd_wa_put2_0 y z
     else (if x = ''wordarray_get_0'' then upd_wa_get_0 y z
           else (if x = ''wordarray_length_0'' then upd_wa_length_0 y z
                 else False)))" 

subsubsection "Value Semantics"

definition val_wa_length_0
  where
  "val_wa_length_0 x y = (\<exists>xs len. x = VAbstract (VWA xs) \<and> y = VPrim (LU32 len) \<and> 
                                length xs = unat len)" 


definition val_wa_get_0
  where
  "val_wa_get_0 x y =
      (\<exists>xs idx v. x = VRecord [VAbstract (VWA xs), VPrim (LU32 idx)] \<and> y = VPrim (LU32 v) \<and>
       (unat idx < length xs \<longrightarrow> xs ! unat idx = y) \<and> (\<not> unat idx < length xs \<longrightarrow> v = 0))" 

definition val_wa_put2_0
  where
  "val_wa_put2_0 x y =
      (\<exists>xs idx val. x = VRecord [VAbstract (VWA xs), VPrim (LU32 idx), VPrim (LU32 val)] \<and>
       y = VAbstract (VWA (xs[unat idx := VPrim (LU32 val)])))" 


fun \<xi>m :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>m x y z = 
    (if x = ''wordarray_put2_0'' then val_wa_put2_0 y z
     else (if x = ''wordarray_get_0'' then val_wa_get_0 y z
           else (if x = ''wordarray_length_0'' then val_wa_length_0 y z
                 else False)))" 

fun \<xi>p :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>p x y z = 
    (if x = ''wordarray_put2'' then val_wa_put2_0 y z
     else (if x = ''wordarray_get'' then val_wa_get_0 y z
           else (if x = ''wordarray_length'' then val_wa_length_0 y z
                 else False)))" 

subsection "Level 1 \<xi> Abstractions"

\<comment>\<open> This section contains the abstractions for second order calls to word array functions.
    Note that in order to show termination, abstractions on this level can only call other
    abstractions from level 0. So far, this seems to be the best solution, however, when more
    levels are introduced, i.e. when third, fourth ... calls are introduced, these abstractions
    should probably be automatically generated. \<close>

(*
function \<xi>1 :: "(char list, atyp, 32 word) uabsfuns" 
  and upd_wa_foldnb_0  :: "(char list, atyp, 32 word) ufundef" 
(*  and upd_wa_mapnb_0  :: "(char list, atyp, 32 word) ufundef" *)
  where
  "\<xi>1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' then upd_wa_foldnb_0 y z
     else (if x = ''wordarray_map_no_break_0'' then False 
           else \<xi>0 x y z))" 
| "upd_wa_foldnb_0 (b1, b2) c = (\<exists>p frm to f ts acc len arr.
    b2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
      (UFunction f ts, RFun), (UPrim (LU32 acc), RPrim (Num U32)), (UUnit, RUnit)] \<and> 
    b1 p = option.Some (UAbstract (WAU32 len arr)) \<and>
    (if frm < min to len 
      then (\<exists>v b1' acc'. (b1 (arr + 4 * frm) = option.Some (UPrim (LU32 v))) \<and> 
        (\<xi>1, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), (UPrim (LU32 acc), RPrim (Num U32)), 
          (UUnit, RUnit)])] \<turnstile> (b1, App (Fun f ts) (Var 0)) \<Down>! (b1', UPrim (LU32 acc'))) \<and>
        upd_wa_foldnb_0 (b1', URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 (frm + 1)), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
          (UFunction f ts, RFun), (UPrim (LU32 acc'), RPrim (Num U32)), (UUnit, RUnit)]) c)
    else (b1, b2) = c))"
  by pat_completeness auto

termination \<xi>1
  apply (relation "measure 
    (\<lambda>x. case x of Inl (_, _, _) \<Rightarrow> Suc (unat ((max_word :: 32 word)))
             | Inr ((a1, a2), _) \<Rightarrow> 
                      (case a2 of URecord [] \<Rightarrow> 0
                                        | _ \<Rightarrow> 0))")
     apply clarsimp
  apply clarsimp
  sorry
*)

subsubsection "Update Semantics"

type_synonym ('f, 'a, 'l) ufoldmapdef = "('f, 'a, 'l) store \<Rightarrow> 32 word \<Rightarrow> 32 word \<Rightarrow> 32 word \<Rightarrow>
                                        'f expr \<Rightarrow> ('f, 'a, 'l) uval \<Rightarrow> ('f, 'a, 'l) uval \<times> ptrtyp set\<Rightarrow>
                                        (('f, 'a, 'l) store \<times> ('f, 'a, 'l) uval) \<Rightarrow> bool"

function upd_wa_mapnb_bod_0 :: "(char list, atyp, 32 word) ufoldmapdef"
  where
  "upd_wa_mapnb_bod_0 \<sigma> p frm to f acc (obsv, s) res = (\<exists>len arr. 
    \<sigma> p = option.Some (UAbstract (WAU32 len arr)) \<and> 
    (if frm < min to len then (\<exists>v v' acc' \<sigma>'. \<sigma> (arr + 4 * frm) = option.Some (UPrim (LU32 v)) \<and> 
         (\<xi>0, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), (acc, upd.uval_repr acc), (obsv, upd.uval_repr obsv)])] \<turnstile> 
            (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>', URecord [(UPrim (LU32 v'), RPrim (Num U32)), (acc', upd.uval_repr acc')])) \<and>
          \<sigma> p = \<sigma>' p \<and> (\<forall>i<len. \<sigma> (arr + 4 * i) = \<sigma>' (arr + 4 * i)) \<and> (upd.uval_repr acc = upd.uval_repr  acc') \<and>
          upd_wa_mapnb_bod_0 (\<lambda>l.(if l = arr + 4 * frm then option.Some (UPrim (LU32 v')) else \<sigma>' l))
             p (frm + 1) to f acc' (obsv, s) res) 
    else (\<sigma>, URecord [(
        UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
         (acc, upd.uval_repr acc)]) = res))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, frm, to, _, _, _, _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done

function upd_wa_foldnb_bod_0 :: "(char list, atyp, 32 word) ufoldmapdef"
  where
  "upd_wa_foldnb_bod_0 \<sigma> p frm to f acc (obsv, s) res = (\<exists>len arr. \<sigma> p = option.Some (UAbstract (WAU32 len arr)) \<and>
    (if frm < min to len then (\<exists>v acc' \<sigma>' w1 w2. \<sigma> (arr + 4 * frm) = option.Some (UPrim (LU32 v)) \<and> 
          (\<xi>0, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), (acc, upd.uval_repr acc), 
            (obsv, upd.uval_repr obsv)])] \<turnstile> (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>', acc')) \<and>
          frame \<sigma> w1 \<sigma>' w2 \<and> ({p} \<union> s \<union> {arr + 4 * i | i. i < len}) \<inter> w1 = {}  \<and>
          upd_wa_foldnb_bod_0 \<sigma>' p (frm + 1) to f acc' (obsv, s) res) 
    else (\<sigma>, acc) = res))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, frm, to, _, _, _, _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done
print_theorems
declare upd_wa_mapnb_bod_0.simps[simp del]
declare upd_wa_foldnb_bod_0.simps[simp del]

lemma upd_wa_foldnb_bod_0_to_geq_len:
  "\<lbrakk>upd_wa_foldnb_bod_0 \<sigma> p frm len f acc (obsv, s) (\<sigma>', r); \<sigma> p = option.Some (UAbstract (WAU32 len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_bod_0 \<sigma> p frm to f acc (obsv, s) (\<sigma>', r)"
  apply (induct arbitrary: to arr rule: upd_wa_foldnb_bod_0.induct[where ?a0.0 = \<sigma> and 
                                                       ?a1.0 = p and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = len and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = "(obsv, s)" and
                                                       ?a7.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = to in meta_spec)
  apply (subst (asm) upd_wa_foldnb_bod_0.simps)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply (drule_tac x = toa in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule conjI; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>' in exI)
    apply clarsimp
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI)
     apply clarsimp
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = p in allE; clarsimp)
   apply (rule FalseE)
   apply auto[1]
  apply (subst upd_wa_foldnb_bod_0.simps)
  apply clarsimp
  done

lemma upd_wa_foldnb_bod_0_to_geq_lenD:
  "\<lbrakk>upd_wa_foldnb_bod_0 \<sigma> p frm to f acc (obsv, s) (\<sigma>', r); \<sigma> p = option.Some (UAbstract (WAU32 len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_bod_0 \<sigma> p frm len f acc (obsv, s) (\<sigma>', r)"
  apply (induct rule: upd_wa_foldnb_bod_0.induct[where ?a0.0 = \<sigma> and 
                                                       ?a1.0 = p and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = "(obsv, s)" and
                                                       ?a7.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (subst (asm) upd_wa_foldnb_bod_0.simps)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>' in exI)
   apply clarsimp
   apply (rule_tac x = w1 in exI)
   apply clarsimp
   apply (rule conjI)
    apply (rule_tac x = x in exI)
    apply clarsimp
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply (clarsimp simp: frame_def)
   apply (erule_tac x = p in allE; clarsimp)
  apply (case_tac "frm < to")
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
  apply clarsimp
  apply (subgoal_tac "\<not> frm < len")
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
  apply auto
  done

lemma upd_wa_foldnb_bod_0_step:
  "\<lbrakk>upd_wa_foldnb_bod_0 \<sigma> p frm to f acc (obsv, s) (\<sigma>', r); \<sigma> p = option.Some (UAbstract (WAU32 len arr));
    frm \<le> to; to < len; \<sigma> (arr + 4 * to) = option.Some (UPrim (LU32 v)); 
    frame \<sigma>' w1 \<sigma>'' w2; ({p} \<union> s \<union> {arr + 4 * i | i. i < len}) \<inter> w1 = {};
     \<xi>0, [URecord [(UPrim (LU32 v), RPrim (Num U32)),
      (r, upd.uval_repr r), (obsv, upd.uval_repr obsv)]] \<turnstile> (\<sigma>', App f (Var 0))\<Down>! (\<sigma>'', r')\<rbrakk> 
    \<Longrightarrow> upd_wa_foldnb_bod_0 \<sigma> p frm (to + 1) f acc (obsv, s) (\<sigma>'', r')"
  apply (induct arbitrary: len arr v r r' \<sigma>' \<sigma>'' w1 w2 obsv s
                rule: upd_wa_foldnb_bod_0.induct[where ?a0.0 = \<sigma> and 
                                                       ?a1.0 = p and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = "(obsv, s)" and
                                                       ?a7.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (erule upd_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>'''' in meta_spec)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (drule_tac x = v in meta_spec)
   apply (drule_tac x = b in meta_spec)
   apply (drule_tac x = r' in meta_spec)
   apply (drule_tac x = a in meta_spec)
   apply (drule_tac x = \<sigma>'' in meta_spec)
   apply (drule_tac x = w1 in meta_spec)
   apply (drule_tac x = w2 in meta_spec)
   apply (drule_tac x = obsv in meta_spec)
   apply (drule_tac x = s in meta_spec)
   apply clarsimp
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule conjI)
    apply clarsimp
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>'''' in exI)
    apply clarsimp
    apply (rule_tac x = w1a in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI)
     apply clarsimp
    apply (case_tac "frma + 1 \<le> toa")
     apply clarsimp
     apply (thin_tac "frame _ _ _ _")
     apply (clarsimp simp: frame_def)
     apply (frule_tac x = pa in spec)
     apply clarsimp
     apply (erule_tac x = "arr + 4 * toa" in allE)
     apply clarsimp
     apply (thin_tac "_, _ \<turnstile> _ \<Down>! _")+
     apply (thin_tac "_ = {}")
     apply clarsimp
     apply (drule_tac x = "arr + 4 * toa" in orthD1; simp)
     apply (rule disjI2)
     apply (rule_tac x = toa in exI; clarsimp)
    apply (clarsimp simp: not_le) thm inc_le
    apply (drule_tac i = frma and m = toa in inc_le)
    apply (rule FalseE)
    apply simp
   apply clarsimp
   apply (clarsimp simp: not_less)
   apply (rule FalseE)
   apply (simp add: less_is_non_zero_p1 plus_one_helper2 word_le_not_less)
  apply (erule disjE)
   apply (subst upd_wa_foldnb_bod_0.simps; clarsimp)
   apply (rule conjI; clarsimp)
    apply (rule_tac x = r' in exI)
    apply (rule_tac x = \<sigma>'' in exI)
    apply (subst upd_wa_foldnb_bod_0.simps; clarsimp)
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = w2 in exI)
     apply clarsimp
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = pa in allE; clarsimp)
    apply (rule_tac x = len in exI)
    apply (rule_tac x = arr in exI)
    apply clarsimp
   apply (clarsimp simp: not_less)
   apply (meson less_is_non_zero_p1 word_le_not_less word_overflow)
  apply (clarsimp simp: not_less)
  by auto

lemma upd_wa_foldnb_bod_0_back_step:
  "\<lbrakk>upd_wa_foldnb_bod_0 \<sigma> p frm to f acc (obsv, s) (\<sigma>', r); to > 0; to \<le> len; frm < to - 1; 
    \<sigma> p = option.Some (UAbstract (WAU32 len arr)); \<sigma> (arr + 4 * (to - 1)) = option.Some (UPrim (LU32 v))\<rbrakk>
    \<Longrightarrow> \<exists>\<sigma>'' r'' w1 w2. upd_wa_foldnb_bod_0 \<sigma> p frm (to - 1) f acc (obsv, s) (\<sigma>'', r'') \<and> 
        (\<xi>0, [URecord [(UPrim (LU32 v), RPrim (Num U32)), (r'', upd.uval_repr r''), 
          (obsv, upd.uval_repr obsv)]] \<turnstile> (\<sigma>'', App f (Var 0))\<Down>! (\<sigma>', r)) \<and>
        frame \<sigma>'' w1 \<sigma>' w2 \<and> ({p} \<union> s \<union> {arr + 4 * i | i. i < len}) \<inter> w1 = {}"
  apply (induct arbitrary: len arr v \<sigma>' r obsv s
                rule: upd_wa_foldnb_bod_0.induct[where ?a0.0 = \<sigma> and 
                                                       ?a1.0 = p and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = "to" and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = "(obsv, s)" and
                                                       ?a7.0 = "(\<sigma>', r)"]; clarsimp)
  apply (erule upd_wa_foldnb_bod_0.elims)  
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>''' in meta_spec)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (drule_tac x = v in meta_spec)
   apply (drule_tac x = a in meta_spec)
   apply (drule_tac x = b in meta_spec)
   apply (drule_tac x = obsv in meta_spec)
   apply (drule_tac x = s in meta_spec)
   apply (case_tac "frma + 1 < toa - 1"; clarsimp)
    apply (drule meta_mp)
     apply (clarsimp simp: frame_def)
     apply (erule_tac x = pa in allE)
     apply clarsimp
    apply (drule meta_mp)
     apply (clarsimp simp: frame_def)
     apply (erule_tac x = "arr + (4 * toa - 4)" in allE)
     apply clarsimp
     apply (drule_tac x  = "arr + (4 * toa - 4)" in orthD1; simp)
     apply (rule disjI2)
     apply (rule_tac x = "toa - 1" in exI)
     apply clarsimp
     apply (drule minus_one_helper; blast)
    apply clarsimp
    apply (rule_tac x = \<sigma>'''' in exI)
    apply (rule_tac x = r'' in exI)
    apply clarsimp
    apply (rule conjI)
     apply (subst upd_wa_foldnb_bod_0.simps)
     apply clarsimp
     apply (rule_tac x = acc' in exI)
     apply (rule_tac x = \<sigma>''' in exI)
     apply clarsimp
     apply (rule_tac x = w1 in exI)
     apply clarsimp
     apply (rule_tac x = x in exI; clarsimp)
    apply (rule_tac x = w1a in exI)
    apply clarsimp
    apply (rule_tac x = xa in exI; clarsimp)
   apply (rule_tac x = \<sigma>''' in exI)
   apply (rule_tac x = acc' in exI)
   apply (rule conjI)
    apply (subst upd_wa_foldnb_bod_0.simps)
    apply clarsimp
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>''' in exI)
    apply clarsimp
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI; clarsimp)
    apply (subst upd_wa_foldnb_bod_0.simps)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = pa in allE; clarsimp)
    apply (rule_tac x = len in exI)
    apply (rule_tac x = arr in exI)
    apply clarsimp
   apply (subgoal_tac "frma + 1 = toa - 1")
    apply (erule upd_wa_foldnb_bod_0.elims)
    apply (clarsimp split: if_split_asm)
    apply (erule disjE; clarsimp)
     apply (subst (asm) frame_def)
     apply (frule_tac x = p in spec)
     apply clarsimp
     apply (erule_tac x = "arra + 4 + 4 * frma" in allE; clarsimp)
     apply (drule_tac x  = "arra + 4 + 4 * frma" in orthD1; simp)
      apply (rule disjI2)
      apply (rule_tac x = "1 + frma" in exI; simp)
     apply (subst (asm) add.assoc[symmetric])
     apply clarsimp
     apply (erule upd_wa_foldnb_bod_0.elims)
     apply clarsimp
     apply (subst (asm) add.assoc[symmetric])
     apply clarsimp
     apply (rule_tac x = w1a in exI)
     apply clarsimp
     apply (rule_tac x = xa in exI; clarsimp)
    apply (subst (asm) frame_def)
    apply (frule_tac x = p in spec)
    apply clarsimp
    apply (erule impE)
     apply (metis (no_types) add.commute add_left_cancel inc_le one_add_one word_le_less_eq word_not_le word_overflow zero_neq_one)
    apply (erule impE)
     apply (metis (no_types, hide_lams) add.commute add_left_cancel inc_le is_num_normalize(1) one_add_one word_le_less_eq)
    apply clarsimp
    apply (erule_tac x = "arra + 4 + 4 * frma" in allE; clarsimp)
    apply (drule_tac x  = "arra + 4 + 4 * frma" in orthD1; simp)
     apply (rule disjI2)
     apply (rule_tac x = "1 + frma" in exI; simp)
     apply (metis (no_types) add.commute add_left_cancel inc_le one_add_one word_le_less_eq word_not_le word_overflow zero_neq_one)
    apply (subst (asm) add.assoc[symmetric])
    apply clarsimp
    apply (subst (asm) add.assoc[symmetric])
    apply clarsimp
    apply (erule upd_wa_foldnb_bod_0.elims)
    apply clarsimp
    apply blast
  apply (meson inc_le word_le_less_eq)
  apply (rule FalseE)
  apply (case_tac "frma < toa"; clarsimp)
   apply auto[1]
  by (metis less_1_simp word_le_less_eq word_le_not_less)


lemma upd_wa_foldnb_bod_0_back_step':
  "\<lbrakk>upd_wa_foldnb_bod_0 \<sigma> p frm to f acc (obsv, s) (\<sigma>', r); 
    \<sigma> p = option.Some (UAbstract (WAU32 len arr)); len < to\<rbrakk>
    \<Longrightarrow> upd_wa_foldnb_bod_0 \<sigma> p frm (to - 1) f acc (obsv, s) (\<sigma>', r)"
  apply (induct arbitrary: len arr
                rule: upd_wa_foldnb_bod_0.induct[where ?a0.0 = \<sigma> and 
                                                       ?a1.0 = p and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = "to" and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = "(obsv, s)" and
                                                       ?a7.0 = "(\<sigma>', r)"]; clarsimp)
  apply (drule_tac x = len in meta_spec)
  apply (erule upd_wa_foldnb_bod_0.elims)  
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>'' in meta_spec)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply clarsimp
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule conjI; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>'' in exI)
    apply clarsimp
    apply (rule_tac x = w1 in exI)
    apply clarsimp
    apply (rule conjI)
     apply (rule_tac x = x in exI; clarsimp)
    apply (clarsimp simp: frame_def)
    apply (erule_tac x = pa in allE; clarsimp)
   apply (metis (no_types, hide_lams) less_1_simp word_le_less_eq word_le_not_less)
  apply (case_tac "frma < toa"; clarsimp)
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
  apply (subst upd_wa_foldnb_bod_0.simps)
  apply clarsimp
  apply (rule FalseE)  
  by auto

(* We will need to define a different wrapper for each type of accumulator so that we can prove
   that the frame constraints still hold when proving the proc_env_matches_ptrs constraint.
   This is because we do not know what the set of writeable pointers are unless we know the
   type of the accumulator *)

definition upd_wa_foldnb_0  :: "(char list, atyp, 32 word) ufundef" 
  where
  "upd_wa_foldnb_0 y z = 
    (let (y1, y2) = y;
         (z1, z2) = z
      in (\<exists>p frm to acc r x.
        y2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), 
                      RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
                      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
                      (x, RFun), (UPrim (LU32 acc), RPrim (Num U32)), (UUnit, RUnit)] \<and> 
        y1 = z1 \<and> y1 p = z1 p \<and> (\<exists>len arr. y1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
          (\<forall>i<len. y1 (arr + 4 * i) = z1 (arr + 4 * i))) \<and> z2 = UPrim (LU32 r) \<and>
        (case x of
            UFunction f ts \<Rightarrow> (\<Xi>, [], [option.Some abbreviatedType1] \<turnstile> (App (Fun f ts) (Var 0)) : 
                                TPrim (Num U32)) \<and> 
                              upd_wa_foldnb_bod_0 y1 p frm to (Fun f ts) (UPrim (LU32 acc)) (UUnit, {}) z
          | UAFunction f ts \<Rightarrow> (\<Xi>, [], [option.Some abbreviatedType1] \<turnstile> (App (AFun f ts) (Var 0)) : 
                                TPrim (Num U32)) \<and>
                              upd_wa_foldnb_bod_0 y1 p frm to (AFun f ts) (UPrim (LU32 acc)) (UUnit, {}) z
          | _ \<Rightarrow> False)))"
(*
lemma upd_wa_foldnb_0_to_geq_len:
  "\<lbrakk>upd_wa_foldnb_0 (\<sigma>, URecord fs) z; prod.fst (fs ! 0) = UPtr p repr;
       \<sigma> p = option.Some (UAbstract (WAU32 len arr)); prod.fst (fs ! 2) = UPrim (LU32 len); 
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_0 (\<sigma>, URecord (fs[2 := (UPrim (LU32 to), prod.snd (fs ! 2))])) z"
  apply (clarsimp simp: upd_wa_foldnb_0_def)
  apply (case_tac x; clarsimp)
   apply (case_tac y; clarsimp)
   apply (rule_tac len = len and arr = arr in upd_wa_foldnb_bod_0_to_geq_len; simp)
  apply (case_tac y; clarsimp)
  apply (rule_tac len = len and arr = arr in upd_wa_foldnb_bod_0_to_geq_len; simp)
  done

lemma upd_wa_foldnb_0_to_geq_lenD:
    "\<lbrakk>upd_wa_foldnb_0 (\<sigma>, URecord fs) z; prod.fst (fs ! 0) = UPtr p repr;
       \<sigma> p = option.Some (UAbstract (WAU32 len arr)); prod.fst (fs ! 2) = UPrim (LU32 to); 
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_0 (\<sigma>, URecord (fs[2 := (UPrim (LU32 len), prod.snd (fs ! 2))])) z"
  apply (clarsimp simp: upd_wa_foldnb_0_def)
  apply (case_tac x; clarsimp)
   apply (case_tac y; clarsimp)
   apply (drule_tac len = len and arr = arr in upd_wa_foldnb_bod_0_to_geq_lenD; simp)
  apply (case_tac y; clarsimp)
  apply (drule_tac len = len and arr = arr in upd_wa_foldnb_bod_0_to_geq_lenD; simp)
  done
*)
definition upd_wa_mapnb_0  :: "(char list, atyp, 32 word) ufundef" 
  where
  "upd_wa_mapnb_0 y z = 
    (let (y1, y2) = y;
         (z1, z2) = z 
    in (\<exists>p frm to x.
        y2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]),
                      RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
                      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
                      (x, RFun),
                      (UUnit, RUnit), (UUnit, RUnit)] \<and>
        y1 p = z1 p \<and> (\<exists>len arr. y1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
          frame y1 ({p} \<union> {arr + 4 * i | i. i < len}) z1 ({p} \<union> {arr + 4 * i | i. i < len})) \<and>
        (case x of
            UFunction f ts \<Rightarrow> upd_wa_mapnb_bod_0 y1 p frm to (Fun f ts) (UUnit) (UUnit, {}) z
          | UAFunction f ts \<Rightarrow> upd_wa_mapnb_bod_0 y1 p frm to (AFun f ts) (UUnit) (UUnit, {}) z
          | _ \<Rightarrow> False)))"

fun \<xi>1 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' then upd_wa_foldnb_0 y z
     else (if x = ''wordarray_map_no_break_0'' then False 
           else \<xi>0 x y z))" 

subsubsection "Value Semantics"

type_synonym ('f, 'a) vfoldmapdef = "('f, 'a) vval list \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> 'f expr \<Rightarrow> ('f, 'a) vval \<Rightarrow> 
                                        ('f, 'a) vval  \<Rightarrow> ('f, 'a) vval \<Rightarrow> bool"

type_synonym ('f, 'a) vfoldmapdef' = "('f, 'a) vval list \<Rightarrow> 'f expr \<Rightarrow> ('f, 'a) vval \<Rightarrow> 
                                        ('f, 'a) vval  \<Rightarrow> ('f, 'a) vval \<Rightarrow> bool"

function val_wa_foldnb_bod_0 :: "(char list, vatyp) vfoldmapdef"
  where
  "val_wa_foldnb_bod_0 xs frm to f acc obsv res = 
    (if frm < min to (length xs)
      then (\<exists>v acc'. xs ! frm = VPrim (LU32 v) \<and> 
          (\<xi>m, [(VRecord [(VPrim (LU32 v)), acc, obsv])] \<turnstile> App f (Var 0) \<Down> acc') \<and>
          val_wa_foldnb_bod_0 xs (Suc frm) to f acc' obsv res)
    else acc = res)"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, frm, to, _, _, _, _). to - frm)"; clarsimp)
  apply linarith
  done
print_theorems
declare val_wa_foldnb_bod_0.simps[simp del]

lemma val_wa_foldnb_bod_0_append:
  "\<lbrakk>to \<le> length xs; val_wa_foldnb_bod_0 (xs @ [x]) frm to f acc obsv r\<rbrakk>
    \<Longrightarrow> val_wa_foldnb_bod_0 xs frm to f acc obsv r"
  apply (induct arbitrary: x 
                rule: val_wa_foldnb_bod_0.induct[where ?a0.0 = xs and
                                                       ?a1.0 = frm and
                                                       ?a2.0 = to and
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = x in meta_spec)
   apply clarsimp
   apply (subst val_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = v in exI)
   apply (rule conjI)
    apply (simp add: nth_append)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod_0.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_0_append_incl_to:
  "\<lbrakk>frm < length (xs @ [x]); to > length xs; val_wa_foldnb_bod_0 (xs @ [x]) frm to f acc obsv r\<rbrakk>
    \<Longrightarrow> \<exists>r'. val_wa_foldnb_bod_0 xs frm to f acc obsv r' \<and> (\<xi>m, [VRecord [x, r', obsv]] \<turnstile> (App f (Var 0)) \<Down> r)"
  apply (induct arbitrary: x
                rule: val_wa_foldnb_bod_0.induct[where ?a0.0 = xs and
                                                       ?a1.0 = frm and
                                                       ?a2.0 = to and
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r])
  apply clarsimp
  apply (case_tac "frm = length xs")
   apply (subst val_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (erule val_wa_foldnb_bod_0.elims)
   apply clarsimp
   apply (erule val_wa_foldnb_bod_0.elims)
   apply (clarsimp split: if_splits)
  apply (erule val_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_splits)
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = x in meta_spec)
  apply clarsimp
  apply (rule_tac x = r' in exI)
  apply clarsimp
  apply (subst val_wa_foldnb_bod_0.simps)
  apply clarsimp
  apply (rule_tac x = v in exI)
  apply (clarsimp simp: nth_append)
  apply (rule_tac x = acc' in exI)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_0_step:
  "\<lbrakk>val_wa_foldnb_bod_0 xs frm to f acc obsv r; frm \<le> to; to < length xs; 
    xs ! to = (VPrim (LU32 v));
    \<xi>m, [VRecord [(VPrim (LU32 v)), r, obsv]] \<turnstile> (App f (Var 0)) \<Down> (r')\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod_0 xs frm (Suc to) f acc obsv r'"
  apply (induct arbitrary: v r'
                rule: val_wa_foldnb_bod_0.induct[where ?a0.0 = xs and 
                                                       ?a1.0 = frm and 
                                                       ?a2.0 = to and 
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r])
  apply clarsimp
  apply (erule val_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = v in meta_spec)
   apply (drule_tac x = r' in meta_spec)
   apply clarsimp
   apply (subst val_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod_0.simps)
  apply clarsimp
  apply (rule_tac x = r' in exI)
  apply (subst val_wa_foldnb_bod_0.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_0_to_geq_len:
  "\<lbrakk>val_wa_foldnb_bod_0 xs frm (length xs) f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod_0 xs frm to f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod_0.induct[where ?a0.0 = xs and 
                                                       ?a1.0 = frm and 
                                                       ?a2.0 = to  and 
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod_0.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_0_to_geq_lenD:
  "\<lbrakk>val_wa_foldnb_bod_0 xs frm to f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod_0 xs frm (length xs) f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod_0.induct[where ?a0.0 = xs and 
                                                       ?a1.0 = frm and 
                                                       ?a2.0 = to and 
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod_0.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_0_back_step':
  "\<lbrakk>val_wa_foldnb_bod_0 xs frm (Suc to) f acc obsv r; length xs < Suc to\<rbrakk>
    \<Longrightarrow> val_wa_foldnb_bod_0 xs frm to f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod_0.induct[where ?a0.0 = xs and 
                                                       ?a1.0 = frm and 
                                                       ?a2.0 = to  and 
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod_0.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_0_back_step:
  "\<lbrakk>val_wa_foldnb_bod_0 xs frm (Suc to) f acc obsv r; Suc to \<le> length xs; frm < to;
    xs ! to = VPrim (LU32 v)\<rbrakk>
    \<Longrightarrow> \<exists>r'. val_wa_foldnb_bod_0 xs frm to f acc obsv r' \<and>
        (\<xi>m, [VRecord [VPrim (LU32 v), r', obsv]] \<turnstile> (App f (Var 0)) \<Down> r)"
  apply (induct arbitrary: v
                rule: val_wa_foldnb_bod_0.induct[where ?a0.0 = xs and 
                                                       ?a1.0 = frm and 
                                                       ?a2.0 = to  and 
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_split_asm)
  apply (erule_tac x = acc' in meta_allE)
  apply (erule_tac x = v in meta_allE)
  apply clarsimp
  apply (case_tac "Suc frma < to")
   apply clarsimp
   apply (rule_tac x = r' in exI)
   apply clarsimp
   apply (subst val_wa_foldnb_bod_0.simps; clarsimp)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply clarsimp
  apply (subgoal_tac "to = Suc frma")
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule conjI)
    apply (subst val_wa_foldnb_bod_0.simps; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply clarsimp
    apply (subst val_wa_foldnb_bod_0.simps; clarsimp)
   apply (erule val_wa_foldnb_bod_0.elims; clarsimp)
   apply (erule val_wa_foldnb_bod_0.elims; clarsimp)
  by linarith

lemma val_wa_foldnb_bod_0_preservation:
  "\<lbrakk>proc_ctx_wellformed \<Xi>; val.proc_env_matches \<xi>m \<Xi>;
    val_wa_foldnb_bod_0 xs frm to f acc obsv r; \<forall>i<length xs. \<exists>v. xs ! i = VPrim (LU32 v);
    \<Xi>, [], [option.Some t] \<turnstile> App f (Var 0) : u; val.vval_typing \<Xi> acc u;
    \<forall>x v. val.vval_typing \<Xi> v u \<longrightarrow> val.matches \<Xi> [VRecord [VPrim (LU32 x), v, obsv]] [option.Some t]\<rbrakk>
    \<Longrightarrow> val.vval_typing \<Xi> r u"
  apply (induct to arbitrary: r)
   apply (erule val_wa_foldnb_bod_0.elims; clarsimp)
  apply (case_tac "length xs < Suc to")
   apply (drule val_wa_foldnb_bod_0_back_step'; simp)
  apply (case_tac "to \<le> frm")
   apply (erule val_wa_foldnb_bod_0.elims; clarsimp split: if_splits)
   apply (erule val_wa_foldnb_bod_0.elims; clarsimp)
   apply (drule val.preservation(1)[of "[]" "[]" _ _ _  \<xi>m, simplified]; simp)
  apply (clarsimp simp: not_less not_le)
  apply (erule_tac x = to in allE; clarsimp)
  apply (drule val_wa_foldnb_bod_0_back_step; simp?)
  apply clarsimp
  apply (drule_tac x = r' in meta_spec)
  apply clarsimp
  apply (drule val.preservation(1)[of "[]" "[]" _ _ _  \<xi>m, simplified]; simp)
  done

function val_wa_foldnb_bod_0p :: "(char list, vatyp) vfoldmapdef"
  where
  "val_wa_foldnb_bod_0p xs frm to f acc obsv res = 
    (if frm < min to (length xs)
      then (\<exists>v acc'. xs ! frm = VPrim (LU32 v) \<and> 
          (\<xi>p, [(VRecord [(VPrim (LU32 v)), acc, obsv])] \<turnstile> App f (Var 0) \<Down> acc') \<and>
          val_wa_foldnb_bod_0p xs (Suc frm) to f acc' obsv res)
    else acc = res)"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, frm, to, _, _, _, _). to - frm)"; clarsimp)
  apply linarith
  done

declare val_wa_foldnb_bod_0p.simps[simp del]

lemma val_wa_foldnb_bod_0p_append:
  "\<lbrakk>to \<le> length xs; val_wa_foldnb_bod_0p (xs @ [x]) frm to f acc obsv r\<rbrakk>
    \<Longrightarrow> val_wa_foldnb_bod_0p xs frm to f acc obsv r"
  apply (induct arbitrary: x 
                rule: val_wa_foldnb_bod_0p.induct[where ?a0.0 = xs and
                                                       ?a1.0 = frm and
                                                       ?a2.0 = to and
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0p.elims)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = x in meta_spec)
   apply clarsimp
   apply (subst val_wa_foldnb_bod_0p.simps)
   apply clarsimp
   apply (rule_tac x = v in exI)
   apply (rule conjI)
    apply (simp add: nth_append)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod_0p.simps)
  apply clarsimp
  done


lemma val_wa_foldnb_bod_0p_append_incl_to:
  "\<lbrakk>frm < length (xs @ [x]); to > length xs; val_wa_foldnb_bod_0p (xs @ [x]) frm to f acc obsv r\<rbrakk>
    \<Longrightarrow> \<exists>r'. val_wa_foldnb_bod_0p xs frm to f acc obsv r' \<and> (\<xi>p, [VRecord [x, r', obsv]] \<turnstile> (App f (Var 0)) \<Down> r)"
  apply (induct arbitrary: x
                rule: val_wa_foldnb_bod_0p.induct[where ?a0.0 = xs and
                                                       ?a1.0 = frm and
                                                       ?a2.0 = to and
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r])
  apply clarsimp
  apply (case_tac "frm = length xs")
   apply (subst val_wa_foldnb_bod_0p.simps)
   apply clarsimp
   apply (erule val_wa_foldnb_bod_0p.elims)
   apply clarsimp
   apply (erule val_wa_foldnb_bod_0p.elims)
   apply (clarsimp split: if_splits)
  apply (erule val_wa_foldnb_bod_0p.elims)
  apply (clarsimp split: if_splits)
  apply (drule_tac x = acc' in meta_spec)
  apply (drule_tac x = x in meta_spec)
  apply clarsimp
  apply (rule_tac x = r' in exI)
  apply clarsimp
  apply (subst val_wa_foldnb_bod_0p.simps)
  apply clarsimp
  apply (rule_tac x = v in exI)
  apply (clarsimp simp: nth_append)
  apply (rule_tac x = acc' in exI)
  apply clarsimp
  done


lemma val_wa_foldnb_bod_0p_step:
  "\<lbrakk>val_wa_foldnb_bod_0p xs frm to f acc obsv r; frm \<le> to; to < length xs; 
    xs ! to = (VPrim (LU32 v));
    \<xi>p, [VRecord [(VPrim (LU32 v)), r, obsv]] \<turnstile> (App f (Var 0)) \<Down> (r')\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod_0p xs frm (Suc to) f acc obsv r'"
  apply (induct arbitrary: v r'
                rule: val_wa_foldnb_bod_0p.induct[where ?a0.0 = xs and 
                                                       ?a1.0 = frm and 
                                                       ?a2.0 = to and 
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r])
  apply clarsimp
  apply (erule val_wa_foldnb_bod_0p.elims)
  apply (clarsimp split: if_split_asm)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = v in meta_spec)
   apply (drule_tac x = r' in meta_spec)
   apply clarsimp
   apply (subst val_wa_foldnb_bod_0p.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod_0p.simps)
  apply clarsimp
  apply (rule_tac x = r' in exI)
  apply (subst val_wa_foldnb_bod_0p.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_0p_to_geq_len:
  "\<lbrakk>val_wa_foldnb_bod_0p xs frm (length xs) f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod_0p xs frm to f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod_0p.induct[where ?a0.0 = xs and 
                                                       ?a1.0 = frm and 
                                                       ?a2.0 = to  and 
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0p.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod_0p.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
   apply (subst val_wa_foldnb_bod_0p.simps)
   apply clarsimp
  done

lemma val_wa_foldnb_bod_0p_to_geq_lenD:
  "\<lbrakk>val_wa_foldnb_bod_0p xs frm to f acc obsv r; length xs \<le> to\<rbrakk> 
    \<Longrightarrow> val_wa_foldnb_bod_0p xs frm (length xs) f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod_0p.induct[where ?a0.0 = xs and 
                                                       ?a1.0 = frm and 
                                                       ?a2.0 = to and 
                                                       ?a3.0 = f and
                                                       ?a4.0 = acc and
                                                       ?a5.0 = obsv and
                                                       ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0p.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod_0p.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
   apply (subst val_wa_foldnb_bod_0p.simps)
   apply clarsimp
  done


lemma val_wa_foldnb_bod_0p_back_step':
  "\<lbrakk>val_wa_foldnb_bod_0p xs frm (Suc to) f acc obsv r; length xs < Suc to\<rbrakk>
    \<Longrightarrow> val_wa_foldnb_bod_0p xs frm to f acc obsv r"
  apply (induct rule: val_wa_foldnb_bod_0p.induct[where ?a0.0 = xs and 
                                                        ?a1.0 = frm and 
                                                        ?a2.0 = to  and 
                                                        ?a3.0 = f and
                                                        ?a4.0 = acc and
                                                        ?a5.0 = obsv and
                                                        ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0p.elims)
  apply (clarsimp split: if_split_asm)
   apply (erule_tac x = acc' in meta_allE; clarsimp)
   apply (subst val_wa_foldnb_bod_0p.simps)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply (subst val_wa_foldnb_bod_0p.simps)
  apply clarsimp
  done

lemma val_wa_foldnb_bod_0p_back_step:
  "\<lbrakk>val_wa_foldnb_bod_0p xs frm (Suc to) f acc obsv r; Suc to \<le> length xs; frm < to;
    xs ! to = VPrim (LU32 v)\<rbrakk>
    \<Longrightarrow> \<exists>r'. val_wa_foldnb_bod_0p xs frm to f acc obsv r' \<and>
        (\<xi>p, [VRecord [VPrim (LU32 v), r', obsv]] \<turnstile> (App f (Var 0)) \<Down> r)"
  apply (induct arbitrary: v
                rule: val_wa_foldnb_bod_0p.induct[where ?a0.0 = xs and 
                                                        ?a1.0 = frm and 
                                                        ?a2.0 = to  and 
                                                        ?a3.0 = f and
                                                        ?a4.0 = acc and
                                                        ?a5.0 = obsv and
                                                        ?a6.0 = r]; clarsimp)
  apply (erule val_wa_foldnb_bod_0p.elims)
  apply (clarsimp split: if_split_asm)
  apply (erule_tac x = acc' in meta_allE)
  apply (erule_tac x = v in meta_allE)
  apply clarsimp
  apply (case_tac "Suc frma < to")
   apply clarsimp
   apply (rule_tac x = r' in exI)
   apply clarsimp
   apply (subst val_wa_foldnb_bod_0p.simps; clarsimp)
   apply (rule_tac x = acc' in exI)
   apply clarsimp
  apply clarsimp
  apply (subgoal_tac "to = Suc frma")
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule conjI)
    apply (subst val_wa_foldnb_bod_0p.simps; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply clarsimp
    apply (subst val_wa_foldnb_bod_0p.simps; clarsimp)
   apply (erule val_wa_foldnb_bod_0p.elims; clarsimp)
   apply (erule val_wa_foldnb_bod_0p.elims; clarsimp)
  by linarith


definition val_wa_foldnb_0
  where
  "val_wa_foldnb_0 x y = (\<exists>xs frm to acc r func. 
      x = VRecord [VAbstract (VWA xs), VPrim (LU32 frm), VPrim (LU32 to), func, VPrim (LU32 acc),
                   VUnit] \<and> y = VPrim (LU32 r) \<and> (\<forall>i < length xs. \<exists>v. xs ! i = VPrim (LU32 v)) \<and>
      (case func of
            VFunction f ts \<Rightarrow> (\<Xi>, [], [option.Some abbreviatedType1] \<turnstile> (App (Fun f ts) (Var 0)) : 
                                TPrim (Num U32)) \<and>
                              (val_wa_foldnb_bod_0 xs (unat frm) (unat to)
                                (Fun f ts) (VPrim (LU32 acc)) (VUnit) y)
                              
          | VAFunction f ts \<Rightarrow> (\<Xi>, [], [option.Some abbreviatedType1] \<turnstile> (App (AFun f ts) (Var 0)) : 
                                TPrim (Num U32)) \<and>
                               (val_wa_foldnb_bod_0 xs (unat frm) (unat to)
                                (AFun f ts) (VPrim (LU32 acc)) (VUnit) y)
          | _ \<Rightarrow> False))"


definition val_wa_foldnb_0p
  where
  "val_wa_foldnb_0p x y = (\<exists>fs xs frm to. x = VRecord fs \<and> fs! 0 = VAbstract (VWA xs) \<and>
      fs ! 1 = VPrim (LU32 frm) \<and> fs ! 2 = VPrim (LU32 to) \<and> length fs = 6 \<and> 
      (case fs ! 3 of
            VFunction f ts \<Rightarrow> val_wa_foldnb_bod_0p xs (unat frm) (unat to)
                                (Fun f ts) (fs ! 4) (fs ! 5) y
          | VAFunction f ts \<Rightarrow> val_wa_foldnb_bod_0p xs (unat frm) (unat to)
                                (AFun f ts) (fs ! 4) (fs ! 5) y
          | _ \<Rightarrow> False))"

fun \<xi>m1 :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>m1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' 
      then val_wa_foldnb_0 y z
     else \<xi>m x y z)" 

fun \<xi>p1 :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>p1 x y z = 
    (if x = ''wordarray_fold_no_break'' 
      then val_wa_foldnb_0p y z
     else \<xi>p x y z)" 
end (* of context *)
end