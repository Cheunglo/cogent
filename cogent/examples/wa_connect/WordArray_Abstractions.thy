(*
  This file contains the locale WordArray which includes the locale generated by AutoCorres from
  the C file containing the word array functions.
  
  This file also includes the proof that the WordArray locale is a subset of the top level 
  correspondence locale.

  This file also contains the various abstractions for the word array functions.
*)

theory WordArray_Abstractions
  imports Generated_AllRefine
begin

section "Helper Word Lemmas"

lemma word_mult_cancel_left: 
  fixes a b c :: "('a::len) word"
  assumes "0 \<le> a" "0 \<le> b" "0 \<le> c"
  assumes "uint c * uint a \<le> uint (max_word :: ('a::len) word)"
  assumes "uint c * uint b \<le> uint (max_word :: ('a::len) word)"
  shows "c * a = c * b \<longleftrightarrow> c = 0 \<or> a = b"
  apply (rule iffI)
   using assms
   apply (unfold word_mult_def word_of_int_def)
    apply (clarsimp simp:Abs_word_inject max_word_def uint_word_of_int m1mod2k uint_0_iff )
   apply fastforce
   done

section "WordArray Locale Definition"

locale WordArray = main_pp_inferred begin
  definition "abs_repr_u a \<equiv> case a of
      WAU32 _ _ \<Rightarrow> (''WordArray'', [RPrim (Num U32)])
    | _ \<Rightarrow> (''Unknown Abstract Type'', [])"

  definition "abs_typing_u a name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    (case a of
      WAU32 len arr \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num U32)] \<and> sig \<noteq> Unboxed \<and>
                      (sigil_perm sig = option.Some ReadOnly \<longrightarrow> w = {} \<and> r = {arr + 4 * i | i. i < len}) \<and>
                      (sigil_perm sig = option.Some Writable \<longrightarrow> r = {} \<and> w = {arr + 4 * i | i. i < len}) \<and>
                      (\<forall>i < len. \<exists>x. \<sigma>(arr + 4 * i) = option.Some (UPrim (LU32 x))) \<and> 4 * unat len \<le> unat (max_word :: ptrtyp)
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [] \<and> r = {} \<and> w = {} \<and> sig = Unboxed)"

  definition "abs_typing_v a name \<tau>s \<equiv>
    (case a of
      VWA xs \<Rightarrow> name = ''WordArray'' \<and> \<tau>s = [TPrim (Num U32)] \<and> (\<forall>i < length xs. \<exists>x. xs ! i = VPrim (LU32 x))
    | _ \<Rightarrow> name = ''Unknown Abstract Type'' \<and> \<tau>s = [])"

  definition  "abs_upd_val' au av name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    abs_typing_u au name \<tau>s sig r w \<sigma> \<and> abs_typing_v av name \<tau>s \<and>
    (case au of
      WAU32 len arr \<Rightarrow>
        (case av of 
          VWA xs \<Rightarrow> unat len = length xs \<and> 
                      (\<forall>i < len. \<exists>x. \<sigma>(arr + 4 * i) = option.Some (UPrim (LU32 x)) \<and> 
                                     xs ! (unat i) = VPrim (LU32 x))
          | _ \<Rightarrow> False)
      | _ \<Rightarrow> (case av of
                VTOther _ \<Rightarrow> True
             |  _ \<Rightarrow> False))"

lemma distinct_indices:
  "abs_typing_u (WAU32 len arr) n ts s r w \<sigma> \<Longrightarrow> \<forall>i < len. \<forall>j < len. i = j \<longleftrightarrow> 4 * i = 4 * j"
  apply clarsimp
  apply (rule iffI)
   apply (clarsimp simp: abs_typing_u_def)
  apply (clarsimp simp: abs_typing_u_def)
  apply (subgoal_tac "0 \<le> i")
   apply (frule_tac b = j and c = 4 in word_mult_cancel_left; clarsimp simp: uint_nat)
    apply (subgoal_tac "int (unat i) < int (unat len)")
     apply linarith
    apply (simp add: unat_mono)
   apply (subgoal_tac "int (unat j) < int (unat len)")
    apply linarith
   apply (simp add: unat_mono)
  apply simp
  done      
end

section "Sublocale Proof"

sublocale WordArray \<subseteq> Generated_cogent_shallow _ abs_repr_u abs_typing_v abs_typing_u abs_upd_val'
  apply (unfold abs_repr_u_def[abs_def] abs_typing_v_def[abs_def] abs_typing_u_def[abs_def] abs_upd_val'_def[abs_def])
  apply (unfold_locales; clarsimp split: vatyp.splits atyp.splits)
          apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
         apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
        apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
       apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
      apply (case_tac s; clarsimp; case_tac x11a; clarsimp; erule_tac x = i in allE; clarsimp)
     apply (case_tac s, (case_tac s', simp_all)+)[]
    apply (unfold UpdateSemantics.frame_def)
    apply (erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply (case_tac s; clarsimp; case_tac x11a; clarsimp;
           drule_tac x = "x12 + 4 * i" in orthD1; simp; rule_tac x = i in exI; simp)
   apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
  apply (case_tac s; clarsimp; case_tac x11a; clarsimp)
   apply (rule conjI; clarsimp; erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply auto[1]
   apply (erule_tac x = i in allE; clarsimp)
   apply auto[1]
  apply (rule conjI; clarsimp; erule_tac x = "x12 + 4 * i" in allE; clarsimp)
    apply (erule_tac x = i in allE; clarsimp)
    apply (rule_tac x = x in exI)
    apply auto[1]
   apply (erule_tac x = i in allE; clarsimp)
   apply auto[1]
  done

section "Abstractions for Word Arrays"
section "Shallow Word Array Value Relation"

overloading
  valRel_WordArrayU32 \<equiv> valRel
begin
  definition valRel_WordArrayU32: 
    "\<And>\<xi> x v. valRel_WordArrayU32 (\<xi> :: (funtyp,vabstyp) vabsfuns) (x :: (32 word) WordArray) (v :: (funtyp, vabstyp) vval) \<equiv> 
      \<exists>xs. v = VAbstract (VWA xs) \<and> length x = length xs \<and> (\<forall>i < length xs. xs ! i = VPrim (LU32 (x ! i)))"
end

subsection "Shallow Word Array Function Definitions"

overloading
  wordarray_put2' \<equiv> wordarray_put2
begin
definition wordarray_put2':
 "wordarray_put2' (x :: ('a WordArray, 32 word, 'a) WordArrayPutP) \<equiv> (WordArrayPutP.arr\<^sub>f x)[unat (WordArrayPutP.idx\<^sub>f x) := WordArrayPutP.val\<^sub>f x]" 
end

overloading
  wordarray_length' \<equiv> wordarray_length
begin
definition wordarray_length':
 "wordarray_length' (x :: 'a WordArray) \<equiv> (of_nat (length x) :: 32 word)" 
end

overloading
  wordarray_get' \<equiv> wordarray_get
begin
definition wordarray_get':
 "wordarray_get' (x :: (32 word WordArray, 32 word) RR) \<equiv> (if unat (RR.p2\<^sub>f x) < length (RR.p1\<^sub>f x) then (RR.p1\<^sub>f x) ! unat (RR.p2\<^sub>f x) else 0)" 
end

subsection "\<xi> Abstractions"

definition upd_wa_put2_0
  where
  "upd_wa_put2_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in (\<exists>p idx val. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 idx), RPrim (Num U32)), (UPrim (LU32 val), RPrim (Num U32))] \<and>
          y2 = UPtr p (RCon ''WordArray'' [RPrim (Num U32)]) \<and>
          y1 = (\<lambda>l. (if \<exists>len arr. x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
                        l = arr + 4 * idx \<and> idx < len then option.Some (UPrim (LU32 val)) else x1 l))))"

definition upd_wa_get_0
  where
  "upd_wa_get_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p idx len arr. x2 = URecord [
          (UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 idx), RPrim (Num U32))] \<and> x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
            (idx < len \<longrightarrow> x1 (arr + 4 * idx) = option.Some y2) \<and>
            (\<not> idx < len \<longrightarrow> y2 = UPrim (LU32 0))))"

definition upd_wa_length_0
  where
  "upd_wa_length_0 x y =
      (let (x1, x2) = x;
           (y1, y2) = y
      in x1 = y1 \<and> (\<exists>p len arr. x2 = UPtr p (RCon ''WordArray'' [RPrim (Num U32)]) \<and>
          x1 p = option.Some (UAbstract (WAU32 len arr)) \<and> y2 = UPrim (LU32 len)))"

definition val_wa_length_0
  where
  "val_wa_length_0 x y = (\<exists>xs len. x = VAbstract (VWA xs) \<and> y = VPrim (LU32 len) \<and> 
                                length xs = unat len)" 


definition val_wa_get_0
  where
  "val_wa_get_0 x y =
      (\<exists>xs idx v. x = VRecord [VAbstract (VWA xs), VPrim (LU32 idx)] \<and> y = VPrim (LU32 v) \<and>
       (unat idx < length xs \<longrightarrow> xs ! unat idx = y) \<and> (\<not> unat idx < length xs \<longrightarrow> v = 0))" 

definition val_wa_put2_0
  where
  "val_wa_put2_0 x y =
      (\<exists>xs idx val. x = VRecord [VAbstract (VWA xs), VPrim (LU32 idx), VPrim (LU32 val)] \<and>
       y = VAbstract (VWA (xs[unat idx := VPrim (LU32 val)])))" 


fun \<xi>0 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>0 x y z = 
    (if x = ''wordarray_put2_0'' then upd_wa_put2_0 y z
     else (if x = ''wordarray_get_0'' then upd_wa_get_0 y z
           else (if x = ''wordarray_length_0'' then upd_wa_length_0 y z
                 else False)))" 

fun \<xi>m :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>m x y z = 
    (if x = ''wordarray_put2_0'' then val_wa_put2_0 y z
     else (if x = ''wordarray_get_0'' then val_wa_get_0 y z
           else (if x = ''wordarray_length_0'' then val_wa_length_0 y z
                 else False)))" 

fun \<xi>p :: "(char list, vatyp) vabsfuns" 
  where
  "\<xi>p x y z = 
    (if x = ''wordarray_put2'' then val_wa_put2_0 y z
     else (if x = ''wordarray_get'' then val_wa_get_0 y z
           else (if x = ''wordarray_length'' then val_wa_length_0 y z
                 else False)))" 

(*
function \<xi>1 :: "(char list, atyp, 32 word) uabsfuns" 
  and upd_wa_foldnb_0  :: "(char list, atyp, 32 word) ufundef" 
(*  and upd_wa_mapnb_0  :: "(char list, atyp, 32 word) ufundef" *)
  where
  "\<xi>1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' then upd_wa_foldnb_0 y z
     else (if x = ''wordarray_map_no_break_0'' then False 
           else \<xi>0 x y z))" 
| "upd_wa_foldnb_0 (b1, b2) c = (\<exists>p frm to f ts acc len arr.
    b2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
      (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
      (UFunction f ts, RFun), (UPrim (LU32 acc), RPrim (Num U32)), (UUnit, RUnit)] \<and> 
    b1 p = option.Some (UAbstract (WAU32 len arr)) \<and>
    (if frm < min to len 
      then (\<exists>v b1' acc'. (b1 (arr + 4 * frm) = option.Some (UPrim (LU32 v))) \<and> 
        (\<xi>1, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), (UPrim (LU32 acc), RPrim (Num U32)), 
          (UUnit, RUnit)])] \<turnstile> (b1, App (Fun f ts) (Var 0)) \<Down>! (b1', UPrim (LU32 acc'))) \<and>
        upd_wa_foldnb_0 (b1', URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
          (UPrim (LU32 (frm + 1)), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
          (UFunction f ts, RFun), (UPrim (LU32 acc'), RPrim (Num U32)), (UUnit, RUnit)]) c)
    else (b1, b2) = c))"
  by pat_completeness auto

termination \<xi>1
  apply (relation "measure 
    (\<lambda>x. case x of Inl (_, _, _) \<Rightarrow> Suc (unat ((max_word :: 32 word)))
             | Inr ((a1, a2), _) \<Rightarrow> 
                      (case a2 of URecord [] \<Rightarrow> 0
                                        | _ \<Rightarrow> 0))")
     apply clarsimp
  apply clarsimp
  sorry
*)
type_synonym ('f, 'a, 'l) ufoldmapdef = "('f, 'a, 'l) store \<Rightarrow> 32 word \<Rightarrow> 32 word \<Rightarrow> 32 word \<Rightarrow>
                                        'f expr \<Rightarrow> (('f, 'a, 'l) uval \<times> repr)\<Rightarrow> 
                                        (('f, 'a, 'l) uval \<times> repr) \<Rightarrow>
                                        (('f, 'a, 'l) store \<times> ('f, 'a, 'l) uval) \<Rightarrow> bool"
(* We will need to define a different body for each type of accumulator so that we can prove
   that the frame constraints still hold whne proving the proc_env_matches_ptrs constraint*)
function upd_wa_mapnb_bod_0 :: "(char list, atyp, 32 word) ufoldmapdef"
  where
  "upd_wa_mapnb_bod_0 \<sigma> p frm to f acc obsv res = (\<exists>len arr. 
    \<sigma> p = option.Some (UAbstract (WAU32 len arr)) \<and> 
    (if frm < min to len then (\<exists>v v' acc'. \<sigma> (arr + 4 * frm) = option.Some (UPrim (LU32 v)) \<and> 
         (\<xi>0, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), acc, obsv])] \<turnstile> 
            (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>, URecord [(UPrim (LU32 v'), RPrim (Num U32)), (acc', prod.snd acc)])) \<and>
          upd_wa_mapnb_bod_0 (\<lambda>l.(if l = arr + 4 * frm then option.Some (UPrim (LU32 v')) else \<sigma> l))
             p (frm + 1) to f (acc', prod.snd acc) obsv res) 
    else (\<sigma>, URecord [(
        UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
         acc]) = res))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, frm, to, _, _, _, _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done

function upd_wa_foldnb_bod_0 :: "(char list, atyp, 32 word) ufoldmapdef"
  where
  "upd_wa_foldnb_bod_0 \<sigma> p frm to f acc obsv res = (\<exists>len arr. \<sigma> p = option.Some (UAbstract (WAU32 len arr)) \<and>
    (if frm < min to len then (\<exists>v acc' \<sigma>'. \<sigma> (arr + 4 * frm) = option.Some (UPrim (LU32 v)) \<and> 
          (\<xi>0, [(URecord [(UPrim (LU32 v), RPrim (Num U32)), acc, obsv])] \<turnstile> (\<sigma>, App f (Var 0)) \<Down>! (\<sigma>', acc')) \<and>
          \<sigma> p = \<sigma>' p \<and> (\<forall>i<len. \<sigma> (arr + 4 * i) = \<sigma>' (arr + 4 * i)) \<and>
          upd_wa_foldnb_bod_0 \<sigma>' p (frm + 1) to f (acc', prod.snd acc) obsv res) 
    else (\<sigma>, prod.fst acc) = res))"
  by pat_completeness auto
termination
  apply (relation "measure (\<lambda>(_, _, frm, to, _, _, _, _). unat to - unat frm)"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt)
  apply (cut_tac n = frm in unat_Suc2; clarsimp)
   apply (cut_tac y = to in word_not_simps(3); clarsimp simp: word_less_nat_alt)
  apply linarith
  done
print_theorems
declare upd_wa_mapnb_bod_0.simps[simp del]
declare upd_wa_foldnb_bod_0.simps[simp del]

lemma upd_wa_foldnb_bod_0_to_geq_len:
  "\<lbrakk>upd_wa_foldnb_bod_0 \<sigma> p frm len f acc obsv (\<sigma>', r); \<sigma> p = option.Some (UAbstract (WAU32 len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_bod_0 \<sigma> p frm to f acc obsv (\<sigma>', r)"
  apply (induct arbitrary: to arr rule: upd_wa_foldnb_bod_0.induct[where ?a0.0 = \<sigma> and 
                                                       ?a1.0 = p and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = len and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = to in meta_spec)
  apply (subst (asm) upd_wa_foldnb_bod_0.simps)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>' in meta_spec)
   apply (drule_tac x = toa in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = to in exI)
   apply (rule_tac x = arr in exI)
   apply (rule conjI; clarsimp)
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>' in exI)
    apply clarsimp
   apply (rule FalseE)
   apply auto[1]
  apply (subst upd_wa_foldnb_bod_0.simps)
  apply clarsimp
  done

lemma upd_wa_foldnb_bod_0_to_geq_lenD:
  "\<lbrakk>upd_wa_foldnb_bod_0 \<sigma> p frm to f acc obsv (\<sigma>', r); \<sigma> p = option.Some (UAbstract (WAU32 len arr));
    to \<ge> len\<rbrakk> \<Longrightarrow> upd_wa_foldnb_bod_0 \<sigma> p frm len f acc obsv (\<sigma>', r)"
  apply (induct rule: upd_wa_foldnb_bod_0.induct[where ?a0.0 = \<sigma> and 
                                                       ?a1.0 = p and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (subst (asm) upd_wa_foldnb_bod_0.simps)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = len in exI)
   apply (rule_tac x = arr in exI)
   apply clarsimp
   apply (rule_tac x = acc' in exI)
   apply (rule_tac x = \<sigma>' in exI)
   apply clarsimp
  apply (case_tac "frm < to")
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
  apply clarsimp
  apply (subgoal_tac "\<not> frm < len")
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
  apply auto
  done

lemma upd_wa_foldnb_bod_0_step:
  "\<lbrakk>upd_wa_foldnb_bod_0 \<sigma> p frm to f acc obsv (\<sigma>', r); \<sigma> p = option.Some (UAbstract (WAU32 len arr));
    frm \<le> to; to < len; \<sigma> (arr + 4 * to) = option.Some (UPrim (LU32 v)); \<sigma>' p = \<sigma>'' p;
    \<forall>i<len. \<sigma>' (arr + 4 * i) = \<sigma>'' (arr + 4 * i);
    \<xi>0, [URecord [(UPrim (LU32 v), RPrim (Num U32)), (r, prod.snd acc), obsv]] \<turnstile> (\<sigma>', App f (Var 0))\<Down>! (\<sigma>'', r')\<rbrakk> 
    \<Longrightarrow> upd_wa_foldnb_bod_0 \<sigma> p frm (to + 1) f acc obsv (\<sigma>'', r')"
  apply (induct arbitrary: len arr v r r' \<sigma>' \<sigma>''
                rule: upd_wa_foldnb_bod_0.induct[where ?a0.0 = \<sigma> and 
                                                       ?a1.0 = p and 
                                                       ?a2.0 = frm and 
                                                       ?a3.0 = to and
                                                       ?a4.0 = f and
                                                       ?a5.0 = acc and
                                                       ?a6.0 = obsv and
                                                       ?a7.0 = "(\<sigma>', r)"])
  apply clarsimp
  apply (drule_tac x = len in meta_spec)
  apply (erule upd_wa_foldnb_bod_0.elims)
  apply (clarsimp split: if_splits)
   apply (drule_tac x = acc' in meta_spec)
   apply (drule_tac x = \<sigma>'''' in meta_spec)
   apply (drule_tac x = len in meta_spec)
   apply (drule_tac x = arr in meta_spec)
   apply (drule_tac x = v in meta_spec)
   apply (drule_tac x = bd in meta_spec)
   apply (drule_tac x = r' in meta_spec)
   apply (drule_tac x = ad in meta_spec)
   apply (drule_tac x = \<sigma>'' in meta_spec)
   apply clarsimp
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule_tac x = len in exI)
   apply (rule_tac x = arr in exI)
   apply clarsimp
   apply (rule conjI)
    apply clarsimp
    apply (rule_tac x = acc' in exI)
    apply (rule_tac x = \<sigma>'''' in exI)
    apply clarsimp
    apply (case_tac "frma + 1 \<le> toa")
     apply clarsimp
    apply (subst upd_wa_foldnb_bod_0.simps)
    apply clarsimp
    apply (rule_tac x = len in exI)
    apply (rule_tac x = arr in exI)
    apply clarsimp
    apply (rule conjI)
     apply clarsimp
     apply (rule FalseE)
  using inc_le apply blast
    apply clarsimp
     apply (rule FalseE)
  using inc_le apply blast
   apply clarsimp
   apply (rule FalseE)
   apply (metis (mono_tags) add.commute add.left_neutral inc_i inc_le not_le plus_one_helper2 word_gt_a_gt_0 word_less_1)
  apply (erule disjE)
   apply clarsimp
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (subst upd_wa_foldnb_bod_0.simps)
   apply clarsimp
   apply (rule FalseE)
   apply (meson less_is_non_zero_p1 word_overflow)
  apply (rule FalseE)
  by auto

fun upd_wa_foldnb_0  :: "(char list, atyp, 32 word) ufundef" 
  where
  "upd_wa_foldnb_0 y z = 
    (let (y1, y2) = y;
         (z1, z2) = z
      in (\<exists>p frm to f ts acc.
        y2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
            (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
            (UFunction f ts, RFun), (UPrim (LU32 acc), RPrim (Num U32)), (UUnit, RUnit)] \<and> y1 = z1 \<and>
        y1 p = z1 p \<and> (\<exists>len arr. y1 p = option.Some (UAbstract (WAU32 len arr)) \<and> 
          (\<forall>i<len. y1 (arr + 4 * i) = z1 (arr + 4 * i))) \<and>
        upd_wa_foldnb_bod_0 y1 p frm to (Fun f ts) (UPrim (LU32 acc), RPrim (Num U32)) (UUnit, RUnit) z))"

fun upd_wa_mapnb_0  :: "(char list, atyp, 32 word) ufundef" 
  where
  "upd_wa_mapnb_0 y z = 
    (let (y1, y2) = y 
      in (\<exists>p frm to f ts.
        y2 = URecord [(UPtr p (RCon ''WordArray'' [RPrim (Num U32)]), RPtr (RCon ''WordArray'' [RPrim (Num U32)])),
            (UPrim (LU32 frm), RPrim (Num U32)), (UPrim (LU32 to), RPrim (Num U32)),
            (UFunction f ts, RFun), (UUnit, RUnit), (UUnit, RUnit)] \<and> 
        upd_wa_mapnb_bod_0 y1 p frm to (Fun f ts) (UUnit, RUnit) (UUnit, RUnit) z))"

fun \<xi>1 :: "(char list, atyp, 32 word) uabsfuns" 
  where
  "\<xi>1 x y z = 
    (if x = ''wordarray_fold_no_break_0'' then upd_wa_foldnb_0 y z
     else (if x = ''wordarray_map_no_break_0'' then upd_wa_mapnb_0 y z 
           else \<xi>0 x y z))" 

thm validNF no_fail_def validNF_def valid_def dec_arr_typecorrect'

end