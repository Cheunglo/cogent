\documentclass{article}
\usepackage{xspace}
\usepackage
[
        a4paper,% other options: a3paper, a5paper, etc
        left=2cm,
        right=2cm,
        top=3cm,
        bottom=4cm,
        % use vmargin=2cm to make vertical margins equal to 2cm.
        % us  hmargin=3cm to make horizontal margins equal to 3cm.
        % use margin=3cm to make all margins  equal to 3cm.
]
{geometry}
\newcommand{\cogent}{\textsc{Cogent}\xspace}
\newcommand{\Cogent}{\textsc{Cogent}\xspace}

\title{A Guide to Verifying Abstract Types and Functions within \cogent}
\author{Louis Cheung}

\begin{document}
\maketitle

This document provides a brief description of the necessary steps one needs
to take in order to have complete refinement from shallow embedding to C
for a \cogent program that uses abstract types and/or abstract functions.

\section{Abstract Types}
To distinguish between abstract types and their values, we will refer to
their values as abstract values.

\subsection{Embeddings}
For the update, value and the shallow semantics, we need to provide an
embedding for abstract values,
i.e. we need to define what their values should look like.

For example, in the update semantics, we define word arrays as
{``\texttt{UWA} $\tau$ \textit{len} \textit{arr}''},
where \texttt{UWA} is the constructor,
$\tau$ is the Isabelle term representing the element type of the array,
\textit{len} is a 32-bit word representing the length of the array,
and \textit{arr} is a 32-bit word representing the address of the first
element in the array.
In the value semantics, we define them as
{``\texttt{VWA} $\tau$ ``$\alpha$ list''''},
where \texttt{VWA} is the constructor,
$\tau$ is the Isabelle term representing the element type of the array,
and ``$\alpha$ list'' is the abstraction of a word array as a list of values,
where $\alpha$ is instantiated as a \Cogent value in the value semantics.
In the shallow semantics, word array are embedded as Isabelle lists.

Note that we do not need two different embeddings for the polymorphic and
monomorphic value semantics.

The embedding in the value semantics can be defined in any location that
suits the user and is sensible,
e.g. in a new theory file.
For the embeddings in the update and shallow semantics, the following files
must be modified:
\begin{itemize}
\item \texttt{Value\_Relation.thy} \textit{-- update}\\
This file is a core part of the \Cogent refinement framework and is
manually written.
Currently, the Isabelle \texttt{datatype}, \texttt{abstyp},  does not
contain any embeddings for any abstract type.
The embeddings should be added to this datatype.
\item \texttt{XXX\_ShallowShared.thy} \textit{-- shallow}\\
This file is automatically generated and is different for each \cogent program.
The \texttt{XXX} is the capitalised name that user provides to the \cogent
compiler.
Currently, the \cogent compiler automatically emits an Isabelle
\texttt{typedecl} for each abstract type.
This should be replaced with an Isabelle type that is a suitable
representation for the abstract type.
\end{itemize}

\subsection{Type Relation and Value Relation}
The type relation relates a representation of a \cogent type with a with an
Isabelle type,
which in turn represents a C type.
The type relation is used in the update-C refinement where it determines
which AutoCorres typed heap a \cogent value would reside in.

There are 3 value relations: update-C, value-update and shallow-value.
These value relations relate values from one semantics to another.

The update-C value relation relates a value in the update semantics with an
Isabelle term representing a C value.
Note that this relation does not allow for the dereferencing of pointers,
i.e. we cannot extract the value of a pointer within this value relation.
This means that a pointer in the C value should only relate to a pointer in
the update semantics.

The value-update value relation relates a value in the value semantics with
a value in the update semantics.
This relation also takes the type of the value, the current \cogent heap
and the heap footprint of the value in the update semantics.
The purpose of this value relation is to lift pointers to values so that we
can remove all references to the heap and only reason about pure
expressions.
There 4 constraints on this value relation which are:
\begin{itemize}
\item \textbf{Value typing (update semantics)}: the value in the update
semantics is type correct, i.e. satisfies the abstract value typing
relation in the update semantics.
\item \textbf{Value typing (value semantics)}: the value in the value
semantics is type correct, i.e. satisfies the abstract value typing
relation in the value semantics.
\item \textbf{Bang}: applying the \textbf{bang} operator to the value
should make it read-only.
\item \textbf{Frame}: values should remain unchanged if they are not part
the frame that could be modified.
\end{itemize}
These constraints are part of the \textbf{correspondence} locale, and hence, 
we need to prove that these are true for any relation we use to instantiate
any locale that is a sublocale of a locale that extends or is a sublocale
of the \textbf{correspondence} locale defined in
\texttt{Correspondence.thy}.

The shallow-value value relation relates a value in the shallow semantics
with a value in the polymorphic value semantics.
This value relations also takes the mapping that contains all the semantics
of abstract functions,
i.e. a mapping that takes an abstract function identifier and returns a
relation that defines the set of all possible input and output pairs for
that abstract function.

The value-update and the shallow-value relation can be defined in any
location that suits the user and is sensible,
e.g. in a new theory file.
For update-C type and value relation, the following files need to be modified:
\begin{itemize}
\item \texttt{XXX\_CorresSetup.thy} \textit{-- update-C}\\
This file is automatically generated and is different for each \cogent program.
The \texttt{XXX} is the capitalised name that user provides to the \cogent
compiler.
This file calls the function\\
\texttt{local\_setup\_val\_rel\_type\_rel\_put\_them\_in\_buckets} that
defines the update-C value and type relations.
The definition for the type and value relation for abstract types should go here.
\item \texttt{Cogent\_C\_Val\_Auto.thy} \textit{-- update-C}\\
This file is a core part of the \Cogent refinement framework and is
manually written.
Currently, this function defines the update-C value relations for all values,
however, the definition for abstract definitions is
{``$\mathtt{val\_rel}~\mathit{uv}~\mathit{cv} = \exists x.\ uv =
\mathtt{UAbstract}~x$''}.
This definition is not very useful and needs to be replaced.
Although not the best, the current solution is to modify\\
\verb!local_setup_val_rel_type_rel_put_them_in_buckets! to not define a
value relation and type relation for all abstract types that we
wish to manually define the value and type relation for.\\
\textit{-- \textbf{FIXME:} Make the function}
\texttt{local\_setup\_val\_rel\_type\_rel\_put\_them\_in\_buckets}
\textit{take a list of abstract types to ignore.}
\end{itemize}

\subsection{Abstract Value Typing}
The abstract value typing relation is used to relate an embedding of an
abstract value with its abstract type.
The abstract value typing relation in the update semantics take an
embedding of an abstract value, an abstract type represented as an Isabelle
term, the values heap footprint and the \Cogent heap,
and returns true if the abstract value is a value of that abstract type for
the given heap and heap footprint.
Similarly, the abstract value typing relation in the value semantics takes
an embedding of an abstract value and an abstract type represented as an
Isabelle term,
and returns if the abstract value is a value of that abstract type.

The abstract value typing relation in the update semantics has several
constraints on it.
These are:
\begin{itemize}
\item \textbf{Bang}: applying the bang operator to the value makes it
read-only and if it was already read-only then no changes occur
\item \textbf{No alias}: there is no internal aliasing, i.e. pointers can
be either read or write but cannot be both
\item \textbf{Read-only}: if a value should be read-only (according to the
type) then all of its pointers should be read-only
\item \textbf{Escapable}: if a value is of kind E, i.e. can be bound in a
(\textbf{let!}) expression, then it must not have any read-only pointers
\item \textbf{Valid}: All pointers in a value point to valid values on the heap
\item \textbf{Frame}: if a value is not in the frame, then it remains unchanged
\end{itemize}
Note that we also require a mapping from embeddings of abstract values to
type representations used in the type relation.
This mapping should satisfy the following constraints:
\begin{itemize}
\item \textbf{Unique typing representation}: there should only be one
mapping for any abstract value
\item \textbf{Abstract representation}: if the abstract value typing
relation holds for some value,
then the typing representation should consists of a pair containing the
name of the abstract type and a list of type representations of the
abstract type's type parameters
\end{itemize}
Notice that the \textbf{Abstract representation} constraint defines what
the mapping should be.
These constraints are part of the \textbf{update\_sem} locale, and hence, 
we need to prove that these are true for any relation we use to instantiate
any locale that is a sublocale of a locale that extends or is a sublocale
of the \textbf{update\_sem} locale defined in \verb!UpdateSemantics.thy!.

The abstract value typing relation in the value semantics only has one
constraint:
\begin{itemize}
\item \textbf{Bang}: applying the bang operator to the value makes it
read-only and if it was already read-only then no changes occur
\end{itemize}
These constraints are part of the \textbf{value\_sem} locale, and hence, 
we need to prove that these are true for any relation we use to instantiate
any locale that is a sublocale of a locale that extends or is a sublocale
of the \textbf{value\_sem} locale defined in \verb!ValueSemantics.thy!.

\subsection{Heap Relation}
Since AutoCorres splits up the heap into heaps of different types,
the heap relation is actually the conjunction of typed heap relations for
each typed heap that has a value which is visible from \cogent.
Currently, only the typed heap relations for boxed \Cogent records is
automatically defined by the function \verb!local_setup_heap_rel!.
So we need to add the typed heap relation for each each boxed abstract type
to the heap relation.
This is not sufficient when an abstract type consists of objects that
reside on the heap and are not boxed \cogent records,
since the only heap objects that \cogent can recognize are boxed records
and boxed abstract types.
In this case we need to add the typed heap relation for each of these objects

Files that need to be modified:
\begin{itemize}
\item \verb!XXX_CorresSetup.thy!\\
This file is automatically generated and is different for each \cogent program.
The \verb!XXX! is the capitalised name that user provides to the \cogent
compiler.
There are two ways to add the typed heap relations for abstract types and
their constituent parts.
The first is to redefine the heap relation, however, this is not suitable
when there are a lot of boxed \Cogent records as these will need to
be redefined as well.
The second is to \\
\textit{-- \textbf{FIXME:} Make the function}
\verb!local_setup_instantiate_cogent_C_heaps_store_them_in_buckets!
\textit{take a list of types to add to the \cogent C heap store} in the file \verb!Cogent_C_Heap_Auto.thy!\\
\textit{-- \textbf{FIXME:} Make the function} \verb!local_setup_heap_rel!
\textit{to set the heap relation for abstract types and their constituent
parts or take a list of types if this cannot be done
automatically.}
\end{itemize}

\section{Abstract Functions}
\Cogent's correspondence theorems assume that that all abstract functions
refine their embeddings in each semantic layer,
and that these embeddings preserve typing and satisfy the frame constraints.
For first order functions, these are fairly straightforward to generate.
For second order functions, we need to assume that all first order
functions refine their embeddings in each semantic layer,
and that they preserve typing and satisfy the frame constraints.

\subsection{Embeddings}
We need to provide an embedding for each abstract function for the update,
monomorphic value, polymorphic value and the shallow semantics.
Note that it may be possible to use the embedding form the polymorphic
value semantics in the monomorphic value semantics.

The embeddings in the update, monomorphic value and polymorphic value
semantics should be relations that
define the possible input and output pairs of the abstract function.
In the case of the update semantic embedding, the input and output should
also consists of the \Cogent heap before and after the abstract function is
applied.
For the update, monomorphic value and polymorphic value, we define two
mappings each.
These mappings map a function name to the its corresponding embedding.
The first mapping only contains the mappings first order abstract
functions,
whilst the second contains mappings for both first and second order
abstract functions.
We require two mappings for each semantic layer because the input-output
relation for second order abstract functions depend on the evaluation
relation for for first order functions, which in turn relies on the
input-output relation for all first order abstract functions.
Hence, the input-output relations for second order abstract functions will
use the mapping for first order abstract functions in its definition.
In our experience, we found that rather than hard-coding the mapping of
first order abstract functions in the definition of a second order abstract
function input-output relation, passing this as an argument to the relation
was better since this made the relations and theorems reusable for
different \Cogent programs. 
Note that the mappings in the update semantics should overload the Isabelle
constants $\mathtt{user}\_\xi\_0, \mathtt{user}\_\xi\_1$ for first order
mappings, and first and second order mappings respectively.
In addition, theorems about second order functions should be instantiated
with the mappings for first and second order abstract functions, whilst
theorems for first order functions can be instantiated with either mapping.

In the shallow semantics, the embedding is simply a function,
and for second order abstract functions, these functions are simply higher
order functions.
These should overload the relevant Isabelle constants that the \Cogent
compiler generates for each abstract function.

\subsection{Type Preservation and Frame Constraint Satisfiability}
The correspondence theorems all depend on abstract functions preserving
typing and satisfying the frame constraints.
We first prove type preservation and frame constraint satisfiability for
all first order abstract functions.

\subsection{Update to C Refinement}
\subsection{Monomorphic Value to Update Refinement and Upward Propagation}
The core theorem of \cogent that the update semantics refines the value
semantics and that if the update semantics executes then so will the value
semantics,
depends on all embeddings of abstract functions in the update semantics
refining their embeddings in the value semantics and that their value
semantic embeddings will execute if their update semantics embeddings will,
i.e. it is the $\xi_u~\sim~\xi_v~\mathbf{matches-u-v}~\Xi$ assumption.
For first order abstract functions, this should hopefully be straightforward.

For second order abstract functions,
whose set of function arguments are first order, we need to assume that
$\xi_u~\sim~\xi_v~\mathbf{matches-u-v}~\Xi$ holds for all first order
abstract functions.
This assumption implies that all embeddings first order
functions, which the abstract function could possibly call, in the update
semantics refine their value semantics embedding and executes if the
embedding in the update semantics executed,
and this is exactly what we need to prove refinement and upward
propagation.

Some minor note

\subsection{Polymorphic Value to Monomorphic Value Refinement}
\subsection{Shallow to Polymorphic Value Refinement}

\section{Changes to \Cogent in \texttt{wordarray-example} not in \texttt{master}}
This section contains a list changes made to the \texttt{wordarray-example}
branch that have not been pushed to \texttt{master} branch.

Files changed:
\begin{enumerate}
\item \verb!UpdateSemantics.thy!: The following changes were made:
\begin{enumerate}
\item Modified the abstract value typing relation to also take the \Cogent
store as an argument. This fixes an error in the formalisation where
the \texttt{valid} constraint is would force all pointers in an
abstract type to be valid for any \Cogent store.
\item Added the frame constraint to the abstract value typing constraints.
According to the pen and paper formalisation, abstract types should
satisfy this constraints, but this was missing.
This was also added since the changes in 1a caused the proof for
\texttt{uval\_typing\_frame} to break and this assumption was
needed to solve it.
\item Added the constraint that if two embeddings of an abstract value are
equal and satisfy the abstract value typing constraint with the same
\Cogent store and type, then their heap footprints should be the
same.\\
\textit{-- FIXME: This constraint may not be needed.}
\item The proof for \texttt{uval\_typing\_frame} was modified to reflect
the changes from 1a and 1b.
\end{enumerate}
\item \verb!Cogent_Corres.thy!
\begin{enumerate}
\item Modified the locale to reflect changes introduced by 1a.
\end{enumerate}
\item \verb!Correspondence.thy!
\begin{enumerate}
\item Modified the locale to reflect the changes introduced by 1a.
\item Added a frame constraint similar to 1b.
This was needed to we could prove \texttt{upd\_val\_rel\_frame} which broke
due to changes introduce by 2a.
\item Fixed proof for \texttt{upd\_val\_rel\_frame} to reflect changes from
2a and 2b.
\end{enumerate}
\end{enumerate}

\end{document}
