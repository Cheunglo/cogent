-- A third stab at translating the minimal C example: brutal.c
-- We use abstract functions to hide the pointer arithmetic and
-- iteration required by the example. The rest of the example can
-- be expressed in Cogent.
--
--
-- We have restricted the provided interface to only those functions
-- essential for the example.

include <gum/common/common.cogent>
include <gum/common/iterator.cogent>

type Vector -- The "Buffer" type

-- We split a vector/buffer into two:
--
--  * BItem enumerates the initialised portion of a buffer;
--  * BTail points to the start of the uninitialised portion.
type BItem
type BTail

-- The main abstract function for buffers. We can decompose a buffer
-- into its constituent parts, an item and a tail object.
-- Given a function which operates on the item and tail we can
-- internally call this function to modify the provided buffer.
focus_buffer : all (a,b).(Vector, b!,
                   #{ obj : (BItem, BTail), obsv : b!} -> (a, BItem, BTail)) ->
  (a, Vector)

-- Start BItem & BTail interface functions.

-- Retrieve the next item given both the current item and the tail. This
-- function should return the next item on success (Some), or the given
-- item if it is the last initialised item.
next : (BItem, BTail!) -> <None BItem | Some BItem>

-- Retrieve the read-only contents for the given item.
read : BItem! -> Entry!

-- End of BItem & BTail interface functions.

-- Example-specific types and definitions.

-- The data we wish to retrieve.
type Data =
  < Person #TPerson | Addr #TAddr | Date #TDate >

layout LData = variant (2b) { Person(0) : LPerson at 1B, Addr(1) : LAddr at 1B, Date(2) : LDate at 1B }

type TPerson = { age : U32, len : U8, name : U8#[0] }  -- the name ends with \0, and len (of name) includes it.
type TAddr   = { zip : U8 , len : U8, addr : U8#[0] }  -- the addr ends with \0, and len (of addr) includes it.
type TDate   = { yr  : U8 , mon : U8, day  : U8 }

layout LPerson = record { age : 4B, len : 1B at 4B, name : array[1B] at 5B }
layout LAddr   = record { zip : 1B, len : 1B at 1B, addr : array[1B] at 2B }
layout LDate   = record { yr  : 1B, mon : 1B at 1B, day  : 1B at 2B }

type Entry =
  { id   : U32
  , size : U32  -- size of the entire Entry
  , data : Data
  } layout record { id : 4B, size : 4B at 4B, data : LData at 8B }

-- An abstract type for naked character pointers.
type CString

-- user defined accessors; the Cogent getter/setters should not be used.
get_Person_name : TPerson! -> CString!

-- Test for string equality
cstring_eq : (CString!, CString!) -> Bool

-- Here follows the general iteration scheme in Cogent.

-- Given the current item, we may generate the next item,
-- if any, and yield to the consumer. Otherwise, we are finished.
--
gen_next_item : #{ acc : BItem , obsv : (BTail!, CString!) } ->
  GeneratorResult () U32 () BItem
gen_next_item (r { acc = item , obsv = (tail, _) }) =
  next (item, tail)
  | None item -> (item, Stop ())
  | Some item -> (item, Yield ())

-- During consumption, we determine whether or not the current item is
-- the one we want to query. If so, we return its stuff. Otherwise, we
-- ask for the next item.
--
cons_next_item :
  #{ obj : (), acc : BItem, obsv : (BTail!, CString!) } ->
  ConsumerResult U32 () BItem
cons_next_item (r {acc = item , obsv = (_, needle) }) =
  let (res, _) = (
    let entry = read item
    and data = get_Entry_data entry
     in match_Data_Person[(), CString!, <Next | Stop | Return U32>]
          #{scr=data, acc=(), obsv=needle, hit=do_Person, miss=do_not_Person}) !item
   in (item, res)

do_Person : (TPerson!, (), CString!) -> (<Next | Stop | Return U32>, ())
do_Person (p, _, needle) =
  let s = get_Person_name p
  and r = cstring_eq (s, needle)
  and age = p.age
  in if r then (Return age, ())
          else (Next, ())

do_not_Person : (BoxedData_take_Person!, (), CString!) -> (<Next | Stop | Return U32>, ())
do_not_Person (v, _, _) = (Next, ())


type BoxedData
type BoxedData_take_Person

get_Entry_data : Entry! -> BoxedData!

match_Data_Person : all (acc, obsv :< DS, r :< E). 
 #{ scr  : BoxedData!
  , acc  : acc
  , obsv : obsv
  , hit  : (TPerson!, acc, obsv) -> (r, acc)
  , miss : (BoxedData_take_Person!, acc, obsv) -> (r, acc)
  } -> (r, acc)


-- Our main function for item and tail: we iterate using the FFI
-- function which repeatedly calls the consumer followed by the
-- generator until we have completed iteration of all items, or found
-- a matching entry.
--
get_name_age : #{obj : (BItem, BTail) , obsv : CString! } ->
             (<None | Some U32>, BItem, BTail)
get_name_age #{obj = (item, tail) , obsv = needle } =
  let (item, ret) =
     iterate_do [(), U32, (), BItem, (BTail!, CString!)]
                #{ init = ()
                 , gen = gen_next_item
                 , cons = cons_next_item
                 , acc = item
                 , obsv = (tail, needle) } !tail
  and res =
    ret
    | Stop () -> None
    | Return x -> Some x
  in (res, item, tail)

-- Main entry function for the Cogent code.
--
findAgeByName : (Vector, CString!) -> (Vector, <None | Some U32>)
findAgeByName (block, needle) =
  let (res, block) = focus_buffer(block, needle, get_name_age)
  in (block, res)
