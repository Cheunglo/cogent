(*
This file is generated by Cogent

*)

theory Generated_Shallow_Normal
imports "Generated_ShallowShared"
begin

definition
  expstop :: "(32 word, 32 word) StepParam \<Rightarrow> bool"
where
  "expstop ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. False)"

definition
  log2stop :: "((64 word, 64 word) T0, 64 word) StepParam \<Rightarrow> bool"
where
  "log2stop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t acc T0.p1\<^sub>f) (\<lambda>(a,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T0.p2\<^sub>f) (\<lambda>(b,ds\<^sub>4). (>=) a obsv))))"

definition
  searchStop :: "((32 word, 32 word) T0, (32 word WordArray, 32 word) T0) StepParam \<Rightarrow> bool"
where
  "searchStop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t acc T0.p1\<^sub>f) (\<lambda>(l,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T0.p2\<^sub>f) (\<lambda>(r,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obsv T0.p1\<^sub>f) (\<lambda>(arr,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 T0.p2\<^sub>f) (\<lambda>(v,ds\<^sub>6). HOL.Let ((wordarray_length :: 32 word WordArray \<Rightarrow> 32 word) arr) (\<lambda>len. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>1\<^sub>5. HOL.Let (WordArrayGetP.make arr l an\<^sub>1\<^sub>5) (\<lambda>args. HOL.Let ((wordarray_get :: (32 word WordArray, 32 word, 32 word) WordArrayGetP \<Rightarrow> 32 word) args) (\<lambda>x. HOL.Let ((>=) l r) (\<lambda>an\<^sub>1\<^sub>7. HOL.If an\<^sub>1\<^sub>7 True (HOL.Let ((<) l len) (\<lambda>an\<^sub>2\<^sub>1. HOL.Let ((=) x v) (\<lambda>an\<^sub>2\<^sub>4. HOL.Let (an\<^sub>2\<^sub>1 \<and> an\<^sub>2\<^sub>4) (\<lambda>an\<^sub>2\<^sub>0. HOL.If an\<^sub>2\<^sub>0 True False)))))))))))))))"

definition
  expstep :: "(32 word, 32 word) StepParam \<Rightarrow> 32 word"
where
  "expstep ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). (*) acc obsv))"

definition
  log2step :: "((64 word, 64 word) T0, 64 word) StepParam \<Rightarrow> (64 word, 64 word) T0"
where
  "log2step ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t acc T0.p1\<^sub>f) (\<lambda>(a,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T0.p2\<^sub>f) (\<lambda>(b,ds\<^sub>4). HOL.Let (2 :: 64 word) (\<lambda>an\<^sub>3\<^sub>7. HOL.Let ((*) a an\<^sub>3\<^sub>7) (\<lambda>an\<^sub>3\<^sub>5. HOL.Let (1 :: 64 word) (\<lambda>an\<^sub>4\<^sub>0. HOL.Let ((+) b an\<^sub>4\<^sub>0) (\<lambda>an\<^sub>3\<^sub>8. T0.make an\<^sub>3\<^sub>5 an\<^sub>3\<^sub>8))))))))"

definition
  searchNext :: "((32 word, 32 word) T0, (32 word WordArray, 32 word) T0) StepParam \<Rightarrow> (32 word, 32 word) T0"
where
  "searchNext ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t acc T0.p1\<^sub>f) (\<lambda>(l,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T0.p2\<^sub>f) (\<lambda>(r,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obsv T0.p1\<^sub>f) (\<lambda>(arr,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 T0.p2\<^sub>f) (\<lambda>(v,ds\<^sub>6). HOL.Let ((-) r l) (\<lambda>an\<^sub>4\<^sub>9. HOL.Let (2 :: 32 word) (\<lambda>an\<^sub>5\<^sub>2. HOL.Let (checked_div an\<^sub>4\<^sub>9 an\<^sub>5\<^sub>2) (\<lambda>an\<^sub>4\<^sub>8. HOL.Let ((+) l an\<^sub>4\<^sub>8) (\<lambda>m. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>5\<^sub>5. HOL.Let (WordArrayGetP.make arr m an\<^sub>5\<^sub>5) (\<lambda>args. HOL.Let ((wordarray_get :: (32 word WordArray, 32 word, 32 word) WordArrayGetP \<Rightarrow> 32 word) args) (\<lambda>x. HOL.Let ((<) x v) (\<lambda>an\<^sub>5\<^sub>7. HOL.If an\<^sub>5\<^sub>7 (HOL.Let (1 :: 32 word) (\<lambda>an\<^sub>6\<^sub>2. HOL.Let ((+) m an\<^sub>6\<^sub>2) (\<lambda>an\<^sub>6\<^sub>0. T0.make an\<^sub>6\<^sub>0 r))) (HOL.Let ((>) x v) (\<lambda>an\<^sub>6\<^sub>4. HOL.If an\<^sub>6\<^sub>4 (T0.make l m) (T0.make m r)))))))))))))))))"

definition
  myexp :: "(32 word, 32 word) T0 \<Rightarrow> 32 word"
where
  "myexp ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 T0.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 T0.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let (ucast b :: 64 word) (\<lambda>an\<^sub>7\<^sub>3. HOL.Let expstop (\<lambda>an\<^sub>7\<^sub>5. HOL.Let expstep (\<lambda>an\<^sub>7\<^sub>6. HOL.Let (1 :: 32 word) (\<lambda>an\<^sub>7\<^sub>7. HOL.Let (RepParam.make an\<^sub>7\<^sub>3 an\<^sub>7\<^sub>5 an\<^sub>7\<^sub>6 an\<^sub>7\<^sub>7 a) (\<lambda>args. (repeat :: (64 word, (32 word, 32 word) StepParam \<Rightarrow> bool, (32 word, 32 word) StepParam \<Rightarrow> 32 word, 32 word, 32 word) RepParam \<Rightarrow> 32 word) args)))))))"

definition
  mylog2 :: "64 word \<Rightarrow> 64 word"
where
  "mylog2 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>n. HOL.Let log2stop (\<lambda>an\<^sub>8\<^sub>1. HOL.Let log2step (\<lambda>an\<^sub>8\<^sub>2. HOL.Let (1 :: 64 word) (\<lambda>an\<^sub>8\<^sub>4. HOL.Let (0 :: 64 word) (\<lambda>an\<^sub>8\<^sub>5. HOL.Let (T0.make an\<^sub>8\<^sub>4 an\<^sub>8\<^sub>5) (\<lambda>an\<^sub>8\<^sub>3. HOL.Let (RepParam.make n an\<^sub>8\<^sub>1 an\<^sub>8\<^sub>2 an\<^sub>8\<^sub>3 n) (\<lambda>args. HOL.Let ((repeat :: (64 word, ((64 word, 64 word) T0, 64 word) StepParam \<Rightarrow> bool, ((64 word, 64 word) T0, 64 word) StepParam \<Rightarrow> (64 word, 64 word) T0, (64 word, 64 word) T0, 64 word) RepParam \<Rightarrow> (64 word, 64 word) T0) args) (\<lambda>an\<^sub>8\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t an\<^sub>8\<^sub>7 T0.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 T0.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). b))))))))))"

end
