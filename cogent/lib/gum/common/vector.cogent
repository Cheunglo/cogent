type Vector

type VectorHeader
type VectorUsed
type VectorFree

type FocusVectorFArg a b = #{hd : VectorHeader, uvec : VectorUsed, fvec : VectorFree, acc : a, obsv : b}
type FocusVectorFRet r   = #{hd : VectorHeader, uvec : VectorUsed, fvec : VectorFree, res : r}

type FocusVectorRoFArg a b = #{hd : VectorHeader!, uvec : VectorUsed!, fvec : VectorFree!, acc : a, obsv : b}
type FocusVectorRoFRet r   = #{hd : VectorHeader!, uvec : VectorUsed!, fvec : VectorFree!, res : r}

-- The second argument is the size of the flexible field.
new_vector : (SysState, U32) -> R (SysState, Vector) SysState
free_vector : (SysState, Vector) -> SysState

size_vector : VectorHeader! -> U32
size_header : () -> U32
size_entry : Entry! -> U32

vector_header : Vector! -> VectorHeader!

focus_vector : all (a :< E, b :< DS, r :< E).
               #{ vec : Vector
                , acc : a
                , obsv : b
                , f : FocusVectorFArg a b -> FocusVectorFRet r
                } -> (r, Vector)

focus_vector_ro : all (a :< E, b :< DS, r :< E).
                  #{ vec : Vector!
                   , acc : a
                   , obsv : b
                   , f : FocusVectorRoFArg a b -> FocusVectorRoFRet r
                   } -> r

vector_next : (VectorUsed, VectorFree!) -> <This VectorUsed | Next VectorUsed>
vector_next_ro : (VectorUsed!, VectorFree!) -> <NoMore | Next (VectorUsed!)>

vector_read : VectorUsed! -> Entry!

vector_append : #{uvec : VectorUsed, fvec : VectorFree, obj : Entry!}
             -> #{suc : Bool, uvec : VectorUsed, fvec : VectorFree}

