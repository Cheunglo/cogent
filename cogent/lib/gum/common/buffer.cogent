--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

-- The current trend of thoughts seems to indicate that
-- Buffers should not be an ADT but instead they shold be
-- implmemented in COGENT using the WordArray U8 ADT.
-- ADT or not Buffers interface should comply with these prototypes:


-- BufOffs is used to specify the offset within a Buffer
-- Should be used by functions that manipulate Buffers including
-- serialisation ones.
type BufOffs = U32

type BufferData

type Buffer = {
    bound : BufOffs,
 -- @bound is used to virtually resize the buffer when
 -- using serialisation functions. It allows allocating
 -- one large buffer that can be reused across FS operation
 -- for instance. It counts from the beginning of @data
    data : BufferData
}
{-
    wellformed_buf: wordarray_length buf.data >= buf.bound
-}

{-# cinline newBuffer #-}
newBuffer : SysState -> R (SysState, Buffer take (..)) SysState

{-# cinline freeBuffer #-}
freeBuffer : (SysState, Buffer take (..)) -> SysState

{-# CINLINE newBufferData #-}
newBufferData : SysState -> RR SysState BufferData ()

{-# CINLINE freeBufferData #-}
freeBufferData : (SysState, BufferData) -> SysState

buffer_create : (SysState, U32) -> R (SysState, Buffer) SysState
buffer_create (s, size) =
  let Success (s, buf) <= newBuffer s
      |> Error s -> Error s
  and (s, r) = newBufferData s
  and Success osbuf <= r
      |> Error () -> Error (freeBuffer (s, buf))
  in Success (s, buf {bound = size, data = osbuf})

buffer_free : (SysState, Buffer) -> SysState
buffer_free (s, buf) =
  let buf {data = osbuf} = buf
  and s = freeBufferData (s, osbuf)
  in freeBuffer (s, buf)

{-# cinline buf_memset #-}
buf_memset: (Buffer, U32, U32, U8) -> Buffer

-- if the offset is out-of-bounds, return 0
buf_get : (Buffer!, BufOffs) -> U8

buf_set : (Buffer, BufOffs, U8) -> Buffer
