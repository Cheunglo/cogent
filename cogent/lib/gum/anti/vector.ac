
$ty:((r, Vector))
$id:focus_vector ($ty:(#{ vec : Vector
                        , acc : a
                        , obsv : b
                        , f : FocusVectorFArg a b -> FocusVectorFRet r
                        }) args)
{
    $ty:((r, Vector)) ret;
    
    $ty:(FocusVectorFArg a b) farg;
    farg.hd = vector_header (args.vec);
    farg.uvec = (char*) args.vec + $exp:vector_header_size;
    farg.fvec = (char*) args.vec + vector_size (farg.hd);
    farg.acc = args.acc;
    farg.obsv = args.obsv;

    $ty:(FocusVectorFRet r) fret;

    bilbyfs_debug ("focus_vector: header=%p, uvec=%p, fvec=%p, size=%u\n",
                   farg.hd, farg.uvec, farg.fvec, vector_size (farg.hd));

    fret = (($spec:(FocusVectorFArg a b -> FocusVectorFRet r)) args.f) (farg);

    bilbyfs_debug ("post:focus_vector: header=%p, uvec=%p, fvec=%p, size=%u\n",
                   fret.hd, fret.uvec, fret.fvec, vector_size (fret.hd));

    ret.p1 = fret.res;
    ret.p2 = args.vec;
    return ret;
}

$ty:r
$id:focus_vector_ro ($ty:(#{ vec : Vector
                           , acc : a
                           , obsv : b
                           , f : FocusVectorRoFArg a b -> FocusVectorRoFRet r
                           }) args)
{
    $ty:(FocusVectorRoFArg a b) farg;
    farg.hd = vector_header (args.vec);
    farg.uvec = (char*) args.vec + $exp:vector_header_size;
    farg.fvec = farg.uvec + vector_size (farg.hd);
    farg.acc = args.acc;
    farg.obsv = args.obsv;

    $ty:(FocusVectorRoFRet r) fret;

    bilbyfs_debug ("focus_vector_ro: header=%p, uvec=%p, fvec=%p, size=%u\n",
                   farg.hd, farg.uvec, farg.fvec, vector_size (farg.hd));

    fret = (($spec:(FocusVectorRoFArg a b -> FocusVectorRoFRet r)) args.f) (farg);

    bilbyfs_debug ("post:focus_vector_ro: header=%p, uvec=%p, fvec=%p, size=%u\n",
                   fret.hd, fret.uvec, fret.fvec, vector_size (fret.hd));

    return fret.res;
}

$ty:(<This VectorUsed | Next VectorUsed>)
vector_next ($ty:((VectorUsed, VectorFree!)) args)
{
    $ty:(<This VectorUsed | Next VectorUsed>) ret;
    
    void* uvec = args.p1;
    void* fvec = args.p2;
    $ty:(Entry) next;

    next = uvec + vector_entry_size (vector_read (uvec));
    if (next == fvec) {
        ret.tag = TAG_ENUM_This;
        ret.This = uvec;
    } else {
        ret.tag = TAG_ENUM_Next;
        ret.Next = uvec;
    }
    return ret;
}

$ty:(<NoMore | Next (VectorUsed!)>)
vector_next_ro ($ty:((VectorUsed!, VectorFree!)) args)
{
    $ty:(<NoMore | Next (VectorUsed!)>) ret;
    void* uvec = args.p1;
    void* fvec = args.p2;
    $ty:(Entry) next;

    next = uvec + vector_entry_size (vector_read (uvec));
    if (next == fvec) {
        ret.tag = TAG_ENUM_NoMore;
        ret.NoMore = $exp:(());
    } else {
        ret.tag = TAG_ENUM_Next;
        ret.Next = uvec;
    }
    return ret;
}

$ty:(Entry!) vector_read ($ty:(VectorUsed!) args)
{
    return (($ty:(Entry!))args);
}

$ty:(#{suc : Bool, uvec : VectorUsed, fvec : VectorFree})
vector_append ($ty:(#{hd : VectorHeader!, uvec : VectorUsed, fvec : VectorFree, obj : Entry!}) args)
{
    $ty:(#{suc : Bool, uvec : VectorUsed, fvec : VectorFree}) ret;

    void* fvec = args.fvec;
    $ty:(U32) nb_entries = vector_nb_entries (args.hd);
    $ty:(U32) size = vector_entry_size (args.obj);

    if (nb_entries >= $exp:vector_max_nb_entries) {
        // no more space available.
        bilbyfs_debug ("vector_append: no more space\n");
        ret.suc = $exp:(False);
        ret.uvec = args.uvec;
        ret.fvec = args.fvec;
        return ret;
    }


    bilbyfs_debug ("vector_append: memcpy(%p, %p, %u)\n",
                   fvec, (void*) args.obj, size);
    memcpy (fvec, (void*) args.obj, size);

    ret.suc = $exp:(True);
    ret.uvec = args.uvec;
    ret.fvec = fvec + size;

    return ret;
}

