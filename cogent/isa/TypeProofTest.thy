(*
 * Copyright 2016, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(NICTA_GPL)
 *)

theory TypeProofTest
imports "COGENTHelper" "ProofTrace"
begin

definition
  "foo_type \<equiv> Pair Nil (Pair (TRecord (Cons (Pair (TCon ''A'' Nil Writable) False) (Cons (Pair (TCon ''B'' Nil Writable) False) Nil)) Writable) (TRecord (Cons (Pair (TCon ''A'' Nil Writable) False) (Cons (Pair (TCon ''B'' Nil Writable) False) Nil)) Writable))"

definition
  "foo \<equiv> Let (Var 0) (Take (Var 0) 0 (Put (Var 1) 0 (Var 0)))"

definition
  "\<Xi> func_name' \<equiv> case func_name' of ''foo'' \<Rightarrow> foo_type"

lemma 
  "\<Xi>, fst foo_type, [Some (fst (snd foo_type))] \<turnstile> foo : snd (snd foo_type)"
  (* proof script generated by COGENT compiler *)
  apply (simp add: foo_type_def foo_def)
  apply (rule typing_let)
  apply (rule split_cons)
  apply (rule split_comp.left)
  apply (tactic {* rtac @{thm kind_trec[where k="{E}"]} 1 *})
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_empty)
  apply simp
  apply (rule split_empty)
  apply (rule typing_var)
  apply (simp add: weakening_def empty_def del: HOL.simp_thms(25) HOL.simp_thms(26))
  apply (rule keep)
  apply (rule_tac k="{E}" in kind_trec)
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_empty)
  apply simp
  apply simp
  apply (rule typing_take)
  apply (rule split_cons)
  apply (rule split_comp.left)
  apply (rule_tac k="{E}" in kind_trec)
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_empty)
  apply simp
  apply (rule split_cons)
  apply (rule split_comp.none)
  apply (rule split_empty)
  apply (rule typing_var)
  apply (simp add: weakening_def empty_def del: HOL.simp_thms(25) HOL.simp_thms(26))
  apply (rule conjI)
  apply (rule keep)
  apply (rule_tac k="{E}" in kind_trec)
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_empty)
  apply simp
  apply (rule none)
  apply simp
  apply simp
  apply simp
  apply simp
  apply (rule_tac k="{E}" in kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule_tac Q=True in disjI2)
  apply simp
  apply simp
  apply (rule typing_put_better)
  apply (rule split_cons)
  apply (rule split_comp.right)
  apply (rule_tac k="{E}" in kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule split_cons)
  apply (rule split_comp.left)
  apply (rule_tac k="{E}" in kind_trec)
  apply (rule kind_record_cons2)
  apply (rule_tac k="{E}" in kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_empty)
  apply simp
  apply (rule split_cons)
  apply (rule split_comp.none)
  apply (rule split_cons)
  apply (rule split_comp.none)
  apply (rule split_empty)
  apply (rule typing_var)
  apply (simp add: weakening_def empty_def del: HOL.simp_thms(25) HOL.simp_thms(26))
  apply (rule conjI)
  apply (rule none)
  apply (rule conjI)
  apply (rule keep)
  apply (rule_tac k="{E}" in kind_trec)
  apply (rule kind_record_cons2)
  apply (rule_tac k="{E}" in kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_cons1)
  apply (rule kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule kind_record_empty)
  apply simp
  apply (rule conjI)
  apply (rule none)
  apply (rule none)
  apply simp
  apply simp
  apply simp
  apply simp
  apply (rule_tac k="{E}" in kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule_tac Q=True in disjI2)
  apply simp
  apply (rule typing_var)
  apply (simp add: weakening_def empty_def del: HOL.simp_thms(25) HOL.simp_thms(26))
  apply (rule conjI)
  apply (rule keep)
  apply (rule_tac k="{E}" in kind_tcon)
  apply (rule kind_all_empty)
  apply simp
  apply (rule conjI)
  apply (rule none)
  apply (rule conjI)
  apply (rule none)
  apply (rule none)
  apply simp
  apply simp
  done



(* reflected proof script (pass through ParseTypeProof.hs) *)
ML {*
fun tacs ctxt =
[
("asm_full_simp_tac (ctxt addsimps [@{thm \"foo_type_def\"}, @{thm \"foo_def\"}])", asm_full_simp_tac (ctxt addsimps [@{thm "foo_type_def"}, @{thm "foo_def"}]) 1),
("rtac @{thm \"typing_let\"}", rtac @{thm "typing_let"} 1),
("rtac @{thm \"split_cons\"}", rtac @{thm "split_cons"} 1),
("rtac @{thm \"split_comp.left\"}", rtac @{thm "split_comp.left"} 1),
("rtac @{thm \"kind_trec\"[where k = \"{E}\"]}", rtac @{thm "kind_trec"[where k = "{E}"]} 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_empty\"}", rtac @{thm "kind_record_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"split_empty\"}", rtac @{thm "split_empty"} 1),
("rtac @{thm \"typing_var\"}", rtac @{thm "typing_var"} 1),
("asm_full_simp_tac ((ctxt delsimps [(nth @{thms \"HOL.simp_thms\"} (25-1)), (nth @{thms \"HOL.simp_thms\"} (26-1))]) addsimps [@{thm \"weakening_def\"}, @{thm \"empty_def\"}])", asm_full_simp_tac ((ctxt delsimps [(nth @{thms "HOL.simp_thms"} (25-1)), (nth @{thms "HOL.simp_thms"} (26-1))]) addsimps [@{thm "weakening_def"}, @{thm "empty_def"}]) 1),
("rtac @{thm \"keep\"}", rtac @{thm "keep"} 1),
("rtac @{thm \"kind_trec\"[where k = \"{E}\"]}", rtac @{thm "kind_trec"[where k = "{E}"]} 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_empty\"}", rtac @{thm "kind_record_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"typing_take\"}", rtac @{thm "typing_take"} 1),
("rtac @{thm \"split_cons\"}", rtac @{thm "split_cons"} 1),
("rtac @{thm \"split_comp.left\"}", rtac @{thm "split_comp.left"} 1),
("rtac @{thm \"kind_trec\"[where k = \"{E}\"]}", rtac @{thm "kind_trec"[where k = "{E}"]} 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_empty\"}", rtac @{thm "kind_record_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"split_cons\"}", rtac @{thm "split_cons"} 1),
("rtac @{thm \"split_comp.none\"}", rtac @{thm "split_comp.none"} 1),
("rtac @{thm \"split_empty\"}", rtac @{thm "split_empty"} 1),
("rtac @{thm \"typing_var\"}", rtac @{thm "typing_var"} 1),
("asm_full_simp_tac ((ctxt delsimps [(nth @{thms \"HOL.simp_thms\"} (25-1)), (nth @{thms \"HOL.simp_thms\"} (26-1))]) addsimps [@{thm \"weakening_def\"}, @{thm \"empty_def\"}])", asm_full_simp_tac ((ctxt delsimps [(nth @{thms "HOL.simp_thms"} (25-1)), (nth @{thms "HOL.simp_thms"} (26-1))]) addsimps [@{thm "weakening_def"}, @{thm "empty_def"}]) 1),
("rtac @{thm \"conjI\"}", rtac @{thm "conjI"} 1),
("rtac @{thm \"keep\"}", rtac @{thm "keep"} 1),
("rtac @{thm \"kind_trec\"[where k = \"{E}\"]}", rtac @{thm "kind_trec"[where k = "{E}"]} 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_empty\"}", rtac @{thm "kind_record_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"none\"}", rtac @{thm "none"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_tcon\"[where k = \"{E}\"]}", rtac @{thm "kind_tcon"[where k = "{E}"]} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"disjI2\"[where Q = \"True\"]}", rtac @{thm "disjI2"[where Q = "True"]} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"typing_put_better\"}", rtac @{thm "typing_put_better"} 1),
("rtac @{thm \"split_cons\"}", rtac @{thm "split_cons"} 1),
("rtac @{thm \"split_comp.right\"}", rtac @{thm "split_comp.right"} 1),
("rtac @{thm \"kind_tcon\"[where k = \"{E}\"]}", rtac @{thm "kind_tcon"[where k = "{E}"]} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"split_cons\"}", rtac @{thm "split_cons"} 1),
("rtac @{thm \"split_comp.left\"}", rtac @{thm "split_comp.left"} 1),
("rtac @{thm \"kind_trec\"[where k = \"{E}\"]}", rtac @{thm "kind_trec"[where k = "{E}"]} 1),
("rtac @{thm \"kind_record_cons2\"}", rtac @{thm "kind_record_cons2"} 1),
("rtac @{thm \"kind_tcon\"[where k = \"{E}\"]}", rtac @{thm "kind_tcon"[where k = "{E}"]} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_empty\"}", rtac @{thm "kind_record_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"split_cons\"}", rtac @{thm "split_cons"} 1),
("rtac @{thm \"split_comp.none\"}", rtac @{thm "split_comp.none"} 1),
("rtac @{thm \"split_cons\"}", rtac @{thm "split_cons"} 1),
("rtac @{thm \"split_comp.none\"}", rtac @{thm "split_comp.none"} 1),
("rtac @{thm \"split_empty\"}", rtac @{thm "split_empty"} 1),
("rtac @{thm \"typing_var\"}", rtac @{thm "typing_var"} 1),
("asm_full_simp_tac ((ctxt delsimps [(nth @{thms \"HOL.simp_thms\"} (25-1)), (nth @{thms \"HOL.simp_thms\"} (26-1))]) addsimps [@{thm \"weakening_def\"}, @{thm \"empty_def\"}])", asm_full_simp_tac ((ctxt delsimps [(nth @{thms "HOL.simp_thms"} (25-1)), (nth @{thms "HOL.simp_thms"} (26-1))]) addsimps [@{thm "weakening_def"}, @{thm "empty_def"}]) 1),
("rtac @{thm \"conjI\"}", rtac @{thm "conjI"} 1),
("rtac @{thm \"none\"}", rtac @{thm "none"} 1),
("rtac @{thm \"conjI\"}", rtac @{thm "conjI"} 1),
("rtac @{thm \"keep\"}", rtac @{thm "keep"} 1),
("rtac @{thm \"kind_trec\"[where k = \"{E}\"]}", rtac @{thm "kind_trec"[where k = "{E}"]} 1),
("rtac @{thm \"kind_record_cons2\"}", rtac @{thm "kind_record_cons2"} 1),
("rtac @{thm \"kind_tcon\"[where k = \"{E}\"]}", rtac @{thm "kind_tcon"[where k = "{E}"]} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_cons1\"}", rtac @{thm "kind_record_cons1"} 1),
("rtac @{thm \"kind_tcon\"}", rtac @{thm "kind_tcon"} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_record_empty\"}", rtac @{thm "kind_record_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"conjI\"}", rtac @{thm "conjI"} 1),
("rtac @{thm \"none\"}", rtac @{thm "none"} 1),
("rtac @{thm \"none\"}", rtac @{thm "none"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"kind_tcon\"[where k = \"{E}\"]}", rtac @{thm "kind_tcon"[where k = "{E}"]} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"disjI2\"[where Q = \"True\"]}", rtac @{thm "disjI2"[where Q = "True"]} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"typing_var\"}", rtac @{thm "typing_var"} 1),
("asm_full_simp_tac ((ctxt delsimps [(nth @{thms \"HOL.simp_thms\"} (25-1)), (nth @{thms \"HOL.simp_thms\"} (26-1))]) addsimps [@{thm \"weakening_def\"}, @{thm \"empty_def\"}])", asm_full_simp_tac ((ctxt delsimps [(nth @{thms "HOL.simp_thms"} (25-1)), (nth @{thms "HOL.simp_thms"} (26-1))]) addsimps [@{thm "weakening_def"}, @{thm "empty_def"}]) 1),
("rtac @{thm \"conjI\"}", rtac @{thm "conjI"} 1),
("rtac @{thm \"keep\"}", rtac @{thm "keep"} 1),
("rtac @{thm \"kind_tcon\"[where k = \"{E}\"]}", rtac @{thm "kind_tcon"[where k = "{E}"]} 1),
("rtac @{thm \"kind_all_empty\"}", rtac @{thm "kind_all_empty"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("rtac @{thm \"conjI\"}", rtac @{thm "conjI"} 1),
("rtac @{thm \"none\"}", rtac @{thm "none"} 1),
("rtac @{thm \"conjI\"}", rtac @{thm "conjI"} 1),
("rtac @{thm \"none\"}", rtac @{thm "none"} 1),
("rtac @{thm \"none\"}", rtac @{thm "none"} 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1),
("asm_full_simp_tac ctxt", asm_full_simp_tac ctxt 1)
]

*}


(* trace the proof tree *)

declare [[ML_print_depth=99]]
ML {*
fun is_typing t = head_of t |> (fn h => is_const "COGENT.typing" h orelse is_const "COGENT.split" h);
extract_subproofs @{cterm "Trueprop (\<Xi>, fst foo_type, [Some (fst (snd foo_type))] \<turnstile> foo : snd (snd foo_type))"}
  (tacs @{context}) is_typing @{context}
*}

end