%
% Copyright 2016, NICTA
%
% This software may be distributed and modified according to the terms of
% the GNU General Public License version 2. Note that NO WARRANTY is provided.
% See "LICENSE_GPLv2.txt" for details.
%
% @TAG(NICTA_GPL)
%

\documentclass[a4paper]{article}
\usepackage[margin=2cm]{geometry}
\usepackage[bookmarks]{hyperref}
\usepackage[australian]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{url}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{tabularx}


% math packages
\usepackage{mathpartir} %inference rules
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{mathtools} %extensible arrows
\usepackage{alltt}
\usepackage{color}
\usepackage{tikz}

\usepackage{float}
\usepackage{util}
\usepackage{utilc}
\usepackage{comment}

\usepackage{listings}

\definecolor{commentcol}{rgb}{0.3,0.3,0.3}
\definecolor{keywordcol}{rgb}{0,0,0.4}
\definecolor{typecol}{rgb}{0.4,0.1,0}
\definecolor{funccol}{rgb}{0.1,0.4,0}
\definecolor{anticol}{rgb}{0.1,0.4,0.4}
\definecolor{light-gray}{gray}{0.90}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{keywordcol}\tt\bf\ttfamily,
  commentstyle=\color{commentcol}\tt,
  numberstyle=\tiny\color{commentcol},
  numbers=left,
  numbersep=0.5cm,
  xleftmargin=1cm,
  breaklines=true,
  showstringspaces=false,
}

\lstdefinelanguage{Cogent}{
  basicstyle=\ttfamily\small,
  sensitive=true,
  morecomment=[l]{--},
  morecomment=[s]{\{-}{-\}},
  morekeywords={type, let, in, and, if, then, else, take, put, inline, \#, !},
  emph={[1]U8,U16,U32,U64,Bool,String},
  emphstyle={[1]\color{typecol}},
}

\lstdefinelanguage{antiC}{
  language=C,
  morekeywords={$ty, $exp, $id, $spec},
  emph={[2]size_t,uint8_t,uint16_t,uint32_t,uint64_t},
  emphstyle={[2]\color{typecol}},
}

\newcommand{\inlinecogent}[1]{\lstinline[language=Cogent,basicstyle=\ttfamily\normalsize]{#1}\xspace}
\newcommand{\inlinec}[1]{\lstinline[language=antiC,basicstyle=\ttfamily\normalsize]{#1}\xspace}
\newcommand{\inlinehs}[1]{\lstinline[language=haskell,basicstyle=\ttfamily\normalsize]{#1}\xspace}

\allowdisplaybreaks

\newcommand{\TODO}[1]{\textbf{\textsl{\colorbox{yellow}{TODO:} #1}}}
\newcommand{\todo}[1]{\TODO{#1}}
\newcommand{\FIXME}[1]{\textbf{\textsl{\colorbox{yellow}{FIXME:} #1}}}
\newcommand{\fixme}[1]{\FIXME{#1}}

\newcommand{\cogent}{\textsc{Cogent}\xspace}
\newcommand{\Cogent}{\cogent}
\newcommand{\dargent}{\textsc{Dargent}\xspace}
\newcommand{\Dargent}{\dargent}
\newcommand{\isa}{Isabelle/HOL\xspace}



\begin{document}

\title{\cogent Language Report}
\author{Zilin Chen}
\date{\today}

\maketitle

\section{Surface Syntax}

\subsection{Grammar} \label{ssec:grammar}
Note: The syntax of \cogent is not restricted to regular expression, thus the following EBNF definition is incomplete and is
not strictly formal. In particular, indentation rules are specified in a semi-formal manner. Superscript \col{c} means
the associated construct starts at column $c$.

\todo{update me!}

{
\small
\begin{grammar}
  \text{variable / field}           & v            & ::= & [\code{a-z}][\code{A-Za-z0-9'\_}]^*\ |\ \code{\_}[\code{A-Za-z0-9'\_}]^+ \\
  \text{type constructor / tag}      & T            & ::= & [\code{A-Z}][\code{A-Za-z0-9'\_}]^* \\
  \text{binding}                    & b            & ::= & p_i\ (\code{:}\ \tau)^?\ \code{=}\ e\ (\code{!} v)^* \\
  \text{record matching}            & r_m              & ::= & v\ (\code{=}\ p_i)^? \\
  \text{strict record matchings}    & \overline{r_m}^! & ::= & r_m (\code{,}\ r_m)^* \\
  \text{record matchings}           & \overline{r_m}   & ::= & (\overline{r_m}^! \code{,})^?\ \code{..} \\
  \text{record assignment}          & r_a              & ::= & v\ (\code{=}\ e^{\col{1}})^? \\
  \text{strict record assignments}  & \overline{r_a}^! & ::= & r_a (\code{,}\ r_a)^* \\
  \text{record assignments}         & \overline{r_a}   & ::= & (\overline{r_a}^! \code{,})^?\ \code{..} \\
  \text{irrefutable pattern}        & p_i          & ::= & v\ (\code{\{} \overline{r} \code{\}})^? \\
                                    &              & |   & \code{(} (p_i (\code{,}\ p_i)^*)^? \code{)} \\
                                    &              & |   & \code{\#} \code{\{} \overline{r} \code{\}} \\
                                    &              & |   & \code{\_} \\
  \text{pattern}                    & p            & ::= & \code{True}\ |\ \code{False} \\
                                    &              & |   & T\ p_i\ |\ p_i \\
                                    &              & |   & integer\ |\ \code{'} char \code{'} \\
  \text{term}                       & \varepsilon  & ::= & (\code{inline})^?\ v\ (\code{[} \tau (\code{,}\ \tau)^*\code{]})^? \\
                                    &              & |   & \code{True}\ |\ \code{False} \\
                                    &              & |   & integer \\
                                    &              & |   & \code{'} char \code{'} \\
                                    &              & |   & \code{''} string \code{''} \\
                                    &              & |   & T\ \varepsilon \\
                                    &              & |   & \code{(} (e^{\col{1}} (\code{,}\ e^{\col{1}})^*)^? \code{)} \\
                                    &              & |   & \code{\#} \code{\{} \overline{r}^! \code{\}} \\
  \text{basic expression}           & {e_b}^{\col{c}}  & ::= & e_b'\ |\ e_b' \code{;}\ e^{\col{c}}\\
                                    & e_b'         &     & \hspace{-2em} \cmt{\textit{operator precedence descending}} \\
                                    &              & ::= &\varepsilon \code{.} v \\
                                    &              & |   & (\code{complement} | \code{not})\ \varepsilon \\
                                    &              & |   & \varepsilon\ \varepsilon \\
                                    &              & |   & \varepsilon\ \code{\{} \overline{r}  \code{\}} \\
                                    &              & |   & \varepsilon\ (\code{*} | \code{/} | \code{\%})\ \varepsilon \\
                                    &              & |   & \varepsilon\ (\code{+} | \code{-})\ \varepsilon \\
                                    &              & |   & \varepsilon\ (\code{>=} | \code{>} | \code{==} | \code{/=} | \code{<} | \code{<=})\ \varepsilon \\
                                    &              & |   & \varepsilon\ \code{.\&.}\ \varepsilon \cmt{\textit{bitwise-and}} \\
                                    &              & |   & \varepsilon\ \code{.\^{}.}\ \varepsilon \cmt{\textit{bitwise-xor}} \\
                                    &              & |   & \varepsilon\ \code{.|.}\ \varepsilon \cmt{\textit{bitwise-or}} \\
                                    &              & |   & \varepsilon\ (\code{>}\code{>} | \code{<}\code{<})\ \varepsilon \\
                                    &              & |   & \varepsilon\ \code{\&\&}\ \varepsilon \\
                                    &              & |   & \varepsilon\ \code{||}\ \varepsilon \\
  \text{expression matching}         & m^{\col{c}}  & ::= & {e_b}^{\col{c}}\ ((\code{!} v)^*\ {a^{\col{>c}}}^+)^? \cmt{a^+\ \textit{are aligned}}\\
  \text{expression}                 & e^{\col{c}}  & ::= & \code{let}\ b\ (\code{and}\ b)^*\ \code{in}\ e^{\col{c}}\\
                                    &              & |   & \code{if}\ e^{\col{c}}\ (\code{!} v)^*\ \code{then}\ e^{\col{c}}\ \code{else}\ e^{\col{c}} \\
                                    &              & |   & m^{\col{c}} \\
  \text{kind}                       & \kappa       & ::= & [\code{D}|\code{S}|\code{E}]^+ \\
  \text{kind signature}             & s            & ::= & v\ (\code{:<}\ \kappa)^? \\
  \text{kind signatures}            & \overline{s} & ::= & s | \code{(} s (\code{,}\ s)^*\code{)} \\
  \text{alternative}                & a^{\col{c}}  & ::= & \code{|}\ p\ (\code{=>|->|\textasciitilde>})\ e^{\col{c}} \\
  \text{atomtype}                   & \tau_a       & ::= & \code{(} \tau (\code{,}\ \tau)^* \code{)} \\
                                    &              & |   & \code{\{} v\ \code{:}\ \tau (\code{,}\ v\ \code{:}\ \tau)^* \code{\}} \\
                                    &              & |   & \code{<} T\ \tau_{A2}\ (\code{|}\ T\ \tau_{A2})^* \code{>} \\
                                    &              & |   & v \\
                                    &              & |   & T \\
  \text{type A2}                    & \tau_{A2}    & ::= & \code{\#} \tau_a \\
                                    &              & |   & \tau_a \code{!}^? \\
  \text{type A1}                    & \tau_{A1}    & ::= & T\ \tau_{A2}^* \\
                                    &              & |   & \tau_{A2}\ ((\code{take}|\code{put})\ (v | \code{(} (v (\code{,}\ v)^* | \code{..}) \code{)}))^? \\
  \text{mono-type}                  & \tau         & ::= & \tau_{A1}\ (\code{->}\ \tau_{A1})^? \\
  \text{poly-type}                  & \sigma       & ::= & (\code{all}\ \overline{s} \code{.})^?\ \tau\\
  \text{function signature}         & f_{\sigma}   & ::= & v\ \code{:}\ \sigma \\
  \text{function definition}        & f            & ::= & v\ ({a^{\col{c}}}^+ | v\ \code{=}\ e^{\col{1}}) \cmt{a^+\ \textit{are aligned, } c \textit{ is the first column of } a^+} \\
  \text{type definition}            & t            & ::= & \code{type}\ T\ v^*\ (\code{=}\ \tau)^? \\
  \text{include}                    & i            & ::= & \code{include}\ \code{"} filepath \code{"} \\
  \text{program}                    & p            & ::= & {(f_{\sigma}|f_{\sigma}\ f|t|i)^{\col{0}}}^+
\end{grammar}
}

\subsection{Comments}
They are exactly the same as those of Haskell. Single-line comments start with \code{-}\code{-},
block comments are surrounded by \code{\{-} and \code{-\}}. Nested comments are allowed.

\subsection{Pragmas}

\cogent supports several pragmas, or instructions to the compiler placed in the source code.
Pragmas normally don't affect the meaning of the program, but they might affect the efficiency of the generated code.

Pragmas all take the form \code{\{-\# \textit{word ...} \#-\}} where \codeit{word} indicates the type of pragma,
and is optionally followed by information specific to that type of pragma. Case is ignored in \codeit{word}.
The various values for \codeit{word} that \cogent understands are described in \fixme{somewhere?}.
The layout rule does \emph{not} apply in pragmas.


\section{Abstract Syntax}

\todo{update me!}

{
\small
\begin{grammar}
  \text{irref. pattern} & irrp & ::= & pv \\
                        &      & |   & \stuple{\many{irrp_i}} \\
                        &      & |   & \surecord{\many{pfield_i}} \\
                        &      & |   & \sWILDCARD \\
                        &      & |   & \sunit \\
                        &      & |   & pv\ \srecord{\many{pfield_i}} \\
  \text{pattern field} & pfield & ::= & \sALLFIELDS \\
                       &        & |   & f = irrp \\
  \text{pattern} & pat & ::= & T\ \many{irrp_i} \\
                 &     & |   & n\\
                 &     & |   & b\\
                 &     & |   & c\\
                 &     & |   & irrp\\
  \text{alternative} & alt & ::= & \salt{pat}{e}\\
  \text{opt. ty. ann.} & \cdot^\tau & ::= & \cdot : \tau \\
                         &          & |   & \cdot \\
  \text{binding} & b & ::= & irrp^\tau = e\ \sBANG \many{v_j} \\
  \text{expression} & e & ::= & op\ \many{e_i} \\
                    &   & |   & v \\
                    &   & |   & \scaseof{e\ \sBANG \many{v_j}}{\many{alt_i}} \\
                    &   & |   & \styapp{v}{\many{\tau_i}} \\
                    &   & |   & \scon{T}{\many{e_i}} \\
                    &   & |   & \sseq{e}{e} \\
                    &   & |   & \sapp{e}{e} \\
                    &   & |   & \sifthel{e\ \sBANG \many{v_j}}{e}{e} \\
                    &   & |   & \smember{e}{f} \\
                    &   & |   & \sunit \\
                    &   & |   & \ell_n \\
                    &   & |   & \ell_b \\
                    &   & |   & \ell_c \\
                    &   & |   & \ell_s \\
                    &   & |   & \stuple{\many{e_i}} \\
                    &   & |   & \surecord{\many{f_i = e_i}} \\
                    &   & |   & \sletin{\many{b_i}}{e} \\
                    &   & |   & \sput{v}{\many{field_i}} \\
  \text{field} & field & ::= & \sALLFIELDS \\
               &       & |   & f = e \\
  \text{type} & \tau & ::= & \stynf{\tau} \\
              &      & |   & \sUNBOX \tau \\
              &      & |   & \tau \sBANG \\
              &      & |   & \stytake{\tau}{\many{f_i}} \\
              &      & |   & \stytake{\tau}{\sALLFIELDS} \\
              &      & |   & \styput{\tau}{\many{f_i}} \\
              &      & |   & \styput{\tau}{\sALLFIELDS} \\
  \text{nor. type} & \stynf{\tau} & ::= & \stycon{T}{\many{\tau_i}}{\varsigma} \\
                   &              & |   & t\sBANG\ |\ t \\
                   &              & |   & \styfun{\tau}{\tau} \\
                   &              & |   & \srecord{\many{f_i : {\tau_i}^?}} \\
                   &              & |   & \svariant{\many{T_i \mapsto \many{{\tau_i}_j}}} \\
                   &              & |   & \stuple{\many{\tau_i}} \\
  \text{poly-type} & \sigma & ::= & \many{t_i <: \kappa_i}\ \tau \\
  \text{top level} & top & ::= & \sINCLUDE\ s \\
                   &     & |   & T\ \many{t_i} = \tau \\
                   &     & |   & T\ \many{t_i} \\
                   &     & |   & v : \sigma \\
                   &     & |   & v : \sigma = \many{alt_i} \\
                   &     & |   & v : \tau = e
\end{grammar}
}

\section{Surface Type Inference}
\todo{It should become available soon.}

\section{Desugaring}

\todo{update me!}

Note: $::$ is meta-lang.
{
\small
\begin{inductive}{\desugar{\Gamma}{e}{e} \quad \text{(\HiCore{e} is core syntax. See \cite{greport})}}
\inferrule
  {\desugar{\Gamma}{op}{o} \\
   \text{for each $i$: }\desugar{\Gamma}{e_i}{e_i}}
  {\desugar{\Gamma}{\sapp{op}{\many{e_i}}}{\GenPrimOp{o}{\many{e}}}}
\\
\inferrule
  {v \in \Gamma}
  {\desugar{\Gamma}{v}{v}}
\quad
\inferrule
  {(v \mapsto e) \in \Gamma \\
   \desugar{\Gamma}{e}{e}}
  {\desugar{\Gamma}{v}{e}}
\\
\inferrule
  {\desugaralts{\Gamma}{\scaseof{e}{\many{alt_i}}}{e}}
  {\desugar{\Gamma}{\scaseof{e}{\many{alt_i}}}{e}}
\quad
\inferrule
  {\desugar{\Gamma}{e}{e} \\
   v\ \text{fresh} \\
   \desugaralts{\Gamma,v}{\scaseof{v :: \tau}{\many{alt_i}}}{e'}}
  {\desugar{\Gamma}{\scaseof{e :: \tau\ \sBANG \many{v_j}}{\many{alt_i}}}{\LetBang{\many{v_j}}{v}{e}{e'}}}
\\
\inferrule
  {\text{for each $i$: }\desugar{\Gamma}{\tau_i}{\tau_i}}
  {\desugar{\Gamma}{\styapp{v}{\many{\tau_i}}}{\TyApp{v}{\many{\tau_i}}}}
\\
\inferrule
  { }
  {\desugar{\Gamma}{\scon{T}{}}{\Cons{T}{}}}
\quad
\inferrule
  {\desugar{\Gamma}{e}{e}}
  {\desugar{\Gamma}{\scon{T}{e}}{\Cons{T}{e}}}
\quad
\inferrule
  {\desugar{\Gamma}{\stuple{\many{e_i}} :: \tau}{e}}
  {\desugar{\Gamma}{\scon{T}{\many{e_i}} ::_N \svariant{T \mapsto \tau, \cdots}}{\Cons{T}{e}}}
\\
\inferrule
  {\desugar{\Gamma}{e_1}{e_1} \\
   \desugar{\Gamma,v}{e_2}{e_2} \\
   v\ \text{fresh}}
  {\desugar{\Gamma}{\sseq{e_1}{e_2}}{\Let{v}{e_1}{e_2}}}
\\
\inferrule
  {\desugar{\Gamma}{e_1}{e_1} \\
   \desugar{\Gamma}{e_2}{e_2}}
  {\desugar{\Gamma}{\sapp{e_1}{e_2}}{\App{e_1}{e_2}}}
\\
\inferrule
  {\desugar{\Gamma}{e_1}{e_1} \\
   \desugar{\Gamma}{e_2}{e_2} \\
   \desugar{\Gamma}{e_3}{e_3}}
  {\desugar{\Gamma}{\sifthel{e_1}{e_2}{e_3}}{\If{e_1}{e_2}{e_3}}}
\quad
\inferrule
  {\desugar{\Gamma}{e_1}{e_1} \\
   v\ \text{fresh} \\
   \desugar{\Gamma,v}{e_2}{e_2} \\
   \desugar{\Gamma,v}{e_3}{e_3}}
  {\desugar{\Gamma}{\sifthel{e_1\ \sBANG \many{v_j}}{e_2}{e_3}}{\LetBang{\many{v_j}}{v}{e_1}{\If{v}{e_2}{e_3}}}}
\\
\inferrule
  {\desugar{\Gamma}{e}{e}}
  {\desugar{\Gamma}{\smember{e}{f}}{\Member{e}{f}}}
\\
\inferrule
  { }
  {\desugar{\Gamma}{\sunit}{\Unit}}
\quad
\inferrule
  {\desugarlit{\Gamma}{\ell}{\ell}}
  {\desugar{\Gamma}{\ell}{\ell}}
\\
\inferrule
  {\desugar{\Gamma}{e_1}{e_1} \\
   \desugar{\Gamma}{e_2}{e_2} \\\\
   \texttt{--fno-tuples-as-sugars}}
  {\desugar{\Gamma}{\stuple{e_1, e_2}}{\bot}}
  {(\text{tuples are not in Core})}
\quad
\inferrule
  {\text{for each $i$: }\desugar{\Gamma}{e_i}{e_i}}
  {\desugar{\Gamma}{\stuple{\many{e_i}}}{\StructInit{\many{\FieldEq{\texttt{p}$i$}{e_i}}}}}
\\
\inferrule
  {\text{for each $i$: }\desugar{\Gamma}{e_i}{e_i}}
  {\desugar{\Gamma}{\surecord{\many{f_i = e_i}}}{\StructInit{\many{\FieldEq{f$_i$}{e_i}}}}}
\\
\inferrule
  {\desugaralt{\Gamma}{\sletin{irrp = e'}{e}}{e}}
  {\desugar{\Gamma}{\sletin{irrp^\tau = e'}{e}}{e}}
\quad
\inferrule
  {\desugar{\Gamma}{e'}{e'} \\
   \desugar{\Gamma,pv}{e}{e}}
  {\desugar{\Gamma}{\sletin{pv^\tau = e'\ \sBANG \many{v_j}}{e}}{\LetBang{\many{v_j}}{pv}{e'}{e}}}
\\
\inferrule
  {v\ \text{fresh} \\
   \desugar{\Gamma}{\sletin{pv = e'\ \sBANG \many{v_j}, irrp^\tau = pv}{e}}{e}}
  {\desugar{\Gamma}{\sletin{irrp^\tau = e'\ \sBANG \many{v_j}}{e}}{e}}
\quad
\inferrule
  {\desugar{\Gamma}{\sletin{b_0}{\sletin{b_i}{e}}}{e}}
  {\desugar{\Gamma}{\sletin{b_0, \many{b_i}}{e}}{e}}
\\
\inferrule
  {\desugar{\Gamma}{e}{e}}
  {\desugar{\Gamma}{\sput{e}{}}{e}}
\quad
\inferrule
  {\desugar{\Gamma}{e}{e} \\
   \desugar{\Gamma}{e'}{e'}}
  {\desugar{\Gamma}{\sput{e}{f = e'}}{\Put{e}{f}{e'}}}
\quad
\inferrule
  {\desugar{\Gamma}{\sput{(\sput{(e :: \stytake{\tau}{\many{f_i}})}{f_0 = e_0})}{\many{f_i = e_i}}}{e}}
  {\desugar{\Gamma}{\sput{e}{f_0 = e_0, \many{f_i = e_i}} ::_N \tau}{e}}
\end{inductive}
\vspace{1em}

\begin{inductive}{\desugaralts{\Gamma}{\scaseof{e'}{\many{alt_i}}}{e}}
\inferrule
  {\desugaralt{\Gamma}{\scaseof{e'}{alt}}{e}}
  {\desugaralts{\Gamma}{\scaseof{e'}{alt}}{e}}
\\
\inferrule
  {\desugar{\Gamma,pv}{e_0}{e_0} \\
   v'\ \text{fresh} \\
   \desugaralts{\Gamma,v'}{\scaseof{v' :: \svariant{\many{T_j \mapsto \tau_j}}}{\many{alt_i}}}{e}}
  {\desugaralts{\Gamma}{\scaseof{v ::_N \svariant{T \mapsto \tau, \many{T_j \mapsto \tau_j}}}{\salt{\scon{T}{pv}}{e_0}, \many{alt_i}}}
                       {\Case{v}{\Cons{T}{\VarN{pv}}}{e_0}{v'}{e}}}
\\
\inferrule
  {v'\ \text{fresh} \\
   \desugaralts{\Gamma}{\scaseof{v}{\salt{\scon{T}{v' :: \tau}}{\sletin{irrp = v'}{e_0}}}, \many{alt_i}}{e}}
  {\desugaralts{\Gamma}{\scaseof{v :: _N \svariant{T \mapsto \tau, \cdots}}{\salt{\scon{T}{irrp}}{e_0}, \many{alt_i}}}{e}}
\\
\inferrule
  {\desugaralts{\Gamma}{\scaseof{v :: \tau}{\salt{\scon{T}{\stuple{\many{irrp_m}}}}{e_0}, \many{alt_i}}}{e}}
  {\desugaralts{\Gamma}{\scaseof{v ::_N \tau}{\salt{\scon{T}{\many{irrp_m}}}{e_0}, \many{alt_i}}}{e}}
\\
\inferrule
  {\desugar{\Gamma}{v}{e'} \\
   \desugar{\Gamma}{e_0}{e_0} \\
   \desugaralts{\Gamma}{\scaseof{e_0}{\many{alt_i}}}{e}}
  {\desugaralts{\Gamma}{\scaseof{v}{\salt{\ell}{e_0}, \many{alt_i}}}{\If{e' \texttt{==} \ell}{e_0}{e}}}
\\
\inferrule
  {pv\ \text{fresh} \\
   \desugar{\Gamma}{\sletin{pv = e'}{\scaseof{pv}{\many{alt_i}}}}{e}}
  {\desugaralts{\Gamma}{\scaseof{e'}{\salt{pat}{e_0}}, \many{alt_i}}{e}}
\end{inductive}
}

\section{Types}

\subsection{Base Types}\label{ssec:basetypes}

\paragraph{Primitive types} In \cogent, there are a few built-in types, they are \inlinecogent{U8},
\inlinecogent{U16}, \inlinecogent{U32}, \inlinecogent{U64}, \inlinecogent{Bool} and \inlinecogent{String}.~\footnote{There
use to be a primitive \inlinecogent{Char} type in the surface language, but since it is
identical to \inlinecogent{U8}, it is removed from the language.} For example, \inlinecogent{U8} is unsigned
8-bit integer, which corresponds to
\inlinec{uint8\_t} in C. Integer literals can be written in octal (e.g.\ \inlinecogent{0O72}, \inlinecogent{0o24};
reads ``zero-oh''), decimal or hexadecimal (e.g.\ \inlinecogent{0XA2C}, \inlinecogent{0x1fd}). \inlinecogent{Bool}
type in \cogent has only two values, \inlinecogent{True} and \inlinecogent{False}.
\inlinecogent{String} is a type which does not relate to \inlinecogent{U8} in any way. This type is mainly used
for debugging (e.g. \inlinecogent{printf}),
as there are no \inlinecogent{String}-specific operations that allows users to work on them.

\paragraph{Function types} They are of the form $\tau_1 \rightarrow \tau_2$. It can only have one argument, and one return type.
If multiple inputs are desired, they should be grouped in a composite type by \emph{uncurrying}. If the argument or the return type
is a function type itself, it also needs to be enclosed in a composite type. E.g.\ \inlinecogent{(A -> A) -> (A -> A)}.

\paragraph{Abstract types} Apart from these primitive types, users can declare their own types, as building blocks, in \cogent.
They are abstract in the language and their definitions are implemented in C (or antiquoted C, see below \todo{where?}) directly.
For example, one can do \inlinecogent{type T} and a brand new type \inlinecogent{T} is created in the program.

\paragraph{Polymorphic types} \cogent is parametrically polymorphic. To define a poly-type, one can write \inlinecogent{all a. a -> a}
for example. Universal quantifiers are always explicit.

\paragraph{Unit type} Unit type (\inlinecogent{()}) has only one inhabitant, which is unit (also spelt as \inlinecogent{()}).

\subsection{Uniqueness type system}
One major feature of \cogent is its uniqueness type system. For detailed explanations, see \cite{Wadler_90} and our publications.
Generally speaking, \emph{linear} objects are dynamically and explicitly allocated on the heap. By contrast, anything else are
statically and implicitly allocated on the stack. For heap-allocated objects, we need to manage the references to them, which is
where uniqueness types help, to ensure that each object on the heap is pointed by \textbf{exactly} one reference at any
given point in the program.~\footnote{There are exceptions to this, which will be discussed shortly.}

\paragraph{Permissions} In order to classify uniqueness properties of each type of objects, we introduce permissions.
In \cogent, permissions are denoted by a combination of three letters -- $\permission{D}$ (discardable), $\permission{S}$ (shareable)
and $\permission{E}$ (escapable).
It's obvious to see that for any linear object, it's type must be non-$\permission{D}$ and non-$\permission{S}$. We cannot throw away
a reference to a linear object, nor can we duplicate (share) it. In \cogent, $\permission{D}$ and $\permission{S}$ are always coupled
when describing the permissions of a type, although in the formal semantics, we usually only focus on one side of it
at a time. In the following text, we just write $\permission{DS}$ instead of
having them separately. We now have at most 4 different combinations. Getting simpler, right?

In some cases, we want to create read-only ``copies'' of an object (say, giving them to other functions which only needs to inspect them).
It in fact doesn't make a deep copy of the object (sure, because we don't modify it anyway), so it would be more accurate to say
that it creates read-only references to the object. In \cogent's purely functional setting, we just don't have to distinguish
references and the actual stored objects.
For a linear object (i.e. without $\permission{DS}$ permissions), we can temporarily put it in a context where it's treated as read-only.
In this context, the linear object can be freely discarded or duplicated (for the reason we explained earlier), thus the permissions 
of the type changes, from linear to read-only, obtaining $\permission{DS}$ permissions. But obviously, we cannot simply allow
these read-only copies to escape this specific context, otherwise we may have no or multiple references (one read-write, and
arbitrarily many read-only). For example, consider the following expression:
\begin{lstlisting}[language=Cogent]
let obj_ro = (let (obj_ro1, obj_ro2) = dup obj
               in obj_ro1) !obj
 in foo (obj_ro, obj)
\end{lstlisting}
In this expression, \inlinecogent{obj} is a linear object. \inlinecogent{!obj} creates a context inside which
\inlinecogent{obj} becomes read-only.~\footnote{For
more about the term level operation creating the read-only context, see Section~\ref{ssec:letbang}.}
The scope of the read-only \inlinecogent{obj} is in the \inlinecogent{let}-binding (the expression on the RHS of the \inlinecogent{=} in
a \inlinecogent{let}-expression). The expression bound to \inlinecogent{obj_ro} is totally
valid, as we can duplicate the read-only \inlinecogent{obj} and discard one of them (\inlinecogent{obj_ro2}). 
Note that the scope of the read-only
\inlinecogent{obj} is the entire inner \inlinecogent{let}-expression. The problem of this whole expression
is that \inlinecogent{obj_ro1}, as a read-only object, escapes its read-only context, where our type system
tells us that it cannot escape. As we can see that in
the body of the outer binding, \inlinecogent{obj_ro} and \inlinecogent{obj} are referencing to the same thing,
which violates the uniqueness type system.

We use $\permission{E}$ to encode this property. A normal
uniqueness type has $\permission{E}$-permission. After coming into a read-only context, it gains 
$\permission{DS}$, losing $\permission{E}$. For non-unique types,
they always have all $\permission{\{DSE\}}$ permissions, as we don't put any constraints on the usage of them. A type
without any of $\permission{\{DSE\}}$ is usually useless as a whole, so we don't consider them.

To summarise, we have 3 kinds of permission combinations in \cogent, namely linear read-only ($\permission{\{DS\}}$),
linear read-write ($\permission{\{E\}}$), and non-linear ($\permission{\{DSE\}}$).

In order to restrain the permissions type variables possess, constraints can be given when explicit quantifiers
are given. For example, \inlinecogent{all (a :< DSE, b). a -> b} means that type variable \inlinecogent{a} has to
be a type which is non-linear, whereas no constraints are posed on what permissions \inlinecogent{b} can have.


\subsection{Composite types}

Using the aforementioned base types, with the help of type constructors and type-level operators, we can build up
composite types. We generally have three different kinds of composite types --- record types, variant types
and tuples.

\paragraph{Record types} Similar to C structs, each record consists of more than 1 field. Fields are order-sensitive.
For example, \code{\{f1:T1, f2:T2, f3:T3\}} is an intensionally different type to \code{\{f2:T2, f1:T1, f3:T3\}}.
Records (or sometimes to disambiguate we call them \emph{boxed} records) is a data structure allocated on the heap,
explicitly, by abstract \Cogent functions. In pure \Cogent (without the help of abstract functions), there is no way to allocate/create
a boxed record, even though you have all the fields at hand, nor a way to free one. Each boxed record comes with
one reference (to the ``box'' itself because the ``box'' is on the heap) regardless of its fields (which
are not necessarily on the heap, depending on each field's type), so every
boxed record is linear, even though all its fields are non-linear or taken. A boxed record is analogous to
a box with one linear reference, which is capable of encapsulating all (if any) the references to its linear fields. So from outside
a boxed record, we have no access to its linear fields. We will introduce term level operations for field access in later sections.

\paragraph{Unboxed records} In contrast to boxed records, we also have unboxed records. The major difference is that
the record itself is allocated on the stack, implicitly by the program. It implies that the linearity of an unboxed record
solely depends on its fields. If any field is linear, then the whole is linear. In \cogent we can construct or destruct an
unboxed records cheaply, supplying or obtaining all it fields (especially linear ones) respectively. An unboxed record
is written as \inlinecogent{\#\{f1:T1, f2:T2\}}, for example, with a leading \inlinecogent{\#}. It's worth mentioning, though, the linear
fields of an unboxed record are still allocated on the heap.


\paragraph{Tuples} Tuples can be considered as unnamed unboxed records. It is also order-sensitive.
In the core calculus of \cogent, tuples are nested pairs, grouping from the right. For example, \inlinecogent{(a,b,c,d)} is equal to
\inlinecogent{(a,(b,(c,d)))}. Other than that, it is pretty much the same as an unboxed record. Notice that there is
no 1-tuple in \cogent (i.e.\ $(a) \equiv a$).


\paragraph{Variant types} Variants are similar to datatypes in ML or Haskell. For example,
\inlinecogent{<A U8 | B Bool U8 | C>} is roughly the same as \inlinehs{data X = A U8 | B Bool U8 | C}.
In terms of the low-level representation, variants at the moment are always allocated on the stack.
The payload can be either linear of non-linear, and if any alternative has a linear payload, the entire
variant is also linear. Every tag can take arbitrarily many arguments, but the compiler will desugar them
to a unit (e.g.\ \inlinecogent{()} for \inlinecogent{C}) or a tuple (e.g. \inlinecogent{(Bool, U8)} for \inlinecogent{B}) accordingly.


\subsection{Type Operators}
\cogent provides several type operators. \inlinecogent{take} and \inlinecogent{put} operators can be applied to
record types (be it boxed or not) and variant types. They will be introduced in detail in Section~\ref{ssec:records}.
Here, we focus on the other two operators: \inlinecogent{\#} and \inlinecogent{!}.

\paragraph{Unbox} \inlinecogent{\#} is the sigil for unboxed data types. It works for
abstract types and records. For an abstract type \inlinecogent{A}, \inlinecogent{\#A}
is the unboxed version of it. \code{\#} has to be put at its use site.
For example, if we have code:
\begin{lstlisting}[language=Cogent]
type #A
foo : A -> Bool
bar : #A -> Bool
\end{lstlisting}
Note that the \code{A} in line 2 is still the boxed version, the \code{\#A} in
line 3 is an unboxed type. We can tell that type \code{\#A} is of 2-kind.

If we apply \code{\#} to records, they become unboxed records as described earlier.
If the record has a synonyms, then the operator can be put either at definition site
or use site. For example,
\begin{lstlisting}[language=Cogent]
type R = {f1 : A, f2 : B}
foo : #R -> ()
type S = #{f1 : A, f2 : B}
bar : S -> ()
baz : #S -> ()
\end{lstlisting}
In this program, \code{\#R == S == \#S}, because the types are purely structural and
\code{\#} is idempotent. Keep in mind that a type synonym is just a ``macro'',
so it is totally valid to put any type operators that works for records to
synonyms that are indeed records. We will not repeat this point in the following text.

\paragraph{Bang} The \code{!} suffix turns any linear types into read-only ones.
It is also idempotent and has no effect on 2-kinded types. The underlying C types
for a linear type and its banged variant are identical.

\section{Patterns and Expressions}
We have seen a large portion of \cogent's type system. On term level, similar to most mainstream functional language,
we can also categorise things into patterns and expressions, which reside on LHS and RHS of \code{=}s respectively (roughly speaking).

\paragraph{Patterns} In \cogent, pattern matching is not as strong as some commercial level languages. When we deal with nested patterns,
inner patterns have to be irrefutable, which can be seen from the syntax (see Section~\ref{ssec:grammar}).

\paragraph{Expressions} They are quite standard and the semantics of them can be derived straightforwardly from the syntax. In the following
paragraphs we are just going to highlight some of the ``unusual'' features.

\subsection{Literals and Variables}
See Section~\ref{ssec:basetypes}.

\subsection{Dealing with records} \label{ssec:records}
We first look at boxed records. Assume that we have an record \code{r} of type \code{\{f1:T1, f2:T2, f3:U32\}} (for
brevity, both in a \cogent program and in this documentation, we would like to define it as \code{R} which is intensionally the same),
where both \code{T1} and \code{T2} are boxed abstract types. Generally, there are three operations relating to record fields --- \emph{member}, \emph{take} and \emph{put}.
Member operation behaves uniformly for linear fields and non-linear ones. The precondition is that the record which contains the field
has to be shareable (i.e. with kind \code{S}). In the case of \code{r} (of type \code{R}), it is not shareable as it contains linear fields \code{f1} and \code{f2}.
In order to temporarily turn it into a shareable one, we use \code{!} operator, which is introduced later in Section~\ref{ssec:letbang}.
By doing \code{(... r.f1 ...) !r} (the ellipses are meta-syntax, indicating the context in which \code{r} is read-only and consequently shareable).
It's worth stressing that by doing member extraction, what you get is merely a \emph{value}. It does not correspond to any memory locations on the heap.

To access the memory locations corresponding to fields, we need take. Take operation is in the form of pattern matching in the
surface language, written \code{r' \{f1 = f1\_obj\} = r} (of course, more than 1 field can be taken at once).
It only works for records that are not read-only as a whole (fields do not matter) as we are destructing the
record.
This pattern matching does the following:
\begin{enumerate}
\item it takes field \code{f1} out of record \code{r}, and binds it to name \code{f1\_obj};
\item it gives the ``new'' record \code{r'}, with field \code{f1} taken.
\end{enumerate}
After doing it, the record \code{r'} no more contains the reference to object \code{f1\_obj} (via its field
\code{f}), which is now a standalone reference.
To interpret it, we can:
\begin{itemize}
\item functionally, the old value \code{r} \emph{becomes} two new values, one of type \code{T1}, and the other of type
  \code{R take f1} (more detail in a second);
\item and imperatively, you can consider it as assigning the pointer to \code{r -> f1} a new pointer \code{f1\_obj} and
\code{r -> f1} becomes \code{NULL} in the record.
\end{itemize}

We can see that taken fields are reflected in the type level. Apart from ``complete'' record types introduced earlier, we can also
have ``partial'' record types, which are first class as well. These "partial" record types have
some (or all) of its fields taken. These types are denoted as \code{R take f1}, for example. If more than one fields are taken, then we need to put them in parentheses,
separated by commas (e.g.\ \code{R take (f1,f2)}). If all are taken, a syntactic sugar is \code{R take (..)}. Dually, type \code{R put f1} means that only \code{f1} is
\emph{not} taken. It is just for convenience, when you have more fields taken than not. It is obvious that for \code{R}, we have
\code{R take f1 == R put (f2,f3)}.

The dual operation of take (the one in expressions) is, as you might have guessed, put. Note that the type operator
\code{put} is merely a syntactic sugar for type-level \code{take},
whereas put operation (ironically not spelt out as \code{take} in the
surface language) is a real thing in expressions, even in the core language.

Put, in contrast to take, appears in expressions (as opposed to patterns) in \cogent. Continuing on our running example, if we want to put object \code{f1\_obj} back to
\code{r'}, we can do \code{r' \{f1 = f1\_obj\}}. You can see that the syntax is nearly identical to take, so do not get confused.
Note that \cogent is a functional language, so this is an expression, not a command/statement. It does not have any effect on the state.
Linear type system requires you bind the put-expression to a new binder, say \code{r''}.
So at this stage, \code{r == r''}, and \code{r'} and \code{f1\_obj} no longer exist!

Now, some syntactic sugar for take and put. If the field name is the same as the binder name, we can use name punning. E.g.\ instead of
\code{let r' \{f1 = f1, f2 = f2\} = r in ...}, we can write \code{let r' \{f1,f2\} = r in ...}. If we want to take all (yet untaken) fields (if at all), then we can write
\code{let r' \{..\} = r in ...}.~\footnote{It is a bit font overloading in this documentation,
\code{..} is \cogent syntax, and \code{...} is meta-level text for any omitted source code.}
Both of them apply to put as well, as expected. Once again, \code{take} and \code{put} are type-level
syntax, and take and put in term-level (as patterns and expressions) have similar syntax using curly brackets.

The aforementioned take operation applies to both linear fields and non-linear ones, although it turns out to be overweighted for non-linears. In order to ``take'' a non-linear field, the first
choice is usually the member operation. To ``put'' a non-linear field, namely to update it
destructively, we can do it by \code{r' = r \{f1 = new\_f1\}}. This is just the normal
put syntax. For non-linear field, a special feature is, the field can be put
in a row more than once (but can only be taken once, as usual). In theory, because the field
is store on the stack, multiple takes is also valid. We forbid it for the purpose of modelling
uninitialised field. When allocating a new record, we generally leave its non-linear fields
taken as well to indicate that these fields are not yet initialised.

\subsection{Control Flow and Pattern Matching}
Control flow in \cogent is simple. We basically support \code{if}-\code{then}-\code{else}
expressions and case distinctions. The conditionals are standard. Just be reminded of the
functional semantics of it. Conditionals can be nested and users should consult Section~\ref{ssec:grammar} about where to put parenthesis. Case distinctions are in the form
of guards. Semantically, conditionals can always be represented equivalently by cases.
The patterns following each guard matches the value of the scrutinee. Pattern matching has
to be exhaustive. For more examples, please see files in directory \texttt{cogent/tests}.
Since each \cogent function allows at most one definition binding, to pattern match argument, we can write
a program like:
\begin{lstlisting}[language=Cogent]
type A

bar : <A U8 | B Bool | C #A> -> ()
bar | A a -> ()
    | B b -> ()
    | c   -> ()
\end{lstlisting}
instead of
\begin{lstlisting}[language=Cogent]
type A

bar : <A U8 | B Bool | C #A> -> ()
bar arg = arg | A a -> ()
              | B b -> ()
              | c   -> ()
\end{lstlisting}


\subsection{Unboxed Records and Tuples} They have similar semantics.
Each \cogent function takes exactly one argument and returns exactly one resultant.
One way to give multiple parameters is to use unboxed records or tuples, which can be
pattern matched directly. One reason to use unboxed records is, by name punning,
we can achieve a C-style function. For instance,
\begin{lstlisting}[language=Cogent]
foo : #{f1 : A, f2 : B} -> ()
foo #{..} = ... bar (f1, f2) ...
-- foo #{f1 = f1_var, f2 = f2_var} = ...
\end{lstlisting}
using the record wildcard syntax, we introduce names \code{f1} and \code{f2}
into scope. Syntax \code{\#\{...\}} (the \code{...} is meta-syntax) is
pattern matching the argument. The commented line is the general syntax to match
an unboxed record. The downside of it, however, is that the record is passed by value
instead of by reference.

Let's take a look at another example:
\begin{lstlisting}[language=Cogent]
bar : (A, B, C) -> ()
bar (a, bc) = let (b, c) = bc in ...
-- bar (a, b, c) = ...
\end{lstlisting}
Line 1 is one way to pattern match the argument, since tuples are right associative.
Line 2 is the flattened way to match.

Another usage of unboxed records is construction. We know that there is
no way to create a \emph{boxed} record in pure \cogent. But for unboxed ones,
we can construct one on the fly, which resembles creation of tuples. The code looks like:
\code{\#\{f1 = f1\_value, f2 = f2\_value\}}, which creates an unboxed record with fields \code{f1}
and \code{f2}, bound to value \code{f1\_value} and \code{f2\_value} respectively.
The effectively equivalent tuple version is \code{(f1\_value, f2\_value)}.
We can summarise that, for unboxed records and tuples, their patterns and expressions
share the same shape.

\subsection{Let} \label{ssec:letbang}
\cogent \code{let}-binding is standard. A sequence of \code{let}-bindings are separated
by keyword \code{and}. When the binder is not important, we can use a wildcard \code{\_}
as a placeholder. Alternatively, we can use sequence syntax, separated by \code{;}. In this
case, the binder is unspoken (thus the type of the expression should be trivial in terms of
linearity). Each binding can be given a type annotation, written as \code{let x : t = b in body}.

\subsection{!}
In accordance to \cogent's linear type system, there is a way to turn a linear
object into a read-only one. The essence is to use \code{!} (read: bang) operator to create a
context in which the bang'ed linear variables are read-only. The language allows users to
bang several variable in one go. There are 3 constructs in \cogent that can accommodate bangs ---
\code{let}, \code{if} and case distinction. The scope of bang'ed variables are highlighted in the following
(trivial) examples.
\begin{lstlisting}[language=Cogent,escapechar=?]
type A

foo : A -> A
foo a = let (a1,a2) = ?\colorbox{light-gray}{pair a}? !a in a

sizeA : A! -> U32

bar : A -> A
bar a = if ?\colorbox{light-gray}{sizeA a > 4}? !a then a else a

bar' : A -> A
bar' a = ?\colorbox{light-gray}{sizeA a > 4}? !a
           | True  -> a
           | False -> a
\end{lstlisting}


\subsection{Polymorphic Functions}
\Cogent supports polymorphic functions. To define one, we need to explicit qualify the type variable
in the type signature. E.g.\
\begin{lstlisting}[language=Cogent]
iterate: all (y, r, s, acc, obsv). #{
	gen: Generator y r s acc obsv!,
	cons: Consumer y r s acc obsv!,
	acc: acc,
	obsv: obsv!} -> IterationResult acc r s
\end{lstlisting}
In this example, \code{y}, \code{r}, \code{s}, \code{acc} and \code{obsv} are type variables. In some cases,
we would like to constrain the kind of some type variables, which can be done using kind constraints (\code{:<}).
For example,
\begin{lstlisting}[language=Cogent]
array_create    : all (a :< E  ). (Ex, U32) -> R (Ex, Array     a) Ex
wordarray_create: all (a :< DSE). (Ex, U32) -> R (Ex, WordArray a) Ex
\end{lstlisting}
Comparing \code{array\_create} and \code{wordarray\_create}, we can see that the former function requires type argument
\code{a}, namely the element type, to be \code{E}scapable (which means the elements are not read-only), whereas
the later requires strictly more, that the element type
has to be \code{D}iscardable, \code{S}hareable and \code{E}scapable (which is an approximation of ``Word'' types).

To call a polymorphic function, since \cogent compiler currently lacks the capability of inferring poly-functions (which is
theoretically possible), the user has to explicitly apply a function to type arguments. For instance,
\begin{lstlisting}[language=Cogent]
let limit = ext2_last_byte (inode, n) - u16_to_u64 (ext2_dir_rec_len (1)) !inode
and ((ex, maybe_dirent, kaddr, _), res) =
      iterate_do [Ext2DirEnt, (), U32, EmptyDirentsInPageAcc, DirentsInPageObsv]
        (#{ init = dirent,
            gen = get_next_dirent_from_page4,
            cons = check_dirent_empty,
            acc = (ex, None (), kaddr, 0),
            obsv = limit })
 in ...
\end{lstlisting}
The list in square brackets are types which instantiate the type variables respectively.

\TODO{How C code is generated? how to use the compiler and its intermediate outputs? What are the must-knows in the compiler?}

\section{Flags in \cogent Compiler}

\section{How to optimise \cogent programs?}

%\subsection{Static Typing Rules}
%\newcommand{\types}[3]{#1 \vdash #2 : #3}
%\newcommand{\typesS}[3]{#1 \vdash #2 :^\star #3}
%\newcommand{\typing}[4]{#1 \vdash #2 : #3 \leadsto #4}
%\newcommand{\typingS}[4]{#1 \vdash #2 :^{\star} #3 \leadsto #4}
%\newcommand{\useVar}[3]{#2 \stackrel{#1}{\leadsto} #3}
%\newcommand{\splitenv}[3]{#1 \leadsto #2 \boxplus #3 }
%\begin{inductive}{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2}}
%  \inferrule{ }{\splitenv{\epsilon}{\epsilon}{\epsilon}}{\textsc{Empty}}
%  \quad
%  \inferrule{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2}}
%            {\splitenv{\Gamma, x : \tau}{\Gamma_1, x : \tau}{\Gamma_2}}
%            {\textsc{Lin}_1}
%  \quad
%  \inferrule{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2}}
%            {\splitenv{\Gamma, x : \tau}{\Gamma_1}{\Gamma_2, x : \tau}}
%            {\textsc{Lin}_2}
%  \\
%  \inferrule{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2}}
%            {\splitenv{\Gamma, x : \intu{\tau}}{\Gamma_1, x : \intu{\tau}}{\Gamma_2, x : \intu{\tau}}}
%            {\intu{\textsc{Contract}}}
%  \quad
%  \inferrule{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2}}
%            {\splitenv{\Gamma, x : \unboxed{\tau}}{\Gamma_1, x : \unboxed{\tau}}{\Gamma_2, x : \unboxed{\tau}}}
%            {\unboxed{\textsc{Contract}}}
%  \\
%  \inferrule{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2}}
%            {\splitenv{\Gamma, x : \intu{\tau}}{\Gamma_1}{\Gamma_2}}
%            {\intu{\textsc{Weaken}}}
%  \quad
%  \inferrule{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2}}
%            {\splitenv{\Gamma, x : \unboxed{\tau}}{\Gamma_1}{\Gamma_2}}
%            {\unboxed{\textsc{Weaken}}}
%\end{inductive}
%\begin{center}
%   We shall say $\Gamma \leadsto \Gamma'$ iff $\splitenv{\Gamma}{\Gamma'}{\epsilon}$
%
%   We also permit unlimited exchange, and assume w.l.o.g. that all variable names are unique.
%\end{center}
%
%\begin{inductive}{\types{\Gamma}{e}{\tau}}
%  \inferrule{ \litType{L} = \primtype{t}}
%            { \types{}{L}{\unboxed{\primtype{t}}}}
%            { \textsc{Lit}}
%  \qquad
%  \inferrule{ }
%            { \types{x : \tau}{x}{\tau}}
%            { \textsc{Var}}
%  \qquad
%  \inferrule{ \opType{o} = (\overline{\tau_i} \rightarrow \tau)
%           \\ \typesS{\Gamma}{\overline{e_i}}{\overline{\tau_i}}}
%            { \types{\Gamma}{o(\overline{e_i})}{\tau}}
%            { \textsc{Op}}
%\end{inductive}
%\begin{inductive}{\typesS{\Gamma}{\overline{e}}{\overline{\tau}}}
%  \inferrule{ }{\typesS{}{\epsilon}{\epsilon}}{\textsc{Empty}}
%  \qquad
%  \inferrule{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2} \\ \types{\Gamma_1}{e}{\tau} \\ \typesS{\Gamma_2}{\overline{e_i}}{\overline{\tau_i}}}
%            {\typesS{\Gamma}{e,\overline{e_i}}{\tau, \overline{\tau_i}}}{\textsc{Cons}}
%\end{inductive}
%\begin{inductive}{\types{\Gamma}{s}{\tau_r}}
%  \inferrule{ \funcType{f} = (\overline{\tau_i} \rightarrow \tau_r)
%           \\ \typesS{\Gamma}{\overline{e_i}}{\overline{\tau_i}}}
%            { \types{\Gamma}{f(\overline{e_i})}{\tau_r}}
%            { \textsc{App}}
%  \quad
%  \inferrule{ \typesS{\Gamma}{\overline{e_i}}{\overline{\tau_i}} }
%            { \types{\Gamma}{\return{\overline{e_i}}}{\overline{\tau_i}}}
%            { \textsc{Return} }
%  \\
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{e}{\unboxed{\primtype{Bool}}}
%           \\ \types{\Gamma_2}{s_t}{\tau_r}
%           \\ \types{\Gamma_2}{s_e}{\tau_r}}
%            { \types{\Gamma}{\ifthenelse{e}{s_t}{s_e}}{\tau_r}}
%            { \textsc{If}}
%  \\
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{e}{\linear{\variant{\overline{\datatag{p}_i :: T_i}}}}
%           \\\\ \text{for each $i$:}\ \types{x_i : \linear{T_i}, \Gamma_2}{s_i}{\tau_r}}
%            { \types{\Gamma}{\case{e}{\overline{\datatag{p}_i\ x_i \rightarrow s_i}}}{\tau_r}}
%            { \linear{\textsc{Case}}}
%  \quad
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{e}{\intu{\variant{\overline{\datatag{p}_i :: T_i}}}}
%           \\\\ \text{for each $i$:}\ \types{x_i : \intu{T_i}, \Gamma_2}{s_i}{\tau_r}}
%            { \types{\Gamma}{\case{e}{\overline{\datatag{p}_i\ x_i \rightarrow s_i}}}{\tau_r}}
%            { \intu{\textsc{Case}}}
%  \\
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{e}{\unboxed{\primtype{err}}}
%           \\ \typesS{\Gamma_2}{\overline{e_i}}{\overline{\tau_i}} }
%            { \types{\Gamma}{\fail{e, \overline{e_i}}}{\fails{\overline{\tau_i}}}}
%            { \textsc{Fail} }
%  \\
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{e}{\linear{\placeholder{\record{\overline{\fieldname{f}_i :: \opened{\tau_i}},\overline{\fieldname{f}_j :: \closed{\tau_j}}}}}}
%           \\ \typesS{\Gamma_2}{\overline{e_i}}{\overline{\tau_i}}}
%            { \types{\Gamma}{\close{e}{\overline{\fieldname{f}_i = e_i}}}{\linear{\record{\overline{\fieldname{f}_i :: \tau_i},\overline{\fieldname{f}_j :: \tau_j}}}}}
%            { \textsc{Close}}
%  \\
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{e}{\linear{\record{\overline{\fieldname{f}_i :: \tau_i}, \overline{\fieldname{f}_j :: \tau_j}}}}
%           \\\\ \types{\Gamma_2,\overline{x_i : \tau_i},p : \linear{\placeholder{\record{\overline{\fieldname{f}_i :: \opened{\tau_i}}, \overline{\fieldname{f}_j :: \closed{\tau_j}} }}}}{s}{\tau_r}}
%            { \types{\Gamma}{ \open{e}{p}{\record{\overline{\fieldname{f}_i = x_i}}}{s} }{\tau_r}}
%            { \textsc{Open}}
%  \\
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%          \\  \types{\Gamma_1}{s}{\tau'_r}
%          \\\\  \types{\Gamma_2}{C}{\tau'_r \rightarrow \tau_r} }
%            { \types{\Gamma}{\bind{s}{C}}{\tau_r} }
%            { \textsc{Bind}}
%\quad
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2,\overline{x_i : \linear{T_i}}}
%          \\  \types{\Gamma_1,\overline{x_i : \intu{\bang{T_i}}}}{s}{\tau'_r}
%          \\\\  \safe{\tau'_r}
%          \\  \types{\Gamma_2, \overline{x_i : \linear{T_i}}}{C}{\tau'_r \rightarrow \tau_r} }
%            { \types{\Gamma}{\letbang{\overline{x_i}}{s}{C}}{\tau_r} }
%            { \textsc{Let!}}
%\\
%  \inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{I}{(\overline{\tau_i} \rightarrow \overline{\tau_o}) \rightarrow \overline{\tau_t}}
%           \\\\ \types{\Gamma_2, \overline{x_i : \tau_i}}{s}{\fails{\overline{\tau_o},\overline{\tau_e}} } }
%            { \types{\Gamma}{\for{\overline{x_i}}{I}{s} }{ \fails{\overline{\tau_t},\overline{\tau_e}} } }
%            { \textsc{For}_F}
%\quad
%\inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{I}{(\overline{\tau_i} \rightarrow \overline{\tau_o}) \rightarrow \overline{\tau_t}}
%           \\\\ \types{\Gamma_2, \overline{x_i : \tau_i}}{s}{\succeeds{\overline{\tau_o}} } }
%            { \types{\Gamma}{\for{\overline{x_i}}{I}{s} }{ \succeeds{\overline{\tau_t}} } }
%            { \textsc{For}_S}
%\\
%\inferrule{ \splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%           \\ \types{\Gamma_1}{I}{(\overline{\tau_i} \rightarrow \overline{\tau_o}) \rightarrow \overline{\tau_t}}
%           \\\\ \types{\Gamma_2, \overline{x_i : \tau_i}}{s}{\canfail{\overline{\tau_o}}{\overline{\tau_o},\overline{\tau_e}} } }
%            { \types{\Gamma}{\for{\overline{x_i}}{I}{s} }{ \canfail{\overline{\tau_t}}{\overline{\tau_t},\overline{\tau_e}} } }
%            { \textsc{For}}
%\quad
%  \inferrule{ \types{\Gamma}{s}{\succeeds{\overline{\tau_i}}} }
%            { \types{\Gamma}{s}{\canfail{\overline{\tau_i}}{\overline{\tau_j}}} }
%            { \textsc{Prom}_S}
%\quad
%  \inferrule{ \types{\Gamma}{s}{\fails{\overline{\tau_j}}} }
%            { \types{\Gamma}{s}{\canfail{\overline{\tau_i}}{\overline{\tau_j}}} }
%            { \textsc{Prom}_F}
%\end{inductive}
%\begin{inductive}{\types{\Gamma}{C}{\tau_C}}
%  \inferrule{ \types{\Gamma, \overline{x_i : \tau_i}}{s}{\tau_r} }
%            { \types{\Gamma}{\onlysuccess{\overline{x_i}}{s}}{\succeeds{\overline{\tau_i}} \rightarrow \tau_r} }
%            { \textsc{Success}}
%  \quad
%  \inferrule{ \types{\Gamma, \overline{x_i : \tau_i}, x_\text{err} : \unboxed{\primtype{err}}}{s}{\tau_r} }
%            { \types{\Gamma}{\onlyfailure{x_\text{err}}{\overline{x_i}}{s}}{\fails{\overline{\tau_i}} \rightarrow \tau_r} }
%            { \textsc{Failure}}
%  \\
%  \inferrule{ \types{\Gamma, \overline{x_j : \tau_j}, x_\text{err} : \unboxed{\primtype{err}}}{s_f}{\tau_r}
%          \\  \types{\Gamma, \overline{x_i : \tau_i}}{s_s}{\tau_r} }
%            { \types{\Gamma}{\handlefailure{\overline{x_i}}{s_s}{x_\text{err}}{\overline{x_j}}{s_f}}{\canfail{\overline{\tau_i}}{\overline{\tau_j}} \rightarrow \tau_r} }
%            { \textsc{Both}}
%\end{inductive}
%\begin{inductive}{\types{\Gamma}{I}{\tau_I}}
%  \inferrule{\types{\Gamma}{e}{\linear{\arraytype{\tau}}}}
%            {\types{\Gamma}{\map{e}}{(\tau \rightarrow \tau) \rightarrow \linear{\arraytype{\tau}}}}
%            {\textsc{Map}}
%  \quad
%  \inferrule{\types{\Gamma}{e}{\intu{\arraytype{\tau}}}}
%            {\types{\Gamma}{\fold{e}}{(\tau \rightarrow \epsilon) \rightarrow \epsilon}}
%            {\textsc{Fold}}
%  \\
%  \inferrule{\splitenv{\Gamma}{\Gamma_1}{\Gamma_2}
%          \\\\ \types{\Gamma_1}{I}{(\overline{\tau_i} \rightarrow \overline{\tau_o}) \rightarrow \overline{\tau_t}}
%          \\ \types{\Gamma_2}{e}{\tau}}
%            {\types{\Gamma}{\with{I}{e}}{((\overline{\tau_i},\tau) \rightarrow (\overline{\tau_o},\tau)) \rightarrow (\overline{\tau_t},\tau)} }
%            {\textsc{With}}
%  \quad
%  \inferrule{\itertype{\itername{i}} = (\overline{\tau},\tau_I)
%          \\ \typesS{\Gamma}{\overline{e}}{\overline{\tau}} }
%            {\types{\Gamma}{\itername{i}(\overline{e})}{\tau_I}}
%            {\textsc{Iter}}
%\end{inductive}
%\begin{sidebyside}
%\begin{inductive}{\safe{\tau}}
%        \inferrule{ }{ \safe{\unboxed{\tau}}}
%                  {\unboxed{\textsc{Safe}}}
%  \quad \inferrule{ }{ \safe{\linear{\tau}}}
%                  {\linear{\textsc{Safe}}}
%\end{inductive}
%&
%\begin{inductive}{\safe{\tau_r}}
%        \inferrule{\text{for each $i$:}\ \safe{\tau_i}}
%                  { \safe{\succeeds{\overline{\tau_i}}}}
%                  {\textsc{Safe}_S}
%                  \quad
%        \inferrule{\text{for each $j$:}\ \safe{\tau_j}}
%                  { \safe{\fails{\overline{\tau_j}}}}
%                  {\textsc{Safe}_F}
%        \\
%        \inferrule{\text{for each $j$:}\ \safe{\tau_j} \\ \text{for each $i$:}\ \safe{\tau_i}}
%                  { \safe{\canfail{\overline{\tau_i}}{\overline{\tau_j}}}}
%                  {\textsc{Safe}}
%\end{inductive}
%\end{sidebyside}
%\begin{sidebyside}
%\begin{fundef}{\textbf{bang}}{T \rightarrow T}
%   \bang{\primtype{T}} & = & \primtype{T} & \textsc{Prim!} \\
%   \bang{\record{\overline{\fieldname{f}_i :: \tau_i}}} & = & \record{\overline{\fieldname{f}_i :: \bangP{\tau_i}}} & \textsc{Record!} \\
%   \bang{\variant{\overline{\fieldname{f}_i :: T_i}}} & = & \variant{\overline{\fieldname{f}_i :: \bang{T_i}}} & \textsc{Variant!} \\
%   \bang{\placeholder{\record{\overline{\fieldname{f}_i :: K_i}}}} & = & \placeholder{\record{\overline{\fieldname{f}_i :: K_i}}} & \textsc{Token!} \\
%   \bang{\arraytype{\tau}} & = & \arraytype{\bangP{\tau}} & \textsc{Array!}
%\end{fundef}
%&
%\begin{fundef}{\textbf{bang}'}{\tau \rightarrow \tau}
%   \bangP{\linear{T}} & = & \intu{\bang{T}} & \textsc{Linear!} \\
%   \bangP{\intu{T}} & = & \intu{T} & \textsc{Shareable!} \\
%   \bangP{\unboxed{T}} & = & \unboxed{T} & \textsc{Unboxed!}
%\end{fundef}
%\end{sidebyside}
%\begin{fundef}{\textbf{prepend}}{\tau_r \times \tau \rightarrow \tau_r}
%   \prepend{\succeeds{\overline{\tau}}}{\tau'} & = & \succeeds{\tau',\overline{\tau}} & \textsc{Prepend}_S \\
%   \prepend{\fails{\overline{\tau}}}{\tau'} & = & \fails{\tau',\overline{\tau}} & \textsc{Prepend}_F \\
%   \prepend{\canfail{\overline{\tau_s}}{\overline{\tau_f}}}{\tau'} & = & \canfail{\tau',\overline{\tau_s}}{\tau',\overline{\tau_f}} & \textsc{Prepend} \\
%\end{fundef}
%\subsection{Evaluation Rules}
%
%\newcommand{\eval}[4]{#1 , #2 \vdash #3 \Downarrow #4}
%\newcommand{\evalS}[4]{#1 , #2 \vdash #3 \Downarrow^\star #4}
%
%\begin{inductive}{ \eval{\Sigma}{\gamma}{e}{v}}
%  \inferrule{ }
%            { \eval{\Sigma}{\gamma}{L}{L}}
%            { \textsc{Lit}}
%  \qquad
%  \inferrule{ x \mapsto v \in \gamma }
%            { \eval{\Sigma}{\gamma}{x}{v}}
%            { \textsc{Var}}
%  \qquad
%  \inferrule{ \evalS{\Sigma}{\gamma}{\overline{e_i}}{\overline{v_i}}
%           \\ \opsemantic{o}[\Sigma, \overline{v_i}] = v}
%            { \eval{\Sigma}{\gamma}{o(\overline{e_i})}{v}}
%            { \textsc{Op}}
%\end{inductive}
%\begin{inductive}{ \eval{\Sigma}{\gamma}{s}{\evaled{s}}}
%  \inferrule{ \evalS{\Sigma}{\gamma}{\overline{e_i}}{\overline{v_i}}}
%            { \eval{\Sigma}{\gamma}{f(\overline{e_i})}{f(\overline{v_i})}}
%            { \textsc{App}}
%\quad
%  \inferrule{ \eval{\Sigma}{\gamma}{I}{\evaled{I}}}
%            {\eval{\Sigma}{\gamma}{\for{\overline{x_i}}{I}{s}}{\for{\overline{x_i}}{\evaled{I}}{s}}}
%            {\textsc{For}}
%\\
%  \inferrule{ \eval{\Sigma}{\gamma}{s}{\evaled{s}}}
%            { \eval{\Sigma}{\gamma}{\overline{x} \leftarrow s; C}{\overline{x} \leftarrow \evaled{s}; C}}
%            { \textsc{Bind}}
%  \quad
%    \inferrule{ \eval{\Sigma}{\gamma}{s}{\evaled{s}} }
%            { \eval{\Sigma}{\gamma}{\letbang{\overline{x_i}}{s}{C}}{\letbang{\overline{x_i}}{\evaled{s}}{C}}   }
%            { \textsc{Let!}}
%  \\
%    \inferrule{ \eval{\Sigma}{\gamma}{e_\text{err}}{v_\text{err}} \\ \evalS{\Sigma}{\gamma}{\overline{e}}{\overline{v}}}
%            { \eval{\Sigma}{\gamma}{\fail{e_\text{err}, \overline{e}}}{\fail{v_\text{err},\overline{v}}}}
%            { \textsc{Fail}}
%\quad
%  \inferrule{ \evalS{\Sigma}{\gamma}{\overline{e_i}}{\overline{v_i}}}
%            { \eval{\Sigma}{\gamma}{\return{\overline{e_i}}}{\return{\overline{v_i}}}}
%            { \textsc{Return}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{v}}
%            { \eval{\Sigma}{\gamma}{\open{e}{p}{\record{\overline{f_i = x_i}}}{s} }{\open{v}{p}{\record{\overline{f_i = x_i}}}{s}}}
%            { \textsc{Open}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{v}
%           \\ \evalS{\Sigma}{\gamma}{\overline{e_i}}{\overline{v_i}}}
%            { \eval{\Sigma}{\gamma}{\close{e}{\overline{x_i = e_i}}}{\close{v}{\overline{x_i = v_i}}}}
%            { \textsc{Close}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{\mathtt{True}}
%           \\ \eval{\Sigma}{\gamma}{s_t}{\evaled{s}}}
%            { \eval{\Sigma}{\gamma}{\ifthenelse{e}{s_t}{s_e}}{E}}
%            { \textsc{If}_1}
%  \qquad
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{\mathtt{False}}
%           \\ \eval{\Sigma}{\gamma}{s_e}{\evaled{s}}}
%            { \eval{\Sigma}{\gamma}{\ifthenelse{e}{s_t}{s_e}}{\evaled{s}}}
%            { \textsc{If}_2}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{v}}
%            { \eval{\Sigma}{\gamma}{\case{e}{\overline{\datatag{p}\ x \rightarrow s}}}{\case{v}{\overline{\datatag{p}\ x \rightarrow s}}}}
%            { \textsc{Case}}
%\end{inductive}
%\begin{sidebyside}
%  \begin{center}
%  \textbf{Value Semantics}
%  \end{center}
%  &
%  \begin{center}
%  \textbf{Update Semantics}
%  \end{center}
%\end{sidebyside}
%\begin{sidebyside}
%\begin{inductive}{\eval{\Sigma}{\gamma}{I}{\evaled{I}}}
%  \inferrule{ \evalS{\Sigma}{\gamma}{\overline{e}}{\overline{v}} }
%            { \eval{\Sigma}{\gamma}{\itername{i}(\overline{e})}{\itername{i}(\overline{v})}}
%            { \textsc{Iter}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{v} }
%            { \eval{\Sigma}{\gamma}{\map{e}}{\map{v}}}
%            { \textsc{Map}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{v} }
%            { \eval{\Sigma}{\gamma}{\fold{e}}{\fold{v}}}
%            { \textsc{Fold}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{I}{\evaled{I}} \\ \eval{\Sigma}{\gamma}{e}{v} }
%            { \eval{\Sigma}{\gamma}{\with{I}{e}}{\with{\evaled{I}}{v}}}
%            { \textsc{With}}
%\end{inductive}
%&
%\begin{inductive}{\eval{\Sigma}{\gamma}{I}{\evaled{I}}}
%  \inferrule{ \evalS{\Sigma}{\gamma}{\overline{e}}{\overline{v}} }
%            { \eval{\Sigma}{\gamma}{\itername{i}(\overline{e})}{\itersemantic{i}[\overline{v}]}}
%            { \textsc{Iter}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{\arraytype{\overline{v}}} }
%            { \eval{\Sigma}{\gamma}{\map{e}}{\mapIter{\overline{v},\epsilon}}}
%            { \textsc{Map}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{e}{\arraytype{\overline{v}}} }
%            { \eval{\Sigma}{\gamma}{\fold{e}}{\foldIter{\overline{v}}}}
%            { \textsc{Fold}}
%  \\
%  \inferrule{ \eval{\Sigma}{\gamma}{I}{\evaled{I}} \\ \eval{\Sigma}{\gamma}{e}{v} }
%            { \eval{\Sigma}{\gamma}{\with{I}{e}}{\withIter{\evaled{I},v}}}
%            { \textsc{With}}
%\end{inductive}
%\end{sidebyside}
%\begin{fundef}{\textbf{foldIter}}{\overline{v} \rightarrow \evaled{I}}
%  \foldIter{\epsilon} & = &  \mathtt{inr}\ \epsilon & \textsc{FoldEmpty} \\
%  \foldIter{v\ \overline{v_i}} & = &  \mathtt{inl}\ (v, (\lambda\epsilon.\ \foldIter{\overline{v_i}}), (\lambda v_e.\ v_e)) & \textsc{FoldCons}
%\end{fundef}
%\begin{fundef}{\textbf{mapIter}}{\overline{v} \times \overline{v}  \rightarrow \evaled{I}}
%  \mapIter{\epsilon,\ \overline{v_j}} & = &  \mathtt{inr}\ \arraytype{\overline{v_j}}& \textsc{MapLast} \\
%  \mapIter{v\ \overline{v_i},\ \overline{v_j}} & = &  \mathtt{inl}\ (v, (\lambda v'.\ \mapIter{\overline{v_i},\ \overline{v_j}\ v'} ), (\lambda v_e\ v'.\ v_e\ \arraytype{\overline{v_j}\ v'\ \overline{v_i}})) & \textsc{MapCons}
%\end{fundef}
%\begin{fundef}{\textbf{withIter}}{\overline{v} \times \evaled{I} \rightarrow \evaled{I}}
%  \withIter{v,\ \mathtt{inr}\ \overline{v_i}} & = & \mathtt{inr}\ \overline{v_i}\ v & \textsc{Term} \\
%  \withIter{v,\ \mathtt{inl}\ (\overline{v_j}, f, g)} & = & \mathtt{inl}\ (\overline{v_j}\ v, \lambda \overline{x_s}\ x.\ \withIter{x,f[\overline{x_s}]},  \lambda \overline{x_f}\ x.\  (g[\overline{x_f}]\ x) & \textsc{Cont} \\
%\end{fundef}
%\begin{verbatim}
%\subsection{Algorithmic Typing Rules}
%\begin{inductive}{\useVar{x : \tau}{\Gamma}{\Gamma'}}
%  \inferrule{ x : \tau \in \Gamma \\ \tau =    \intu{\primtype{T}} }{\useVar{x : \tau}{\Gamma}{\Gamma}}
%  \qquad
%  \inferrule{ x : \tau \in \Gamma \\ \tau =    \unboxed{\primtype{t}} }{\useVar{x : \tau}{\Gamma}{\Gamma}}
%  \qquad
%  \inferrule{ x : \tau \in \Gamma \\ \tau \neq \intu{\primtype{T}} \\ \tau \neq \unboxed{\primtype{t}}}{\useVar{x : \tau}{x : \tau,\Gamma}{\Gamma}}
%\end{inductive}
%
%\begin{inductive}{\typing{\Gamma}{e}{\tau}{\Gamma'}}
%  \inferrule{ \litType{L} = \primtype{t}}
%            { \typing{\Gamma}{L}{\unboxed{\primtype{t}}}{\Gamma}}
%            { \textsc{Lit}}
%  \qquad
%  \inferrule{ \useVar{x : \tau}{\Gamma}{\Gamma'} }
%            { \typing{\Gamma}{x}{\tau}{\Gamma'}}
%            { \textsc{Var}}
%  \qquad
%  \inferrule{ \opType{o} = (\overline{\tau_i} \rightarrow \tau)
%           \\ \typingS{\Gamma}{\overline{e_i}}{\overline{\tau_i}}{\Gamma'}}
%            { \typing{\Gamma}{o(\overline{e_i})}{\tau  }{\Gamma}}
%            { \textsc{Op}}
%\end{inductive}
%\begin{inductive}{\typing{\Gamma}{s}{\tau_m}{\Gamma'}}
%  \inferrule{ \funcType{f} = (\overline{\tau_i} \rightarrow \tau_m)
%           \\ \typingS{\Gamma}{\overline{e_i}}{\overline{\tau_i}}{\Gamma'}}
%            { \typing{\Gamma}{f(\overline{e_i})}{\tau_m}{\Gamma'}}
%            { \textsc{App}}
%  \\
%  \inferrule{ \typing{\Gamma}{e}{\tau}{\Gamma'}
%           \\ \tau = \record{\overline{x_i :: \tau_i}}}
%            { \typing{\Gamma}{\open{e}}{\M\ (\placeholder{\tau},\overline{\tau_i})}{\Gamma'}}
%            { \textsc{Open}}
%  \qquad
%  \inferrule{ \typing{\Gamma}{e}{\placeholder{\tau}}{\Gamma'}
%          \\ \tau = \record{\overline{x_i :: \tau_i}}
%          \\ \typingS{\Gamma'}{\overline{e_i}}{\overline{\tau_i}}{\Gamma''}}
%            { \typing{\Gamma}{\close{e}{\overline{x_i = e_i}}}{\M\ \tau}{\Gamma''}}
%            { \textsc{Close} }
%  \\
%  \inferrule{ \typing{\Gamma}{s}{m\ \overline{\tau_i}}{\Gamma'}
%           \\ \{\overline{x_i : \tau_i}\} \stackrel{\star}{\leadsto} R
%           \\ \typing{\overline{x_i : \tau_i},\Gamma'}{s'}{m\ \overline{\tau_j}}{R\Gamma''}
%           \\ \Gamma'' \subseteq \Gamma'}
%            { \typing{\Gamma}{\overline{x_i}\leftarrow s; s'}{m\ \overline{\tau_j}}{\Gamma''}}
%            { \textsc{Bind} }
%  \\
%%  \inferrule{ \typing{\Gamma}{s}{m\ ()}{\Gamma'}
%%           \\ \typing{\Gamma'}{s'}{m\ \overline{\tau_j}}{\Gamma''} }
%%            { \typing{\Gamma}{s; s'}{m\ \overline{\tau_j}}{\Gamma''}}
%%            { \textsc{Seq} }
%%  \qquad
%  \inferrule{ \typingS{\Gamma}{\overline{e_i}}{\overline{\tau_i}}{\Gamma'} }
%            { \typing{\Gamma}{\return{\overline{e_i}}}{m\ \overline{\tau_i}}{\Gamma'}}
%            { \textsc{Return} }
%  \qquad
%  \inferrule{ \typing{\Gamma}{e}{\intu{\primtype{Bool}}}{\Gamma'}
%           \\ \typing{\Gamma'}{s_t}{m\ \overline{\tau_i}}{\Gamma''}
%           \\ \typing{\Gamma'}{s_e}{m\ \overline{\tau_i}}{\Gamma''}}
%            { \typing{\Gamma}{\ifthenelse{e}{s_t}{s_e}}{m\ \overline{\tau_i}}{\Gamma''}}
%            { \textsc{If}}
%  \\
%  \inferrule{ \typing{\Gamma}{e}{\variant{\overline{\datatag{p}_i :: \tau_i}}}{\Gamma'}
%           \\ \text{for each $i$:}\ \typing{x_i : \tau_i,\Gamma'}{s_i}{m\ \overline{\tau_r}}{\Gamma''}}
%            { \typing{\Gamma}{\case{e}{\overline{\datatag{p}_i\ x_i \rightarrow s_i}}}{m\ (\variant{\overline{\datatag{p}_i :: \tau_i}} ,\overline{\tau_r})}{\Gamma''}}
%            { \textsc{Case}}
%  \\
%  \inferrule{ \typing{\Gamma}{e}{\unboxed{\primtype{err}}}{\Gamma'} }
%            { \typing{\Gamma}{\throw{e}}{\ME\ \overline{\tau}}{\Gamma'}}
%            { \textsc{Raise} }
%  \qquad
%  \inferrule{ \typing{\Gamma}{s}{\M\  \overline{\tau_i}}{\Gamma'}}
%            { \typing{\Gamma}{s}{\ME\ \overline{\tau_i}}{\Gamma'}}
%            { \textsc{Coerce}}
%  \\
%  \inferrule{ \typing{\Gamma}{s}{\ME\ \overline{\tau_i}}{\Gamma'}
%           \\ \typing{x : \unboxed{\primtype{err}}, \Gamma'}{s_c}{\ME\ \overline{\tau_i}}{x : \unboxed{\primtype{err}}, \Gamma''}}
%            { \typing{\Gamma}{\try{s}{x}{s_c}}{\M\ \overline{\tau}}{\Gamma''}}
%            { \textsc{Try} }
%  \\
%  \inferrule{ \typing{\overline{x_i : \intu{\primtype{T}_i}},\Gamma}{e}{\unboxed{\primtype{t}}}{\overline{x_i : \intu{\primtype{T}_i}},\Gamma'}
%           \\ \typing{\overline{x_i : \linear{\primtype{T}_i}}, y : \unboxed{\primtype{t}}, \Gamma'}{s}{m\ \overline{\tau}}{y : \unboxed{\primtype{t}},\Gamma''}}
%            { \typing{\overline{x_i : \linear{\primtype{T}_i}},\Gamma}{\letbang{\overline{x_i}}{y}{e}{s}}{m\ \overline{\tau} }{\Gamma''}}
%            {\textsc{Let!}}
%\end{inductive}
%
%\subsection{Execution Rules}
%\newcommand{\smallstepV}[5]{#1 \vdash (#2, #3) \mapsto (#4, #5)}
%\newcommand{\smallstep}[7]{#1 \vdash (#2, #3, #4) \mapsto (#5, #6, #7)}
%\begin{sidebyside}
%  \begin{center}
%  \textbf{Value Semantics}
%  \end{center}
%  &
%  \begin{center}
%  \textbf{Update Semantics}
%  \end{center}
%\end{sidebyside}
%\begin{sidebyside}
%    \scriptsize
%  \begin{inductive}{\smallstepV{\gamma}{W}{E}{W'}{E'}}
%    \inferrule{\funcsemantic{f}[\epsilon, W, \overline{v}] = (\epsilon, W', \overline{v_r})}
%              {\smallstepV{\gamma}{W}{f(\overline{v})}{W'}{\return{\overline{v_r}}}}
%              {\textsc{App}}
%    \\
%    \inferrule{\smallstepV{\gamma}{W}{E}{W'}{E'}}
%              {\smallstepV{\gamma}{W}{\overline{x} \leftarrow E; s}{W'}{\overline{x} \leftarrow E'; s}}
%              {\textsc{Bind}_1}
%    \\
%    \inferrule{ \eval{\epsilon}{\overline{x_i \mapsto v_i}, \gamma}{s}{E}}
%              {\smallstepV{\gamma}{W}{\overline{x_i} \leftarrow \return{\overline{v_i}}; s}{W}{\using{\overline{x_i \mapsto v_i}}{E}}}
%              {\textsc{Bind}_2}
%    \\
%    \inferrule{\smallstepV{\overline{x_i \mapsto v_i}, \gamma}{W}{E}{W'}{E'} }
%              {\smallstepV{\gamma}{W}{\using{\overline{x_i \mapsto v_i}}{E}}{W'}{\using{\overline{x_i \mapsto v_i}}{E'}} }
%              {\textsc{Using}_1}
%    \\
%    \inferrule{ \quad }
%              {\smallstepV{\gamma}{W}{\using{\overline{x_i \mapsto v_i}}{(\return{\overline{v_r}})}}{W}{\return{\overline{v_r}}} }
%              {\textsc{Using}_2}
%    \\
%    \inferrule{ \quad }
%              {\smallstepV{\gamma}{W}{\using{\overline{x_i \mapsto v_i}}{(\throw{v_e})}}{W}{\throw{v_e}} }
%              {\textsc{Using}_3}
%    \\
%%    \inferrule{\smallstepV{\gamma}{W}{E}{\gamma'}{W'}{E'}}
%%              {\smallstepV{\gamma}{W}{E; s}{\gamma}{W'}{E'; s}}
%%              {\textsc{Seq}_1}
%%    \\
%%    \inferrule{ }
%%              {\smallstepV{\gamma}{W}{\return{()}; s}{\gamma}{W}{s}}
%%              {\textsc{Seq}_2}
%    \inferrule{ \quad }
%              {\smallstepV{\gamma}{W}{\overline{x_i} \leftarrow \throw{v_c}; s}{W}{\throw{v_c}}}
%              {\textsc{Raise}}
%    \\
%    \inferrule{ \smallstepV{\gamma}{W}{E}{W'}{E'}}
%              { \smallstepV{\gamma}{W}{\try{E}{x}{s_c}} { W'} {\try{E'}{x}{s_c}}}
%              { \textsc{Try}_1}
%    \\
%    \inferrule{ \eval{\epsilon}{x \mapsto v, \gamma}{s_c}{E}}
%              { \smallstepV{\gamma}{W}{\try{(\throw{v})}{x}{s_c}} { W} {\using{x \mapsto v}{E}}}
%              { \textsc{Try}_2}
%    \\
%    \inferrule{  \quad }
%              { \smallstepV{\gamma}{W}{\try{(\return{\overline{v}})}{x}{s_c}}{ W}{\return{\overline{v}}}}
%              { \textsc{Try}_3}
%    \\
%    \inferrule{ \quad }
%              { \smallstepV{\gamma}{W}{\open{\record{\overline{x_i = v_i}}}}{W}{\return{(\top,\overline{v_i})}}}
%              { \textsc{Open}}
%    \\
%    \inferrule{ \quad }
%              { \smallstepV{\gamma}{W}{\close{\top}{\overline{x_i = v_i}}}{W}{\return{\record{\overline{x_i = v_i}}}}}
%              { \textsc{Close}}
%    \\
%    \inferrule{ \eval{\epsilon}{x_k \mapsto v, \cup \gamma}{s_k}{E}}
%              { \smallstepV{\gamma}{W}{\case{\variant{\datatag{p}_k, v}}{\overline{\datatag{p}_i\ x_i \mapsto s_i}}}{W}{\using{x_k \mapsto v}{E}}}
%              { \textsc{Case}}
%  \end{inductive}
%  &
%      \scriptsize
%  \begin{inductive}{\smallstep{\gamma}{\Sigma}{W}{E}{\Sigma'}{W'}{E'}}
%    \inferrule{\funcsemantic{f}[\Sigma, W, \overline{v}] = (\Sigma', W', \overline{v_r})}
%              {\smallstep{\gamma}{\Sigma}{W}{f(\overline{v})}{\Sigma'}{W'}{\return{\overline{v_r}}}}
%              {\textsc{App}}
%    \\
%    \inferrule{\smallstep{\gamma}{\Sigma}{W}{E}{\Sigma'}{W'}{E'}}
%              {\smallstep{\gamma}{\Sigma}{W}{\overline{x} \leftarrow E; s}{\Sigma'}{W'}{\overline{x} \leftarrow E'; s}}
%              {\textsc{Bind}_1}
%    \\
%    \inferrule{ \eval{\Sigma}{\overline{x_i \mapsto v_i}, \gamma}{s}{E}}
%              {\smallstep{\gamma}{\Sigma}{W}{\overline{x_i} \leftarrow \return{\overline{v_i}}; s}{\Sigma}{W}{\using{\overline{x_i \mapsto v_i}}{E}}}
%              {\textsc{Bind}_2}
%    \\
%    \inferrule{\smallstep{\overline{x_i \mapsto v_i}, \gamma}{\Sigma}{W}{E}{\Sigma'}{W'}{E'} }
%              {\smallstep{\gamma}{\Sigma}{W}{\using{\overline{x_i \mapsto v_i}}{E}}{\Sigma'}{W'}{\using{\overline{x_i \mapsto v_i}}{E'}} }
%              {\textsc{Using}_1}
%    \\
%    \inferrule{ \quad }
%              {\smallstep{\gamma}{\Sigma}{W}{\using{\overline{x_i \mapsto v_i}}{(\return{\overline{v_r}})}}{\Sigma}{W}{\return{\overline{v_r}}} }
%              {\textsc{Using}_2}
%    \\
%    \inferrule{ \quad }
%              {\smallstep{\gamma}{\Sigma}{W}{\using{\overline{x_i \mapsto v_i}}{(\throw{v_e})}}{\Sigma}{W}{\throw{v_e}} }
%              {\textsc{Using}_3}
%    \\
%    \inferrule{ \quad }
%              {\smallstep{\gamma}{\Sigma}{W}{\overline{x_i} \leftarrow \throw{v_c}; s}{\Sigma}{W}{\throw{v_c}}}
%              {\textsc{Raise}}
%    \\
%    \inferrule{ \smallstep{\gamma}{\Sigma}{W}{E}{\Sigma'}{W'}{E'}}
%              { \smallstep{\gamma}{\Sigma}{W}{\try{E}{x}{s_c}}{\Sigma'}{ W'} {\try{E'}{x}{s_c}}}
%              { \textsc{Try}_1}
%    \\
%    \inferrule{ \eval{\Sigma}{x \mapsto v, \gamma}{s_c}{E}}
%              { \smallstep{\gamma}{\Sigma}{W}{\try{(\throw{v})}{x}{s_c}}{\Sigma}{ W} {\using{x \mapsto v}{E}}}
%              { \textsc{Try}_2}
%    \\
%    \inferrule{ \quad }
%              { \smallstep{\gamma}{\Sigma}{W}{\try{(\return{\overline{v}})}{x}{s_c}}{\Sigma}{ W}{\return{\overline{v}}}}
%              { \textsc{Try}_3}
%    \\
%%    \inferrule{\smallstep{\Sigma}{\gamma}{W}{E}{\Sigma'}{\gamma'}{W'}{E'}}
%%              {\smallstep{\Sigma}{\gamma}{W}{E; s}{\Sigma'}{\gamma}{W'}{E'; s}}
%%              {\textsc{Seq}_1}
%%    \\
%%    \inferrule{ }
%%              {\smallstep{\Sigma}{\gamma}{W}{\return{()}; s}{\Sigma}{\gamma}{W}{s}}
%%              {\textsc{Seq}_2}
%    \inferrule{ \Sigma[\ell] = \record{\overline{x_i = v_i}}}
%              { \smallstep{\gamma}{\Sigma}{W}{\open{\ell}}{\Sigma}{W}{\return{(\placeholder{\ell},\overline{v_i})}}}
%              { \textsc{Open}}
%    \\
%    \inferrule{ \Sigma' = (\Sigma[\ell] := \record{\overline{x_i = v_i}})}
%              { \smallstep{\gamma}{\Sigma}{W}{\close{(\placeholder{\ell})}{\overline{x_i = v_i}}}{\Sigma'}{W}{\return{\ell}}}
%              { \textsc{Close}}
%    \\
%    \inferrule{ \eval{\Sigma}{x_k \mapsto v, \gamma}{s_k}{E}}
%              { \smallstep{\gamma}{\Sigma}{W}{\case{\variant{\datatag{p}_k, v}}{\overline{\datatag{p}_i\ x_i \mapsto s_i}}}{\Sigma}{W}{\using{x_k \mapsto v}{E}}}
%              { \textsc{Case}}
%  \end{inductive}
%\end{sidebyside}
%\subsection{State Typing}
%\newcommand{\valtype}[2]{\Sigma \vdash #1 : #2 }
%\newcommand{\valtypeS}[2]{\Sigma \vdash #1 :^\star #2 }
%\newcommand{\valtypeE}[4]{#1; #2 \vdash #3 : #4}
%\begin{sidebyside}
%\begin{inductive}{\valtype{v}{\tau}}
%  \inferrule{ }
%            { \valtype{L}{\unboxed{\litType{L}}}}
%            { \textsc{Lit}}
%  \\
%  \inferrule{ \valtype{v}{\tau}  \\ (\datatag{p} :: \tau) \in (\overline{\datatag{p}_i :: \tau_i})}
%            { \valtype{\variant{\datatag{p}, v}}{\variant{\overline{\datatag{p}_i :: \tau_i}}}}
%            { \textsc{Sum}}
%  \\
%  \inferrule{ \valtypeS{\overline{v_i}}{\overline{\tau_i}} }
%            { \valtype{\record{\overline{x_i = v_i}}}{\record{\overline{x_i :: \tau_i}}}}
%            { \textsc{Prod}}
%  \\
%  \inferrule{  }
%            { \valtype{\top}{\placeholder{\tau}}}
%            { \textsc{Token}}
%  \\
%  \inferrule{ \quad }
%            { \valtype{a}{\intu{\absType{\epsilon, a}}} }
%            { \intu{\textsc{Abstr}}}
%  \\
%  \inferrule{ \quad }
%            { \valtype{a}{\linear{\absType{\epsilon, a}}} }
%            { \linear{\textsc{Abstr}}}
%\end{inductive}
%&
%\begin{inductive}{\valtype{v}{\tau}}
%  \inferrule{ }
%            {\valtype{L}{\unboxed{\litType{L}}}}
%            {\textsc{Lit}}
%  \\
%  \inferrule{ \Sigma[\ell] = \variant{\datatag{p}, v}\\ \valtype{v}{\tau}  \\ (\datatag{p} :: \tau) \in (\overline{\datatag{p}_i :: \tau_i})}
%            { \valtype{\ell}{\variant{\overline{\datatag{p}_i :: \tau_i}}}}
%            { \textsc{Sum}}
%  \\
%  \inferrule{ \Sigma[\ell] = \record{\overline{x_i = v_i}} \\ \valtypeS{\overline{v_i}}
%            {\overline{\tau_i}} }{\valtype{\ell}{\record{\overline{x_i :: \tau_i}}}}
%            {\textsc{Prod}}
%  \\
%  \inferrule{  }
%            { \valtype{\placeholder{\ell}}{\placeholder{\tau}}}
%            {\textsc{Token}}
%  \\
%  \inferrule{ \Sigma[\ell] = a }
%            { \valtype{\ell}{\intu{\absType{\Sigma, a}}} }
%            { \intu{\textsc{Abstr}}}
%  \\
%  \inferrule{ \Sigma[\ell] = a }
%            { \valtype{a}{\linear{\absType{\Sigma, a}}} }
%            { \linear{\textsc{Abstr}}}
%\end{inductive}
%\end{sidebyside}
%
%TODO: Fix below
%\begin{inductive}{\valtypeE{\Gamma}{\Sigma}{E}{\tau_m}}
%  \inferrule{ \funcType{f} = \overline{\tau_i} \rightarrow \tau_m  \\ \valtypeS{\overline{v}}{\overline{\tau_i}}}
%            { \valtypeE{\Gamma}{\Sigma}{f(\overline{v})}{\tau_m}}
%            { \textsc{App}}
%  \\
%  \inferrule{ \valtype{v}{\tau} \\ \tau = \record{\overline{x_i :: \tau_i}}}
%            { \valtypeE{\Gamma}{\Sigma}{\open{v}}{\M\ (\placeholder{\tau},\overline{\tau_i})}}
%            { \textsc{Open}}
%  \qquad
%  \inferrule{ \valtype{v}{\placeholder{\record{\overline{x_i :: \tau_i}}}} \\ \valtypeS{\overline{v_i}}{\overline{\tau_i}} }
%            { \valtypeE{\Gamma}{\Sigma}{\close{v}{\overline{x_i = v_i}}}{\M\ \record{\overline{x_i :: \tau_i}}}}
%            { \textsc{Close}}
%  \\
%  \inferrule{ \valtypeE{\Gamma}{\Sigma}{E}{m\ \overline{\tau_i}} \\ \types{\overline{x_i : \tau_i},\Gamma'}{s}{m\ \tau}}
%            { \valtypeE{\Gamma\Gamma'}{\Sigma}{\overline{x_i} \leftarrow E; s}{m\ \tau}}
%            { \textsc{Bind}}
%  \qquad
%  \inferrule{ \valtypeS{\overline{v_i}}{\overline{\tau_i}}}
%            { \valtypeE{\Gamma}{\Sigma}{\return{\overline{v_i}}}{m\ \overline{\tau_i}}}
%            { \textsc{Return}}
%  \\
%  \inferrule{ \valtypeE{\Gamma}{\Sigma}{E}{m\ \overline{\tau}} \\ \types{x : \unboxed{\primtype{err}}, \Gamma'}{s}{m\ \overline{\tau}} }
%            { \valtypeE{\Gamma\Gamma'}{\Sigma}{\try{E}{x}{s}}{m\ \overline{\tau}}}
%            { \textsc{Try}}
%  \qquad
%  \inferrule{ \valtype{v}{\unboxed{\primtype{err}}}}
%            { \valtypeE{\Gamma}{\Sigma}{\throw{v}}{\ME\ \overline{\tau}}}
%            { \textsc{Raise}}
%  \\
%  \inferrule{ \valtype{v}{\variant{\overline{\datatag{p}_i :: \tau_i}}} \\ \text{for each $i$,}\ \types{x_i : \tau_i, \Gamma'}{s_i}{m\ \overline{\tau}} }
%            { \valtypeE{\Gamma\Gamma'}{\Sigma}{\case{v}{\overline{\datatag{p}_i\ x_i \rightarrow s_i}}}{m\ \overline{\tau}}}
%            { \textsc{Case}}
%  \\
%  \inferrule{ \valtypeE{\Gamma}{\Sigma}{E}{\M\ \overline{\tau_i}}}
%            { \valtypeE{\Gamma}{\Sigma}{E}{\ME\ \overline{\tau_i}}}
%            { \textsc{Coerce}}
%  \qquad
%  \inferrule{ \valtypeS{\overline{v_i}}{\overline{\tau_i}} \\ \valtypeE{\overline{x_i : \tau_i}, \Gamma'}{\Sigma}{E}{m\ \overline{\tau}} }
%            { \valtypeE{\Gamma\Gamma'}{\Sigma}{\using{\overline{x_i \mapsto v_i}}{E}}{m\ \overline{\tau}} }
%            { \textsc{Using}}
%  \\
%  \inferrule{ \valtypeE{\Gamma, x : \intu{\primtype{T}}, x : \intu{\primtype{T}}}{\Sigma}{s}{\tau_m} }
%            { \valtypeE{\Gamma, x : \intu{\primtype{T}}}{\Sigma}{s}{\tau_m} }
%            { \textsc{Contr}}
%  \qquad
%  \inferrule{ \valtypeE{\Gamma}{\Sigma}{s}{\tau_m} }
%            { \valtypeE{\Gamma, x : \intu{\primtype{T}}}{\Sigma}{s}{\tau_m} }
%            { \textsc{Weak}}
%  \\
%  \inferrule{ \valtypeE{\Gamma, x : \unboxed{\primtype{t}}, x : \unboxed{\primtype{t}}}{\Sigma}{s}{\tau_m} }
%            { \valtypeE{\Gamma, x : \unboxed{\primtype{t}}}{\Sigma}{s}{\tau_m} }
%            { \textsc{Contr}^\sharp}
%  \qquad
%  \inferrule{ \valtypeE{\Gamma}{\Sigma}{s}{\tau_m} }
%            { \valtypeE{\Gamma, x : \unboxed{\primtype{t}}}{\Sigma}{s}{\tau_m} }
%            { \textsc{Weak}^\sharp}
%  \qquad
%  \inferrule{ \valtypeE{\Gamma, x : \linear{\primtype{t}}, x : \unboxed{\primtype{t}}}{\Sigma}{s}{\tau_m} }
%            { \valtypeE{\Gamma, x : \linear{\primtype{t}}}{\Sigma}{s}{\tau_m} }
%            { \textsc{Copy}}
%\end{inductive}
%\subsection{Definitely provable things}
%\begin{itemize}
%  \item \textbf{Algorithmic typing correctness}: $ \typing{\Gamma}{s}{\tau_m}{\Gamma'} $ implies $ \types{\Delta}{s}{\tau_m}$ where $\Delta = \Gamma \setminus \Gamma'$. Requires:
%  \begin{itemize}
%    \item $ \typing{\Gamma}{e}{\tau}{\Gamma'} \implies \types{\Delta}{e}{\tau}$
%  \end{itemize}
%  \item \textbf{Type soundness w.r.t. evaluation}: Let $\gamma$ be an environment $\overline{x_i \mapsto v_i}$. Let $\Gamma$ be a type environment $\overline{x_i : \tau_i}$. We shall use the term that $\Gamma$ \emph{describes} $\gamma$ if $\valtypeS{\overline{v_i}}{\overline{\tau_i}}$. If $\Gamma$ describes $\gamma$ and $\types{\Gamma}{s}{\tau_m}$, then:
%  \begin{itemize}
%    \item $\eval{\Sigma}{\gamma}{s}{E}$, and
%    \item $\valtypeE{\Gamma}{\Sigma}{E}{\tau_m}$
%  \end{itemize}
%  Requires:
%  \begin{itemize}
%    \item A similar proof for expressions: $\Gamma\ \text{describes}\ \gamma \land \types{\Gamma}{e}{\tau} \implies \eval{\Sigma}{\gamma}{e}{v} \land \valtype{v}{\tau}$
%  \end{itemize}
%  \item \textbf{Execution progress (value semantics):} If $\Gamma\ \text{describes}\ \gamma$ and $\valtypeE{\Gamma}{\epsilon}{E}{\tau_m}$ then there exists a $W'$ and $E'$ such that $\smallstepV{\gamma}{W}{E}{W'}{E'}$
%  \item \textbf{Execution progress (update semantics):} If $\Gamma\ \text{describes}\ \gamma$ and $\valtypeE{\Gamma}{\Sigma}{E}{\tau_m}$ then there exists a $\Sigma'$, $W'$ and $E'$ such that $\smallstep{\gamma}{\Sigma}{W}{E}{\Sigma'}{W'}{E'}$.
%  \item \textbf{Execution preservation (value semantics):} If $\Gamma\ \text{describes}\ \gamma$ and $\valtypeE{\Gamma}{\epsilon}{E}{\tau_m}$ and $\smallstepV{\gamma}{W}{E}{W'}{E'}$ then
%    $\valtypeE{\Gamma}{\epsilon}{E'}{\tau_m}$.
%  \item \textbf{Execution preservation (update semantics):} If $\Gamma\ \text{describes}\ \gamma$ and $\valtypeE{\Gamma}{\Sigma}{E}{\tau_m}$ and $\smallstep{\gamma}{\Sigma}{W}{E}{\Sigma'}{W'}{E'}$ then $\valtypeE{\Gamma}{\Sigma'}{E'}{\tau_m}$.
%\end{itemize}
%
%\subsection{Braindead speculation}
%\textbf{Areas to tackle:}
%\begin{itemize}
%  \item General properties:
%  \begin{itemize}
%    \item Shareable values ($\intu{\primtype{T}}$) are never present in the same context as their linear equivalents. We might be able to get away with saying they're never in an execution context at all, as they're only introduced by let!.
%  \end{itemize}
%  \item Update semantics properties. Not sure these would be necessary to relate the two semantics, as they're stronger statements (\emph{all} data, not just data I'm accessing right now). Still, it'd be nice to generate proofs of this, because it shows that the C is not only correct with respect to its results but also in terms of memory management (in particular, freeing stuff).
%  \begin{itemize}
%    \item All allocated data is reachable. Reachable is defined inductively as: mentioned in the environment, an expression, or from a value that is itself reachable. Would have to demand proofs of this from abstract functions.
%    \item All reachable data is allocated. No invalid pointers.
%    \item No linear-typed value is reachable in more than one way.
%  \end{itemize}
%  \item Relating the two semantics:
%  \begin{itemize}
%    \item Firstly we'll need some value relation that says that some $(\Sigma, v_u) \sim v_v$ where $v_u$ is a value in the update semantics, and $v_v$ is a value in the value semantics. Broadly this will mean that they are equivalent in some sense. This could be broadened easily to whole environments, as well as $E$'s, because they are little more than structure around a bunch of values.
%    \item Show that one step of execution in both semantics preserves all of these relations.
%    \item Show that state typing implies all of these relations in both semantics (assuming wellformed and matching environments).
%    \item Show that the outside-worlds are also equivalent/equal as evaluation progresses.
%    \item Equivalence proof done :D
%  \end{itemize}
%\end{itemize}
%
%\end{verbatim}
%
%
%\subsection{Linear Values}
%Linear types are tagged to be either allocated (and therefore freeable) or checked out (and can therefore be checked in). Functions can be polymorphic on the tag, which means that they neither free nor check-in the value. Tags are inferred, never provided by the user.
%
%\begin{itemize}
%\item A linearA value in the argument: function will de-allocate value
%\item A linearC value in the argument: function will check-in value
%\item A linear value in the argument: function can neither check in nor free value
%\item A linearA value in the result: function allocated value
%\item A linearC value in the result: function checked value out
%\item A linear value in the result: function updated value passed in
%\end{itemize}
%
%Problem: if we allow to check out different parts of the state, can we make sure there is no aliasing?
%
%
%\subsection{Error Handling}
%
%Functions which may return errors have type:
%\begin{grammar}
%ME \tau = M (!Either \tau  (Error, linearC \tau))
%\end{grammar}
%where
%\begin{grammar}
%linearC (\linear{\tau}) = \tau \\
%linearC (\linearAlloc{\tau}) = \{\} \\
%linearC (\linearCheckout{\tau}) = \{\} \\
%linearC (\{\overline{\tau_i}\}) = \cup \overline{linearC ({\tau_i})} \\
%linearC (t) = \{\}
%\end{grammar}
%This means that an error function has to return all linear values it has not allocated nor checked out, and free or check in all others (this could happen automatically).
%
%\begin{alltt}
%>>=E :: M tau -> (tau -> ME tau') -> ME tau'
%>>=E' :: ME tau -> (tau -> ME tau') -> ME tau'
%raiseErr :: Bool -> M (linearC tau') -> M tau' -> ME tau'
%handleErr :: ME tau -> (tau -> M tau') -> (linearC tau -> M tau') -> M tau'
%\end{alltt}
%
%\begin{alltt}
%simpleobj_example (so : A.SimpleObj) : ME A.SimpleObj
%= { buf          <- buf_create(42)
%  ; buf, so      <- simpleobj_serialise(buf,so,0)
%  ; so2          <- simpleobj_new('_',0)
%  ; buf, so2     <- simpleobj_unserialise(buf, so2, 0)
%  ; so' , a1, b1 <- open so
%  ; so2', a2, b2 <- open so2
%  ; raiseErr not(a1 == a2 && b1 == b2)
%     { free (so2)
%     ; free (buff)
%     ; return ()
%  }
%  ; so2 <- close so2' {a = a2, b = b2}
%  ; so  <- close so'  {a = a1, b = b1}
%  ; simpleobj_free (so)
%  ; buf_free(buf)
%  ; return so2
%  }
%\end{alltt}

%\bibliographystyle{alpha}
\bibliographystyle{plain}

\bibliography{references}


\end{document}
