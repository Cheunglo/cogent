-- Tests recursive types
#ifndef COGENT_LIST_LIB
#define COGENT_LIST_LIB

include <gum/common/common.cogent>

type ListNode a = 
  rec t { 
    l: < 
      Nil 
    | Cons (a,t) 
    > 
  }

type EmptyListNode a = (ListNode a) take (..)

type List a = 
  #{
    size: U64,
    list: ListNode a
  }

------------- Allocation and deallocation -------------

-- TODO: All functions that call these two abstract functions need to take in SysState
alloc_list_node : all a. () -> EmptyListNode a
list_free_node : all a. EmptyListNode a -> ()

-- Deallocates an entire list and all the elements inside
list_free : all a. (List a, a -> ()) -> ()
list_free (r { list = x }, f) = list_free' (x, f)

list_free' : all a. (ListNode a, a -> ()) -> ()
list_free' (r, f) =
  let r2 { l = x } = r
  and _ = list_free_node r2 in
    x | Nil               -> ()
      | Cons (elem, rest) ->
        let _ = f elem in list_free' (rest, f)

------------- List basic -------------

-- Adds an element to the front of the list
-- Returns the updated list
list_cons : all a. (a, List a) -> List a
list_cons (x, r) = 
  let #{ list = y, size = s } = r
  and node = (alloc_list_node ()) { l = Cons (x,y) }
  in #{ list = node, size = s + 1 }

-- Removes the first element of the list if it exists
-- Returns the element if it exists and the resulting list
list_head : all a. List a -> (Option a, List a)
list_head r =
  let #{ list = l, size = s } = r
  and l' { l = x } = l
  in
    x | Nil -> (None, #{ list = (l' { l = Nil }), size = s })
      | Cons (elem, rest) ->
        let _ = list_free_node l' in
          (Some elem, #{ list = rest, size = s-1 })

-- Appends two lists (the second on the end of the first)
-- Returns the appended list
list_append : all a. (List a, List a) -> List a
list_append (r1, r2) =
  let #{ size = s1, list = l1 } = r1
  and #{ size = s2, list = l2 } = r2
  and appended = list_append' (l1,l2)
  in #{ size = s1 + s2, list = appended }

list_append' : all a. (ListNode a, ListNode a) -> ListNode a
list_append' (head { l = x }, b) =
  x | Nil -> 
        let _ = list_free_node head in b
    | Cons (elem, tail) -> 
        let rest = list_append' (tail, b)
        in head { l = Cons (elem, rest) }


------------- List Transformations -------------

-- Maps all elements in a list to a new element
-- Returns the updated list
-- This reallocates every node in the list
list_map : all (a, b). ((a! -> b), (List a)!) -> List b
list_map (f, r) = 
  let #{ list = y } = r
  and x = list_map'[a,b] (f, y)
  in #{ list = x, size = r.size }

list_map' : all (a, b). ((a! -> b), (ListNode a)!) -> ListNode b
list_map' (f, head) =
  let node = alloc_list_node[b] () in
    head.l | Nil -> node { l = Nil }
           | Cons (elem, tail) ->
               node { l = Cons (f elem, list_map'[a,b] (f, tail)) }

-- Maps all elements in place, requiring that the mapped elements are the same type
-- Returns the updated list
-- This does NOT allocate a new list
list_map_in_place : all (a :< E). ((a -> a), (List a)) -> List a
list_map_in_place (f, r) =
  let #{ list = y, size = s } = r
  and x = list_map_in_place'[a] (f,y)
  in  #{ list = x, size = s }

list_map_in_place' : all (a :< E). ((a -> a), (ListNode a)) -> ListNode a
list_map_in_place' (f, head) =
    let head { l = x } = head in 
      x | Nil -> head { l = Nil }
        | Cons (elem, tail) ->
            head { l = Cons (f elem, list_map_in_place'[a] (f, tail)) }

-- Reverses a list
-- Returns the reversed list
list_reverse : all a. List a -> List a
list_reverse r = 
  let #{ size, list } = r
  and list = list_reverse'[a] (list, (alloc_list_node ()) { l = Nil })
  in #{ size, list }

list_reverse' : all a. (ListNode a, ListNode a) -> ListNode a
list_reverse' (head { l }, acc) =
  l | Nil  -> 
      let _ = list_free_node head
      in acc
    | Cons (elem, rest) ->
      list_reverse'[a] (rest, head { l = Cons (elem, acc) } )

------------- List Qualities -------------

-- Returns true if a list is empty
list_empty : all a. (List a)! -> Bool
list_empty r = let #{ size } = r in size == 0

-- Returns the length of the list
list_length : all a. (List a)! -> U64
list_length r = let #{ size } = r in size

-- Checks if two lists are equal given an element comparison function
-- Returns True if they are equal, false otherwise
list_equal : all a. ((List a)!, (List a)!, (a!,a!) -> Bool) -> Bool
list_equal (x, y, f) = 
  let #{ size = s1, list = l1 } = x
  and #{ size = s2, list = l2 } = y
  in (s1 == s2) | False -> False
                | True  -> list_equal'[a] (l1, l2, f)

list_equal' : all a. ((ListNode a)!, (ListNode a)!, (a!,a!) -> Bool) -> Bool
list_equal' (x, y, f) =
  x.l | Nil -> 
        y.l | Nil -> True
            | _   -> False
      | Cons (e1, rest1) ->
        y.l | Nil -> False
            | Cons (e2, rest2) -> 
              f (e1,e2) | False -> False
                        | True  -> list_equal'[a] (rest1, rest2, f)

-- Given a search function and a list, finds the first element that the function returns true for
-- Returns None if no such element is found
list_find : all a. ((List a)!, a! -> Bool) -> Option U64

-- Finds and removes the element in the list at the provided index. 
-- Returns None if the index is out of range, with the list unchanged, otherwise returns the element and the updated list
list_at : all a. (List a, U64) -> (List a, Option a)


#endif -- COGENT_LIST_LIB