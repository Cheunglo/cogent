-- Tests recursive types

include <gum/common/common.cogent>

type ListNode a      = rec t { l: < Nil | Cons (a,t) > }
type EmptyListNode a = (ListNode a) take (..)

type List a = #{
  size: U64,
  list: ListNode a
}

------------- Allocation and deallocation -------------

alloc_list_node : all a. () -> EmptyListNode a
list_free_node : all a. EmptyListNode a -> ()

list_free : all a. (List a, a -> ()) -> ()
list_free (r { list = x }, f) = list_free' (x, f)

list_free' : all a. (ListNode a, a -> ()) -> ()
list_free' (r, f) =
  let r2 { l = x } = r
  and _ = list_free_node r2 in
    x | Nil               -> ()
      | Cons (elem, rest) ->
        let _ = f elem in list_free' (rest, f)

------------- List basic -------------

list_cons : all a. (a, List a) -> List a
list_cons (x, r) = 
  let #{ list = y, size = s } = r
  and node = (alloc_list_node ()) { l = Cons (x,y) }
  in #{ list = node, size = s + 1 }

list_head : all a. List a -> (Option a, List a)
list_head r =
  let #{ list = l, size = s } = r
  and l' { l = x } = l
  in
    x | Nil -> (None, #{ list = (l' { l = Nil }), size = s })
      | Cons (elem, rest) ->
        let _ = list_free_node l' in
          (Some elem, #{ list = rest, size = s-1 })

list_append : all a. (List a, List a) -> List a
list_append (r1, r2) =
  let #{ size = s1, list = l1 } = r1
  and #{ size = s2, list = l2 } = r2
  and appended = list_append' (l1,l2)
  in #{ size = s1 + s2, list = appended }

list_append' : all a. (ListNode a, ListNode a) -> ListNode a
list_append' (head { l = x }, b) =
  x | Nil -> 
        let _ = list_free_node head in b
    | Cons (elem, tail) -> 
        let rest = list_append' (tail, b)
        in head { l = Cons (elem, rest) }


------------- List Transformations -------------

list_map : all (a, b). ((a! -> b), (List a)!) -> List b
list_map (f, r) = 
  let #{ list = y } = r
  and x = list_map'[a,b] (f, y)
  in #{ list = x, size = r.size }

list_map' : all (a, b). ((a! -> b), (ListNode a)!) -> ListNode b
list_map' (f, head) =
  let node = alloc_list_node () in
    head.l | Nil -> node { l = Nil }
           | Cons (elem, tail) ->
             node { l = Cons (f elem, list_map'[a,b] (f, tail)) }

list_map_in_place : all (a :< E). ((a -> a), (List a)) -> List a
list_map_in_place (f, r) =
  let #{ list = y, size = s } = r
  and x = list_map_in_place'[a] (f,y)
  in  #{ list = x, size = s }

list_map_in_place' : all (a :< E). ((a -> a), (ListNode a)) -> ListNode a
list_map_in_place' (f, head) =
    let head { l = x } = head in 
      x | Nil -> head { l = Nil }
        | Cons (elem, tail) ->
            head { l = Cons (f elem, list_map_in_place'[a] (f, tail)) }

list_reverse : all a. List a -> List a
list_reverse r = 
  let #{ size, list } = r
  and list = list_reverse'[a] (list, (alloc_list_node ()) { l = Nil })
  in #{ size, list }

list_reverse' : all a. (ListNode a, ListNode a) -> ListNode a
list_reverse' (head { l }, acc) =
  l | Nil  -> 
      let _ = list_free_node head
      in acc
    | Cons (elem, rest) ->
      list_reverse'[a] (rest, head { l = Cons (elem, acc) } )


------------- List Qualities -------------

list_is_empty : all a. (List a)! -> Bool
list_is_empty (r { size = s }) = s == 0

list_length : all a. (List a)! -> U64
list_length (r { size = s }) = s