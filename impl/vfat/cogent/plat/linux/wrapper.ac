/*
 * Copyright 2016, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(NICTA_GPL)
 */

// FOR TESTING:
// CHECK
// - inode version numbers (are they increasing as they should?)
// - overflow stuff - safe_add?
$esc:(#include <adt.h>)
$esc:(#include <wrapper.h>)
$esc:(#include <fat.h>)

$esc:(#include <wraphead.h>)

//typedef struct super_block *Superblock;
typedef void *ExState;

#include <generated.c>
#include <abstract.h>
#include <gum/anti/iterator.ac>

/*=================*
Extern these eventually
*=================*/
static inline void fat_lock_build_inode(struct msdos_sb_info *sbi)
{
	if (sbi->options.nfs == FAT_NFS_NOSTALE_RO)
		mutex_lock(&sbi->nfs_build_inode_lock);
}

static inline void fat_unlock_build_inode(struct msdos_sb_info *sbi)
{
	if (sbi->options.nfs == FAT_NFS_NOSTALE_RO)
		mutex_unlock(&sbi->nfs_build_inode_lock);
}

/*=================*
Translators
*=================*/
// change previous translations to use this instead
struct timespec * cog_to_c_time ($ty:(Time) arg){
	struct timespec * ts = kmalloc(sizeof(struct timespec), GFP_KERNEL);
	if(!ts){
		$esc:(printk(KERN_WARNING "ERROR MALLOCING.\n")); //TODO: fix errors
	}
	ts->tv_sec = arg.seconds;
	ts->tv_nsec = arg.nanoseconds;
	return ts;
}

/*=================*
Getters and Setters
*=================*/
//TODO: potentially remove one of the fields of timespec when you figure out which is used
$ty:(Time) $id:get_current_time (unit_t arg){
  struct timespec ts = CURRENT_TIME_SEC;
  $ty:(Time) ret;
  ret.seconds = ts.tv_sec;
  ret.nanoseconds = ts.tv_nsec;
  return ret;
}

$ty:(U64) $id:get_version($ty:(VfsInode!) arg){
	struct inode * c_inode = (struct inode *) arg;
	return c_inode->i_version;
}

$ty:(U64) $id:get_sb($ty:(VfsInode!) arg){
	struct inode * c_inode = (struct inode *) arg;
	$ty:(U64) ret = ($ty:(U64)) (c_inode->i_sb);
	return ret;
}

$ty:(VfsInode) $id:set_version($ty:((VfsInode, U64)) arg){
	struct inode * c_inode = (struct inode *) arg.p1;
	c_inode->i_version = (u64) arg.p2;
	$ty:(VfsInode) ret = ($ty:(VfsInode)) c_inode;
	return ret;
}

$ty:(VfsInode) $id:set_time ($ty:((VfsInode, Time)) arg){
  struct inode * node = (struct inode *) (arg.p1);

	$ty:(Time) ts_arg = arg.p2;
	struct timespec ts;
	ts.tv_sec = ts_arg.seconds;
	ts.tv_nsec = ts_arg.nanoseconds;
  node->i_mtime = node->i_atime = node->i_ctime = ts;

	$ty:(VfsInode) ret = ($ty:(VfsInode)) node;
	return ret;
}

$ty:(VfsInode) $id:set_ipos($ty:((VfsInode, U64)) arg) {
	struct inode * inode = (struct inode *) arg.p1;
	loff_t i_pos = arg.p2;
	MSDOS_I(inode) -> i_pos = i_pos;
	return (($ty:(VfsInode)) inode);
}

/*=================*
(Un)Lockers
*=================*/
unit_t $id:flock_buildinode($ty:(U64) arg){
	struct super_block * sb = (struct super_block *) arg;
	fat_lock_build_inode(MSDOS_SB(sb));
	unit_t ret; return ret;
}

unit_t $id:funlock_buildinode($ty:(U64) arg){
	struct super_block * sb = (struct super_block *) arg;
	fat_unlock_build_inode(MSDOS_SB(sb));
	unit_t ret; return ret;
}

/*=================*
General Functions
*=================*/

unit_t printblah ($ty:(String) arg){
	$esc:(printk(KERN_WARNING "HELLO: %s", arg));
	unit_t ret; return ret;
}

$ty:(R (VfsInode, U32) ErrPtr) $id:fat_alloc_new_dir_ac ($ty:((VfsInode, Time)) arg){
	$ty:(R (VfsInode, U32) ErrPtr) ret;
	struct inode * inode = (struct inode *) arg.p1;
	struct timespec * ts = cog_to_c_time(arg.p2);
	// check if ts can be freed - assuming it can
	int cluster = fat_alloc_new_dir (inode, ts);
	//kfree(ts);
	if (cluster < 0){
		$ty:(ErrPtr) err = ($ty:(ErrPtr)) ERR_PTR(cluster);
		ret.tag = TAG_ENUM_Error;
		ret.Error = err;
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success.p1 = ($ty:(VfsInode)) inode;
		ret.Success.p2 = cluster;
		return ret;
	}
}

$ty:(VfsInode) $id:inc_nlink_ac ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	inc_nlink(inode);
	return ($ty:(VfsInode)) inode;
}

// fix style to make it consistent
// check types etc.
$ty:(VfsInode) $id:set_nlink_ac ($ty:((VfsInode, U32)) arg) {
	set_nlink((struct inode *) arg.p1, arg.p2);
	return arg.p1;
}

unit_t $id:fat_free_clusters_ac ($ty:((VfsInode, U32)) arg){
	fat_free_clusters((struct inode *) arg.p1, arg.p2);
	unit_t ret; return ret;
}

$ty:(R VfsInode ErrPtr) $id:fat_dir_empty_ac ($ty:(VfsInode) arg){
	$ty:(R VfsInode ErrPtr) ret;
	struct inode * inode = (struct inode *) arg;
	int err = fat_dir_empty(inode);
	if (err) {
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(ErrPtr)) ERR_PTR(err);
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success = arg;
		return ret;
	}
}

// CREATE a function to translate slot info!!! used a lot
// check if read only for inode
$ty:(R (VfsInode, SlotInfo) ErrPtr) $id:fat_search_long_ac ($ty:((VfsInode, U64, U32)) arg){
	$ty:(R (VfsInode, SlotInfo) ErrPtr) ret;
	struct inode * inode = (struct inode *) arg.p1;
	struct qstr * qname = (struct qstr *) arg.p2;
	int len = arg.p3;
	struct fat_slot_info sinfo;

	int err = fat_search_long(inode, qname->name, len, &sinfo);
	if(err){
		ret.tag = TAG_ENUM_Error;
		void * err_ptr = ERR_PTR(err);
		ret.Error = (($ty:(ErrPtr)) err_ptr);
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success.p1 = (($ty:(VfsInode)) inode);
		ret.Success.p2.i_pos = ($ty:(U64)) sinfo.i_pos;
    ret.Success.p2.slot_off = ($ty:(U64)) sinfo.slot_off;
		ret.Success.p2.nr_slots = ($ty:(U32)) sinfo.nr_slots;
		ret.Success.p2.de = ($ty:(U64)) sinfo.de;
		ret.Success.p2.bh = ($ty:(U64)) sinfo.bh;
		return ret;
	}
}

int vfat_unlink_ac(struct inode * inode, struct dentry * dentry){
	$ty:(VfsInode) inode_cog = ($ty:(VfsInode)) inode;
	$ty:(VfsDentry) dentry_cog = ($ty:(VfsDentry)) dentry;
	$ty:((VfsInode, VfsDentry)) arg;
	arg.p1 = inode_cog;
	arg.p2 = dentry_cog;
	$ty:(R () ErrPtr) cog_ret = $exp:vfat_unlink_cog(arg);
	if(cog_ret.tag == TAG_ENUM_Error){
		return PTR_ERR((void *) cog_ret.Error);
	} else {
		return 0;
	}
}

$ty:((VfsInode, U64)) $id:mark_buffer_dirty_inode_ac ($ty:((VfsInode, U64)) arg){
	struct buffer_head * bh = (struct buffer_head *) arg.p2;
	struct inode * inode = (struct inode *) arg.p1;
	mark_buffer_dirty_inode(bh, inode);
	$ty:((VfsInode, U64)) ret;
	ret.p1 = ($ty:(VfsInode)) inode; ret.p2 = ($ty:(U64)) bh;
	return ret;
}

$ty:((U64, U64)) $id:get_init_null_bhde (unit_t arg){
	$ty:((U64, U64)) ret;
	struct msdos_dir_entry * de;
	struct buffer_head * bh = NULL;
	ret.p1 = de; ret.p2 = bh;
	return ret;
}

$ty:(RR U64 () ErrPtr) $id:sync_dirty_buffer_ac ($ty:(U64) arg){
	$ty:(RR U64 () ErrPtr) ret;
	int err = sync_dirty_buffer ((struct buffer_head *) arg);
	if(err) {
		ret.p1 = arg;
		ret.p2.tag = TAG_ENUM_Error;
		ret.p2.Error = ($ty:(ErrPtr)) ERR_PTR(err);
		return ret;
	} else {
		ret.p1 = arg;
		ret.p2.tag = TAG_ENUM_Success;
		return ret;
	}
}

$ty:(VfsInode) $id:deep_fat_write_inode_ac ($ty:((VfsInode, U32)) arg){
	struct inode * inode = (struct inode *) arg.p1;
	__fat_write_inode (inode, arg.p2); // HOW IS THIS WORKING
	return ($ty:(VfsInode)) inode;
}

$ty:(R VfsInode VfsInode) $id:deep_fat_remove_entries_ac ($ty:((VfsInode, U64, U32)) arg){
	$ty:(R (VfsInode) (VfsInode)) ret;
 	int err = __fat_remove_entries ((struct inode *) arg.p1, arg.p2, arg.p3);
	if (!err) {
		ret.tag = TAG_ENUM_Success;
		ret.Success = arg.p1;
		return ret;
	} else {
		ret.tag = TAG_ENUM_Error;
		ret.Error = arg.p1;
		return ret;
	}
}

// NEED TO ADD IN BH -> SOME ALIASING MIGHT BE HAPPENING (pointer so coding wise doesnt matter
// but later on might)
$ty:((U64, U32)) $id:del_slots_ac ($ty:((U32, U64, U64)) arg){
	int nr_slots = arg.p1;
	struct buffer_head * bh = (struct buffer_head *) arg.p2;
	struct msdos_dir_entry * de = (struct msdos_dir_entry *) arg.p3;
	while (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {
		de->name[0] = DELETED_FLAG;
		de--;
		nr_slots--;
	}
	$ty:((U64, U32)) ret;
	ret.p1 = ($ty:(U64)) de;
	ret.p2 = ($ty:(U32)) nr_slots;
	return ret;
}

$ty:(Bool) $id:ptr_grq_ac ($ty:((U64, U64)) arg){
	$ty:(Bool) ret;
	void * first_ptr = (void *) arg.p1;
	void * second_ptr = (void *) arg.p2;
	if(first_ptr > second_ptr){
		ret.boolean = true;
	} else {
		ret.boolean = false;
	}
	return ret;
}

$ty:(U64) $id:get_endpoint_ac ($ty:((U64, U64)) arg){
	struct super_block * sb = (struct super_block *) arg.p1;
	struct buffer_head * bh = (struct buffer_head *) arg.p2;
	struct msdos_dir_entry * endp = (struct msdos_dir_entry *)(bh->b_data + sb->s_blocksize);
	return ($ty:(U64)) endp;
}

$ty:(U64) $id:slot_offset ($ty:((U32, U32, U64)) arg){
	int orig_slots = arg.p1;
	int nr_slots = arg.p2;
	struct msdos_dir_entry * de = (struct msdos_dir_entry *) arg.p3;
	loff_t offset = ((orig_slots - nr_slots) * sizeof(*de)) - sizeof(*de);
	return ($ty:(U64)) offset;
}

$ty:(U64) $id:delete_first_plus ($ty:(U64) arg){
	struct msdos_dir_entry * de = (struct msdos_dir_entry *) arg;
	de->name[0] = DELETED_FLAG;
	de++;
	return ($ty:(U64)) de;
}

$ty:(R (VfsInode, U64, U64, U64) (VfsInode, ErrPtr)) $id:fat_get_entry_ac ($ty:((VfsInode, U64, U64, U64)) arg){
	struct inode * dir = (struct inode *) arg.p1;
	loff_t pos = arg.p2;
	struct buffer_head * bh = (struct buffer_head *) arg.p3;
	struct msdos_dir_entry * de = (struct msdos_dir_entry *) arg.p4;

	int res;
	///

	if (bh && de &&
		 (de - (struct msdos_dir_entry *)(bh)->b_data) <
				MSDOS_SB(dir->i_sb)->dir_per_block - 1) {
		pos += sizeof(struct msdos_dir_entry);
		(de)++;
		res = 0;
	} else {
		struct super_block *sb = dir->i_sb;
		sector_t phys, iblock;
		unsigned long mapped_blocks;
		int offset;

	next:
		if (bh)
			brelse(bh);

		bh = NULL;
		iblock = pos >> sb->s_blocksize_bits;
		res = fat_bmap(dir, iblock, &phys, &mapped_blocks, 0);
		if (res || !phys)
			res = -1;	/* beyond EOF or error */

		fat_dir_readahead(dir, iblock, phys);

		bh = sb_bread(sb, phys);
		if (bh == NULL) {
			$esc:(fat_msg_ratelimit(sb, KERN_ERR, "Directory bread(block %llu) failed", (llu)phys));
			/* skip this block */
			pos = (iblock + 1) << sb->s_blocksize_bits;
			goto next;
		}

		offset = pos & (sb->s_blocksize - 1);
		pos += sizeof(struct msdos_dir_entry);
		de = (struct msdos_dir_entry *)((bh)->b_data + offset);

		res = 0;
	}
	///

	$ty:(R (VfsInode, U64, U64, U64) (VfsInode, ErrPtr)) ret;
	if(res < 0){
		ret.tag = TAG_ENUM_Error;
		ret.Error.p1 = ($ty:(VfsInode)) dir;
		ret.Error.p2 = ($ty:(ErrPtr)) ERR_PTR (-EIO);
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success.p1 = ($ty:(VfsInode)) dir;
		ret.Success.p2 = ($ty:(U64)) pos;
		ret.Success.p3 = ($ty:(U64)) bh;
		ret.Success.p4 = ($ty:(U64)) de;
	}
	return ret;
}

/*
$ty:((U32, U64)) $id:fix_de ($ty:((U32, U64, U64, U64, U64)) arg){
	int nr_slots = arg.p1;
	struct msdos_dir_entry * de = (struct msdos_dir_entry *) arg.p2;
	struct super_block * sb = (struct super_block *) arg.p3;
	struct buffer_head * bh = (struct buffer_head *) arg.p4;
	struct msdos_dir_entry * endp = (struct msdos_dir_entry *) arg.p5;

	while (nr_slots && de < endp) {
		de->name[0] = DELETED_FLAG;
		de++;
		nr_slots--;
	}

	$ty:((U32, U64)) ret;
	ret.p1 = ($ty:(U32)) nr_slots;
	ret.p2 = ($ty:(U64)) de;
	return ret;
}*/

$ty:(U64) $id:get_b_data ($ty:(U64) arg){
	struct buffer_head * bh = (struct buffer_head *) arg;
	struct msdos_dir_entry * bdat = (struct msdos_dir_entry *) bh->b_data; //check the cast here
	return ($ty:(U64)) bdat;
}

$ty:(Bool) $id:ptr_greq_ac ($ty:((U64, U64)) arg){
	$ty:(Bool) ret;
	void * first_ptr = (void *) arg.p1;
	void * second_ptr = (void *) arg.p2;
	if(first_ptr >= second_ptr) {
		ret.boolean = true;
	} else {
		ret.boolean = false;
	}
	return ret;
}

$ty:(U64) $id:delete_first_ac ($ty:(U64) arg){
	struct msdos_dir_entry * de = (struct msdos_dir_entry *) arg;
	de->name[0] = DELETED_FLAG;
	de--;
	return ($ty:(U64)) de;
}

unit_t $id:fat_msg_ac ($ty:((U64, String)) arg){
	fat_msg((struct super_block *) arg.p1, KERN_WARNING,
				 arg.p2);
	unit_t ret; return ret;
}

unit_t $id:drop_nlink_ac ($ty:(VfsInode) arg){
	drop_nlink((struct inode *) arg);
	unit_t ret; return ret;
}

$ty:(VfsInode) $id:d_inode_ac ($ty:(VfsDentry) arg){
	struct inode * inode = d_inode((struct dentry *) arg);
	return (($ty:(VfsInode)) inode);
}

unit_t $id:fat_detach_ac ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	fat_detach(inode);
	unit_t ret; return ret;
}

$ty:(VfsInode) $id:clear_nlink_ac ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	clear_nlink(inode);
	return (($ty:(VfsInode)) inode);
}

$ty:(R () ErrPtr) $id:fat_remove_entries_ac ($ty:((VfsInode, SlotInfo)) arg){
	$ty:(R () ErrPtr) ret;
	struct inode * inode = (struct inode *) arg.p1;
	$ty:(SlotInfo) sinfo_cog = arg.p2;
	struct fat_slot_info sinfo;
	sinfo.i_pos = sinfo_cog.i_pos;
	sinfo.slot_off = sinfo_cog.slot_off;
	sinfo.nr_slots = sinfo_cog.nr_slots;
	sinfo.de = (struct msdos_dir_entry *) sinfo_cog.de;
	sinfo.bh = (struct buffer_head *) sinfo_cog.bh;

	int err = fat_remove_entries (inode, &sinfo);
	if(err){
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(ErrPtr)) ERR_PTR(err);
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		return ret;
	}
}

$ty:(Bool) $id:is_root_ino ($ty:((VfsInode!)) arg){
	$ty:(Bool) ret;
	struct inode * inode = (struct inode *) arg;
	if(inode->i_ino != MSDOS_ROOT_INO){
		ret.boolean = false;
		return ret;
	} else {
		ret.boolean = true;
		return ret;
	}
}

$ty:(U64) $id:get_head ($ty:(VfsInode!) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_sb_info * sbi = MSDOS_SB(inode->i_sb); //MSDOS_SB is just a getter
	struct hlist_head * head = sbi->inode_hashtable;
	return (($ty:(U64)) head);
}

$ty:(U32) $id:get_logstart ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_inode_info * minfo = MSDOS_I(inode);
	int logstart = minfo->i_logstart; //double check
	return logstart;
}

$ty:(U64) $id:hash_32_ac ($ty:(a) arg){
	return hash_32((u32) arg, FAT_HASH_BITS);
}
// $ty:(U64) $id:fat_hash_ac ($ty:(U64) i_pos){
// 	return (($ty:(U64)) fat_hash (i_pos)); //calls hash_32 which is too deep
// }

unit_t $id:spdir_lock ($ty:(VfsInode!) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_sb_info * sbi = MSDOS_SB(inode->i_sb);
	spin_lock(&sbi->dir_hash_lock);
	unit_t ret; return ret;
}

unit_t $id:spdir_unlock ($ty:(VfsInode!) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_sb_info * sbi = MSDOS_SB(inode->i_sb);
	spin_unlock(&sbi->dir_hash_lock);
	unit_t ret; return ret;
}

unit_t $id:spinode_lock ($ty:(VfsInode!) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_sb_info * sbi = MSDOS_SB(inode->i_sb);
	spin_lock(&sbi->inode_hash_lock);
	unit_t ret; return ret;
}

unit_t $id:spinode_unlock ($ty:(VfsInode!) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_sb_info * sbi = MSDOS_SB(inode->i_sb);
	spin_unlock(&sbi->inode_hash_lock);
	unit_t ret; return ret;
}

$ty:(Bool) $id:is_nfs ($ty:(VfsInode!) arg){
	$ty:(Bool) ret;
	struct inode * inode = (struct inode *) arg;
	struct msdos_sb_info * sbi = MSDOS_SB(inode->i_sb);
	if(sbi->options.nfs){
		ret.boolean = true;
		return ret;
	} else {
		ret.boolean = false;
		return ret;
	}
}

$ty:(U64) $id:get_dhead ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_sb_info * sbi = MSDOS_SB(inode->i_sb);
	return ($ty:(U64)) (sbi->dir_hashtable);
}

// $ty:(U64) $id:fat_dir_hash_ac ($ty:(VfsInode) arg){
// 	struct inode * inode = (struct inode *) arg;
// 	struct msdos_inode_info * minfo = MSDOS_I(inode);
// 	int logstart = minfo->i_logstart; //double check
// 	unsigned long hash_val = fat_dir_hash (logstart); // calls hash_32 which is too deep
// 	return ($ty:(U64)) hash_val;
// }

$ty:(VfsInode) $id:hlist_add_head_ac ($ty:((VfsInode, U64)) arg){
	struct inode * inode = (struct inode *) arg.p1;
	struct msdos_inode_info * minfo = MSDOS_I(inode);
	struct hlist_node * node = &minfo->i_fat_hash;

	struct hlist_head * head = (struct hlist_head *) arg.p2;

	hlist_add_head(node, head);

	return ($ty:(VfsInode)) inode;
}

// GET RID OF THIS LATER - JUST TEMPORARY
$ty:(VfsInode) $id:update_am_time ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	inode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;
	return (($ty:(VfsInode)) inode);
}

$ty:(VfsDentry) $id:d_splice_alias_ac ($ty:((VfsInode, VfsDentry)) arg){
	struct inode * inode = (struct inode *) arg.p1;
	struct dentry * dentry = (struct dentry *) arg.p2;
	struct dentry * ret = d_splice_alias(inode, dentry);
	return (($ty:(VfsDentry)) ret);
}

$ty:(VfsDentry) $id:d_unhashed_ac ($ty:(VfsDentry) arg){
	struct dentry * alias = (struct dentry *) arg;
	BUG_ON(d_unhashed(alias));
	return (($ty:(VfsDentry)) alias);
}

$ty:(U64) $id:get_fat_hash ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_inode_info * minfo = MSDOS_I(inode);
	struct hlist_node * node_fat_hash = &minfo->i_fat_hash;
	return (u64) (node_fat_hash);
}

$ty:(U64) $id:get_dir_hash ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	struct msdos_inode_info * minfo = MSDOS_I(inode);
	struct hlist_node * node_dir_hash = &minfo->i_dir_hash;
	return (u64) (node_dir_hash);
}

//check if id used for everything

unit_t $id:hlist_del_init_ac ($ty:(U64) arg){
	hlist_del_init ((struct hlist_node *) arg);
	unit_t ret; return ret;
}

$ty:(VfsDentry) $id:d_find_alias_ac ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	struct dentry * alias = d_find_alias (inode);
	return ($ty:(VfsDentry)) alias;
}

$ty:(VfsDentry) $id:get_parent ($ty:(VfsDentry) arg){
	struct dentry * dentry = (struct dentry *) arg;
	struct dentry * parent = dentry->d_parent;
	return ($ty:(VfsDentry)) parent;
}

// maybe use RR c a b instead of R a b here - same return value
// $ty:(R (VfsInode, VfsDentry) (VfsInode, VfsDentry)) $id:alias_cond ($ty:((VfsInode, VfsDentry)) arg){
// 	$ty:(R (VfsInode, VfsDentry) (VfsInode, VfsDentry)) ret;
// 	struct inode * inode = (struct inode *) arg.p1;
// 	struct dentry * dentry = (struct dentry *) arg.p2;
// 	struct dentry * alias = d_find_alias(inode);
// 	if(alias && alias->d_parent == dentry->d_parent && !vfat_d_anon_disconn(alias)){
// 		ret.tag = TAG_ENUM_Success;
// 		ret.Success.p1 = ($ty:(VfsInode)) inode;
// 		ret.Success.p2 = ($ty:(VfsDentry)) alias;
// 		return ret;
// 	} else {
// 		ret.tag = TAG_ENUM_Error;
// 		ret.Error.p1 = ($ty:(VfsInode)) inode;
// 		ret.Error.p2 = ($ty:(VfsDentry)) alias;
// 		return ret;
// 	}
// }

$ty:(Bool) $id:is_dir_ac ($ty:(VfsInode!) arg){
	$ty:(Bool) ret;
	struct inode * inode = (struct inode *) arg;
	if(S_ISDIR(inode->i_mode)){ // reformat
		ret.boolean = true;
		return ret;
	} else {
		ret.boolean = false;
		return ret;
	}
}

$ty:(Bool) $id:is_null ($ty:(VfsInode) inode){
	$ty:(Bool) ret;
	if(!inode){
		ret.boolean = true;
		return ret;
	} else {
		ret.boolean = false;
		return ret;
	}
}

$ty:(Bool) $id:is_noent ($ty:(ErrPtr) errptr){
	$ty:(Bool) ret;
	int err = PTR_ERR((void *) errptr);
	if(err == -ENOENT){
		ret.boolean = true;
		return ret;
	} else {
		ret.boolean = true;
		return ret;
	}
}

$ty:(VfsDentry) $id:set_d_time ($ty:((VfsDentry, U64)) arg){
	struct dentry * dentry = (struct dentry *) arg.p1;
	dentry->d_time = arg.p2; //check types
	return (($ty:(VfsDentry)) dentry);
}

unit_t $id:dput_ac ($ty:(VfsDentry) arg){
	struct dentry * dentry = (struct dentry *) arg;
	dput(dentry);
	unit_t ret; return ret;
}

unit_t $id:d_move_ac ($ty:((VfsDentry, VfsDentry)) arg){
	struct dentry * alias = (struct dentry *) arg.p1;
	struct dentry * dentry = (struct dentry *) arg.p2;
	d_move(alias, dentry);
	unit_t ret; return ret;
}

$ty:(VfsInode) $id:mark_inode_dirty_ac ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	mark_inode_dirty(inode);
	return (($ty:(VfsInode)) inode);
}

$ty:(VfsInode) $id:fat_sync_inode_ac ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	(void)fat_sync_inode(inode);
	return (($ty:(VfsInode)) inode);
}

$ty:(Bool) $id:last_char_dot_ac ($ty:((String, U32)) arg){
	$ty:(Bool) ret;
	char * name = (char *) arg.p1;
	$ty:(U32) len = arg.p2;
	if (name[len-1] == '.') {
		ret.boolean = true;
	} else {
		ret.boolean = false;
	}
	return ret;
}

$ty:(String) $id:get_qstr_name ($ty:(U64) arg) {
	struct qstr * qname = (struct qstr *) arg;
	const char * name = qname->name;
	return ($ty:(String)) name;
}

$ty:(U32) $id:get_qstr_length ($ty:(U64) arg){
	struct qstr * qname = (struct qstr *) arg;
	unsigned int len = qname->len;
	return len;
}

// should definitely be changed later on
$ty:(R VfsInode VfsInode) $id:is_dirsync_ac ($ty:(VfsInode) arg){
	$ty:(R VfsInode VfsInode) ret;
	struct inode * inode = (struct inode *) arg;
	if(IS_DIRSYNC(inode)){
		ret.tag = TAG_ENUM_Success;
		ret.Success = ($ty:(VfsInode)) inode;
		return ret;
	} else {
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(VfsInode)) inode;
		return ret;
	}
}

$ty:(ErrPtr) $id:noent_ac (unit_t arg) {
	$ty:(ErrPtr) ret;
	ret = ($ty:(ErrPtr)) ERR_PTR(-ENOENT);
	return ret;
}

/*
$ty:(R U32 ErrPtr) $id:vfat_striptail_len_ac ($ty:(U64) arg){
	$ty:(R U32 ErrPtr) ret;
	struct qstr * qname = (struct qstr *) arg;
	unsigned int len = qname->len;
	const char * name = qname->name;
	while(len && name[len - 1] == '.'){
		len--;
	}
	if (len == 0){
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(ErrPtr)) ERR_PTR(-ENOENT); // POSITIVE NOT NEGATIVE?!
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success = len;
		return ret;
	}
}*/

$ty:(U32) $id:decrementU32 ($ty:(U32) arg){
	return (arg-1);
}

$ty:(R SlotInfo ErrPtr) $id:fat_add_entries_ac ($ty:((VfsInode, U64, U32)) arg){
	$ty:(R SlotInfo ErrPtr) ret;
	struct inode * inode = (struct inode *) arg.p1;
	struct msdos_dir_slot * slots = (struct msdos_dir_slot *) arg.p2;
	int nr_slots = arg.p3;

	struct fat_slot_info sinfo;

	int err = fat_add_entries (inode, slots, nr_slots, &sinfo);
	kfree(slots);
	if(err){
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(ErrPtr)) (ERR_PTR(err));
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success.i_pos = ($ty:(U64)) sinfo.i_pos;
		ret.Success.slot_off = ($ty:(U64)) sinfo.slot_off;
		ret.Success.nr_slots = ($ty:(U32)) sinfo.nr_slots;
		ret.Success.de = ($ty:(U64)) sinfo.de;
		ret.Success.bh = ($ty:(U64)) sinfo.bh;
		return ret;
	}
}

$ty:(Bool) $id:is_disconnected ($ty:(VfsDentry) arg){
	$ty:(Bool) ret;
	struct dentry * dentry = (struct dentry *) arg;
	if (dentry->d_flags & DCACHE_DISCONNECTED) {
		ret.boolean = true;
	} else {
		ret.boolean = false;
	}
	return ret;
}
// $ty:(Bool) $id:vfat_d_anon_disconn_ac ($ty:(VfsDentry) arg){
// 	$ty:(Bool) ret;
// 	struct dentry * dentry = (struct dentry *) arg;
// 	if(vfat_d_anon_disconn(dentry)){
// 		ret.boolean = true;
// 	} else {
// 		ret.boolean = false;
// 	}
// 	return ret;
// }

$ty:(R (VfsInode, U64, U32) ErrPtr) $id:vfat_build_slots_ac ($ty:((VfsInode, U64, U32, U32, U32, Time)) arg){
	$ty:(R (VfsInode, U64, U32) ErrPtr) ret;
	struct inode * inode = (struct inode *) arg.p1;
	const char * name = ((struct qstr *) arg.p2)->name;
	int len = arg.p3;
	int is_dir = arg.p4;
	int cluster = arg.p5;
	struct timespec * ts = cog_to_c_time(arg.p6);

	int nr_slots;
	struct msdos_dir_slot *slots;

	slots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);

	if (slots == NULL){
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(ErrPtr)) ERR_PTR(-ENOMEM); // negative?!
		return ret;
	}

	int err = vfat_build_slots (inode, name, len, is_dir, cluster, ts, slots, &nr_slots);
	kfree(ts);

	if(err){
		kfree(slots);
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(ErrPtr)) ERR_PTR(err);
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success.p1 = ($ty:(VfsInode)) inode;
		ret.Success.p2 = ($ty:(U64)) slots;
		ret.Success.p3 = nr_slots;
		return ret;
	}
}

unit_t $id:slock($ty:(U64) sblock){
	struct super_block * sb = (struct super_block *) sblock;
	mutex_lock(&MSDOS_SB(sb)->s_lock);
	unit_t ret; return ret;
}

unit_t $id:ulock($ty:(U64) sblock){
	struct super_block * sb = (struct super_block *) sblock;
	mutex_unlock(&MSDOS_SB(sb)->s_lock);
	unit_t ret; return ret;
}

$ty:(R (VfsInode, SlotInfo) ErrPtr) $id:vfat_add_entry_ac ($ty:((VfsInode, U64, U32, U32, Time)) arg){
	struct fat_slot_info sinfo;
	$ty:(R (VfsInode, SlotInfo) ErrPtr) ret;

	struct inode * inode = (struct inode *) arg.p1;
	struct qstr * qname = (struct qstr *) arg.p2;
	int is_dir = arg.p3;
	int cluster = arg.p4;

	struct timespec * ts = cog_to_c_time(arg.p5);
	int err = vfat_add_entry(inode, qname, is_dir, cluster, ts, &sinfo);
	kfree(ts);
	if(err){
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(ErrPtr)) ERR_PTR(err);
		return ret;
	} else{
		ret.tag = TAG_ENUM_Success;
		ret.Success.p1 = ($ty:(VfsInode)) inode;
		ret.Success.p2.i_pos = ($ty:(U64)) sinfo.i_pos;
    ret.Success.p2.slot_off = ($ty:(U64)) sinfo.slot_off;
		ret.Success.p2.nr_slots = ($ty:(U32)) sinfo.nr_slots;
		ret.Success.p2.de = ($ty:(U64)) sinfo.de;
		ret.Success.p2.bh = ($ty:(U64)) sinfo.bh;
    return ret;
	}
}

$ty:(R VfsInode ErrPtr) $id:new_inode_ac ($ty:(U64) arg){
	$ty:(R VfsInode ErrPtr) ret;
	struct super_block * sb = (struct super_block *) arg;
	struct inode * newinode = new_inode(sb);
	if(!newinode){
		 ret.tag = TAG_ENUM_Error;
		 ret.Error = ($ty:(ErrPtr)) ERR_PTR(-ENOMEM);
		 return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success = ($ty:(VfsInode)) newinode;
		return ret;
	}
}

// will change later
$ty:(R () ErrPtr) $id:fat_iget_ac ($ty:((U64, U64)) arg){
	$ty:(R () ErrPtr) ret;
	struct super_block * sb = (struct super_block *) arg.p1;
	loff_t i_pos = arg.p2;

	struct inode * inode = fat_iget(sb, i_pos);
	if(inode){
		ret.tag = TAG_ENUM_Error;
		ret.Error = ($ty:(ErrPtr)) inode;
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		return ret;
	}
}

$ty:(VfsInode) $id:set_ino ($ty:((VfsInode, U64)) arg){
	struct inode * inode = (struct inode *) arg.p1;
	struct super_block * sb = (struct super_block *) arg.p2;
	inode->i_ino = iunique(sb, MSDOS_ROOT_INO);
	return (($ty:(VfsInode)) inode);
}

$ty:(R VfsInode (VfsInode, ErrPtr)) $id:fat_fill_inode_ac ($ty:((VfsInode, U64)) arg){
	$ty:(R VfsInode (VfsInode, ErrPtr)) ret;
	struct inode * inode = (struct inode *) arg.p1;
	struct msdos_dir_entry * de = (struct msdos_dir_entry *) arg.p2;
	int err = fat_fill_inode(inode, de);
	if(err){
		ret.tag = TAG_ENUM_Error;
		ret.Error.p1 = ($ty:(VfsInode)) inode;
		ret.Error.p2 = ($ty:(ErrPtr)) ERR_PTR(err);
		return ret;
	} else {
		ret.tag = TAG_ENUM_Success;
		ret.Success = ($ty:(VfsInode)) inode;
		return ret;
	}
}

$ty:(VfsInode) $id:insert_inode_hash_ac ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	insert_inode_hash(inode);
	return (($ty:(VfsInode)) inode);
}

unit_t $id:iput_ac ($ty:(VfsInode) arg){
	struct inode * inode = (struct inode *) arg;
	iput(inode);
	unit_t ret; return ret;
}

$ty:(U32) $id:ptr_err_ac ($ty:(ErrPtr) arg){
	void * err_ptr = (void *) arg;
	return PTR_ERR(err_ptr);
}

int vfat_create_ac(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)
{
	$ty:(VfsInode) cog_inode = ($ty:(VfsInode)) dir;
	$ty:(VfsDentry) cog_dentry = ($ty:(VfsDentry)) dentry;

	$ty:((VfsInode, VfsDentry)) arg;
	arg.p1 = cog_inode;
	arg.p2 = cog_dentry;
	$ty:(R VfsInode ErrPtr) ret = $exp:vfat_create_cog(arg);

	if(ret.tag == TAG_ENUM_Success){
		return 0;
	} else {
		return PTR_ERR((void *) ret.Error);
	}
}

$ty:(VfsInode) $id:fat_build_inode_ac ($ty:((VfsInode, SlotInfo)) arg){
	$ty:(SlotInfo) sinfo = arg.p2;
	long long int i_pos = sinfo.i_pos;
	struct msdos_dir_entry * mdentry = (struct msdos_dir_entry*) sinfo.de;
	struct buffer_head * bh = (struct buffer_head *) sinfo.bh;
  struct super_block * sb = (struct super_block *) (((struct inode *)(arg.p1))->i_sb);

  struct inode * inode_new = fat_build_inode(sb, mdentry, i_pos);

	brelse(bh);

	$ty:(VfsInode) ret = ($ty:(VfsInode)) inode_new;

	return ret;
}

$ty:(U64) $id:brelse_ac ($ty:(U64) arg){
	struct buffer_head * bh = (struct buffer_head *) arg;
	brelse(bh);
	return arg;
}

$ty:(U64) $id:get_name ($ty:(VfsDentry) dentry){
	struct dentry * c_dentry = (struct dentry *) dentry;
	$ty:(U64) ret =  ($ty:(U64)) &(c_dentry->d_name);
	return ret;
}

// unit_t - reached end of non-void function
unit_t $id:d_instantiate_ac($ty:((VfsInode, VfsDentry)!) arg){
	// Have a bang in the argument, so why is this -> instead of .
	struct inode * inode_ptr = (struct inode *) arg.p1;
  struct dentry * dentry_ptr = (struct dentry *) arg.p2;
  d_instantiate(dentry_ptr, inode_ptr); // check if this writes - fix in the future

	// TODO: Check if this writes - unlikely, but if it does then need to add in this code and change the return value
	//arg.p1->i_sb = ($ty:(U64)) inode_ptr->i_sb;
	//arg.p2->dname = ($ty:(U64)) &dentry_ptr->d_name;
	unit_t ret; return ret;

}

$ty:(R VfsInode ErrPtr) $id:is_err($ty:(VfsInode) inode){
  $ty:(R VfsInode ErrPtr) ret;
  struct inode * c_inode = (struct inode *) inode;
  if(IS_ERR(c_inode)){
    ret.tag = TAG_ENUM_Error;
    ret.Error = inode; // double check if this writes anything - unlikely
    return ret;
  } else {
    ret.tag = TAG_ENUM_Success;
    ret.Success = inode;
    return ret;
  }
}

struct dentry *vfat_lookup_ac(struct inode *dir, struct dentry *dentry, unsigned int flags)
{
	$ty:(VfsInode) cog_dir = ($ty:(VfsInode)) dir;
	$ty:(VfsDentry) cog_dentry = ($ty:(VfsDentry)) dentry;
	$ty:((VfsInode, VfsDentry)) arg;
	arg.p1 = cog_dir; arg.p2 = cog_dentry;
	$ty:(R VfsDentry ErrPtr) res = $exp:vfat_lookup_cog(arg);
	if (res.tag == TAG_ENUM_Success){
		return (struct dentry *) res.Success;
	} else {
		return (struct dentry *) res.Error;
	}
}

$ty:(U64) $id:incr_head_pointer($ty:((U64, U64)) arg){
	struct hlist_head * ptr = (struct hlist_head*) arg.p1;
	return (($ty:(U64)) (ptr + arg.p2));
}

int vfat_mkdir_ac (struct inode * inode, struct dentry * dentry, umode_t mode){
	$ty:((VfsInode, VfsDentry)) arg;
	arg.p1 = ($ty:(VfsInode)) inode;
	arg.p2 = ($ty:(VfsDentry)) dentry;
	$ty:(R () ErrPtr) cog_ret = $exp:vfat_mkdir_cog (arg);
	if (cog_ret.tag == TAG_ENUM_Success){
		return 0;
	} else {
		return PTR_ERR((void *) cog_ret.Error);
	}
}

int vfat_rmdir_ac(struct inode *dir, struct dentry *dentry){
	$ty:((VfsInode, VfsDentry)) arg;
	arg.p1 = ($ty:(VfsInode)) dir;
	arg.p2 = ($ty:(VfsDentry)) dentry;
	$ty:(R () ErrPtr) cog_ret = $exp:vfat_rmdir_cog (arg);
	if (cog_ret.tag == TAG_ENUM_Success){
		return 0;
	} else {
		return PTR_ERR((void *) cog_ret.Error);
	}
}
