struct super_block *sb = dir->i_sb;
struct fat_slot_info sinfo;
struct inode *inode;
struct dentry *alias;
int err;

mutex_lock(&MSDOS_SB(sb)->s_lock);

err = vfat_find(dir, &dentry->d_name, &sinfo);
if (err) {
  if (err == -ENOENT) {
    inode = NULL;
    goto out;
  }
  goto error;
}

inode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);
brelse(sinfo.bh);
if (IS_ERR(inode)) {
  err = PTR_ERR(inode);
  goto error;
}

alias = d_find_alias(inode);
/*
* Checking "alias->d_parent == dentry->d_parent" to make sure
* FS is not corrupted (especially double linked dir).
*/
if (alias && alias->d_parent == dentry->d_parent &&
  !vfat_d_anon_disconn(alias)) {
    /*
    * This inode has non anonymous-DCACHE_DISCONNECTED
    * dentry. This means, the user did ->lookup() by an
    * another name (longname vs 8.3 alias of it) in past.
    *
    * Switch to new one for reason of locality if possible.
    */
    BUG_ON(d_unhashed(alias));
    if (!S_ISDIR(inode->i_mode))
    d_move(alias, dentry);
    iput(inode);
    mutex_unlock(&MSDOS_SB(sb)->s_lock);
    return alias;
  } else
  dput(alias);

  out:
  mutex_unlock(&MSDOS_SB(sb)->s_lock);
  if (!inode)
  dentry->d_time = dir->i_version;
  return d_splice_alias(inode, dentry);
  error:
  mutex_unlock(&MSDOS_SB(sb)->s_lock);
  return ERR_PTR(err);
}

static int vfat_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	struct super_block *sb = dir->i_sb;
	struct fat_slot_info sinfo;
	int err;

	mutex_lock(&MSDOS_SB(sb)->s_lock);

	err = vfat_find(dir, &dentry->d_name, &sinfo);
	if (err)
		goto out;

	err = fat_remove_entries(dir, &sinfo);	/* and releases bh */
	if (err)
		goto out;
	clear_nlink(inode);
	inode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;
	fat_detach(inode);
	dentry->d_time = dir->i_version;
out:
	mutex_unlock(&MSDOS_SB(sb)->s_lock);

	return err;
}

static int vfat_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
	struct super_block *sb = dir->i_sb;
	struct inode *inode;
	struct fat_slot_info sinfo;
	struct timespec ts;
	int err, cluster;

	mutex_lock(&MSDOS_SB(sb)->s_lock);

	ts = CURRENT_TIME_SEC;
	cluster = fat_alloc_new_dir(dir, &ts);
	if (cluster < 0) {
		err = cluster;
		goto out;
	}
	err = vfat_add_entry(dir, &dentry->d_name, 1, cluster, &ts, &sinfo);
	if (err)
		goto out_free;
	dir->i_version++;
	inc_nlink(dir);

	inode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);
	brelse(sinfo.bh);
	if (IS_ERR(inode)) {
		err = PTR_ERR(inode);
		/* the directory was completed, just return a error */
		goto out;
	}
	inode->i_version++;
	set_nlink(inode, 2);
	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
	/* timestamp is already written, so mark_inode_dirty() is unneeded. */

	d_instantiate(dentry, inode);

	mutex_unlock(&MSDOS_SB(sb)->s_lock);
	return 0;

out_free:
	fat_free_clusters(dir, cluster);
out:
	mutex_unlock(&MSDOS_SB(sb)->s_lock);
	return err;
}

static int vfat_rmdir(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	struct super_block *sb = dir->i_sb;
	struct fat_slot_info sinfo;
	int err;

	mutex_lock(&MSDOS_SB(sb)->s_lock);

	err = fat_dir_empty(inode);
	if (err)
		goto out;
	err = vfat_find(dir, &dentry->d_name, &sinfo);
	if (err)
		goto out;

	err = fat_remove_entries(dir, &sinfo);	/* and releases bh */
	if (err)
		goto out;
	drop_nlink(dir);

	clear_nlink(inode);
	inode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;
	fat_detach(inode);
	dentry->d_time = dir->i_version;
out:
	mutex_unlock(&MSDOS_SB(sb)->s_lock);

	return err;
}


// Create a new inode associated with the given dentry
// dir is the parent inode, dentry is the given dentry linked with the inode, rest are irrelevant
/*static int vfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,
		       bool excl)
{
	struct super_block *sb = dir->i_sb; // gets the superblock
	struct inode *inode; // will be the new inode
	struct fat_slot_info sinfo; // disk-related info (?) TODO: Check what this does
	struct timespec ts;
	int err;

	//printk(KERN_WARNING "%lu\n", dir->i_ino);

	mutex_lock(&MSDOS_SB(sb)->s_lock);

	ts = CURRENT_TIME_SEC; //time of creation set to now

	err = vfat_add_entry(dir, &dentry->d_name, 0, 0, &ts, &sinfo); //TODO: Check what this does
	if (err)
		goto out;
	dir->i_version++;

	inode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);
	brelse(sinfo.bh); //TODO: Check what this does
	if (IS_ERR(inode)) {
		err = PTR_ERR(inode); //TODO: Check what this does
		goto out;
	}
	inode->i_version++;
	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
	// timestamp is already written, so mark_inode_dirty() is unneeded.

	d_instantiate(dentry, inode);
out:
	mutex_unlock(&MSDOS_SB(sb)->s_lock);
	return err;
}*/

// maybe change this so that it always calls the ac one
// int vfat_d_anon_disconn(struct dentry *dentry)
// {
// 	return IS_ROOT(dentry) && (dentry->d_flags & DCACHE_DISCONNECTED);
// }
