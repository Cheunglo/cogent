--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

include <gum/iterator.cogent>
-- in common.cogent:
--  type ExState = U64
--  type R a b = < Success a | Error b >
--  type RR a b c = (c, R a b)

-- pointers in U64
-- change all to abstract types
-- add in ExState

type VfsInode = U64
type VfsDentry = U64
type ErrPtr = U64

type Time = #{
  seconds:  U32,
  nanoseconds: U32
}

type SlotInfo = #{
  i_pos: U64,
  slot_off: U64,
  nr_slots: U32,
  de: U64,
  bh: U64
}
-- Option a = < Some a | None () > -- lib gum - put this in
-- maybe make locks a(n abstract) type

-- ==========
-- Completely implemented (fix names/return types if needed)
-- ==========
get_sb: VfsInode! -> U64
get_name: VfsDentry -> U64
get_version: VfsInode! -> U64
get_dhead: VfsInode -> U64
get_head: VfsInode! -> U64
get_dir_hash: VfsInode! -> U64
get_fat_hash: VfsInode! -> U64 -- change these to "Either f g"
get_logstart: VfsInode! -> U32
get_parent: VfsDentry -> VfsDentry
get_qstr_name: U64 -> String
get_qstr_length: U64 -> U32
set_version: (VfsInode, U64) -> VfsInode
set_ipos: (VfsInode, U64) -> VfsInode
get_b_data: U64 -> U64

is_err: VfsInode -> R VfsInode ErrPtr
is_dirsync_ac: VfsInode -> R VfsInode VfsInode -- maybe should just be read
is_dir_ac: VfsInode! -> Bool
is_root_ino: VfsInode! -> Bool
is_nfs: VfsInode! -> Bool
is_null: VfsInode -> Bool
is_noent: ErrPtr -> Bool
is_disconnected: VfsDentry -> Bool

flock_buildinode: U64 -> ()
funlock_buildinode: U64 -> ()
ulock: U64 -> ()
slock: U64 -> ()
spinode_unlock: VfsInode! -> ()
spinode_lock: VfsInode! -> ()
spdir_lock: VfsInode! -> ()
spdir_unlock: VfsInode! -> ()

decrementU32: U32 -> U32
incr_head_pointer: (U64, U64) -> U64
inc_nlink_ac: VfsInode -> VfsInode
set_nlink_ac: (VfsInode, U32) -> VfsInode -- check?
fat_msg_ac: (U64, String) -> () -- check?

noent_ac: () -> ErrPtr

-- too deep
drop_nlink_ac: VfsInode -> ()
mark_inode_dirty_ac: VfsInode -> VfsInode
iput_ac: VfsInode -> ()
d_instantiate_ac: (VfsInode, VfsDentry)! -> () -- check comments
new_inode_ac: (U64) -> R VfsInode ErrPtr
hlist_add_head_ac: (VfsInode, U64) -> VfsInode -- needs fixing
brelse_ac: U64 -> U64
mark_buffer_dirty_inode_ac: (VfsInode, U64) -> (VfsInode, U64)
sync_dirty_buffer_ac: (U64) -> RR U64 () ErrPtr
set_ino: (VfsInode, U64) -> VfsInode
insert_inode_hash_ac: VfsInode -> VfsInode -- too deep but very easy to implement
clear_nlink_ac: VfsInode -> VfsInode
d_inode_ac: VfsDentry -> VfsInode -- super easy
dput_ac: VfsDentry -> ()
hlist_del_init_ac: U64 -> ()
d_splice_alias_ac: (VfsInode, VfsDentry) -> VfsDentry
d_move_ac: (VfsInode, VfsDentry) -> ()
d_unhashed_ac: VfsDentry -> VfsDentry
hash_32_ac: all(a). a -> U64 -- CHECK: This returns U32, but here its U64 - does it matter? -- CHANGE THIS so it only accepts U32 and U64? (if possible)
d_find_alias_ac: VfsInode -> VfsDentry
-- ==========

-- time stuff - FIX THESE UP TOO
set_time: (VfsInode, Time) -> VfsInode
update_am_time: VfsInode -> VfsInode -- change this?
set_d_time: (VfsDentry, U64) -> VfsDentry -- fix this up
get_current_time: () -> Time

-- ==========
-- iteration-related stuff
-- ==========
vfat_build_slots_ac: (VfsInode, U64, U32, U32, U32, Time) -> R (VfsInode, U64, U32) ErrPtr -- change later to merge slots and nr_slots
fat_free_clusters_ac: (VfsInode, U32) -> ()
fat_iget_ac: (U64, U64) -> R () ErrPtr -- uses hlist_for_whatever
-- contain fat_get_entry:
deep_fat_remove_entries_ac: (VfsInode, U64, U32) -> R VfsInode VfsInode -- written below, but messed up somehow - debug later
fat_add_entries_ac: (VfsInode, U64, U32) -> R SlotInfo ErrPtr -- maybe define Err as U32 - later get rid of errptr if possible
fat_search_long_ac: (VfsInode, U64, U32) -> R (VfsInode, SlotInfo) ErrPtr
fat_dir_empty_ac: VfsInode -> R VfsInode ErrPtr
-- ==========

-- ==========
-- Other TODO
-- ==========
fat_alloc_new_dir_ac: (VfsInode, Time) -> R (VfsInode, U32) ErrPtr
deep_fat_write_inode_ac: (VfsInode, U32) -> VfsInode
last_char_dot_ac: (String, U32) ->  Bool
delete_first_ac: U64 -> U64
ptr_greq_ac: (U64, U64) -> Bool
-- ==========

-- if bh made concrete, change this!
del_slots_gen: (#{acc: (U32, U64, U64), obsv: ()!}) -> GeneratorResult (U32, U64) () (U32, U64) (U32, U64, U64)
del_slots_gen (#{acc = (nr_slots, de, bh), obsv = _}) =
  let b_data = get_b_data (bh) ! bh
  and is_greq = ptr_greq_ac (de, b_data)
  in (nr_slots > 0 && is_greq)
  | True ->
    ((nr_slots, de, bh), Yield (nr_slots, de))
  | False ->
    ((nr_slots, de, bh), Stop (nr_slots, de))

del_slots_cons: (#{obj: (U32, U64), acc: (U32, U64, U64), obsv: ()!}) -> ConsumerResult () (U32, U64) (U32, U64, U64)
del_slots_cons (#{obj = (nr_slots, de), acc = (_, _, bh), obsv = ()}) =
  let de = delete_first_ac (de)
  and nr_slots = decrementU32 (nr_slots)
  in ((nr_slots, de, bh), Next ())

del_slots_cog: (U32, U64, U64) -> (U64, U32)
del_slots_cog (nr_slots, bh, de) =
  let iter = iterate [(U32, U64), (), (U32, U64), (U32, U64, U64), ()]
  and ((nr_slots, de, _), _) = iter (#{
    gen = del_slots_gen,
    cons = del_slots_cons,
    acc = (nr_slots, de, bh),
    obsv = ()
  })
  in (de, nr_slots)

striptail_gen: (#{acc: U32, obsv: String!}) -> GeneratorResult U32 () U32 U32
striptail_gen (#{acc = len, obsv = name}) =
  if (len > 0 && last_char_dot_ac (name, len)) then
    (len, Yield len)
  else
    (len, Stop len)

striptail_cons: (#{obj: U32, acc: U32, obsv: String!}) -> ConsumerResult () U32 U32
striptail_cons (#{obj = len, acc = new_len, obsv = name}) =
  let new_len = decrementU32 len
  in (new_len, Next ())

vfat_striptail_len_cog: U64 -> R U32 ErrPtr
vfat_striptail_len_cog qname =
  let name = get_qstr_name qname ! qname
  and len = get_qstr_length qname ! qname  -- can probs get rid of this line?
  and iter = iterate [U32, (), U32, U32, String]
  and (len, _) =  iter (#{
    gen = striptail_gen,
    cons = striptail_cons,
    acc = len,
    obsv = name
  })
  in (len == 0)
  | True ->
    let err_ptr = noent_ac ()
    in Error err_ptr
  | False -> Success len

add_head_cog: (VfsInode, U64) -> VfsInode
add_head_cog (inode, i_pos) =
  is_root_ino(inode) ! inode
  | True -> inode
  | False ->
    let inode_head = get_head(inode)
    and offset = fat_hash_cog (i_pos)
    and inode_head = incr_head_pointer (inode_head,offset)
    and _ = spinode_lock(inode)
    and inode = set_ipos (inode, i_pos)
    and inode = hlist_add_head_ac (inode, inode_head)
    and _ = spinode_unlock(inode)
    in inode

-- want to get rid of the one in inode.ac but exporting...
fat_attach_cog: (VfsInode, U64) -> VfsInode
fat_attach_cog (inode, i_pos) =
  let inode = add_head_cog (inode, i_pos) -- is this read only
  in is_dir_ac (inode) ! inode
  | True ->
    is_nfs (inode) ! inode
    | True ->
      let d_head = get_dhead(inode)
      and offset = fat_dir_hash_cog (inode)
      and d_head = d_head + offset
      and _ = spdir_lock(inode)
      and inode = hlist_add_head_ac(inode, d_head) -- check if necessary return here or read only
      and _ = spdir_unlock(inode)
      in inode
    | False -> inode
  | False -> inode

sync_inode_cog: VfsInode -> ()
sync_inode_cog (dir) =
  let dir = update_am_time (dir)
  in is_dirsync_ac (dir)
  | Success dir ->
    let _ = fat_sync_inode_cog (dir) -- check if read only
    in ()
  | Error dir ->
    let dir = mark_inode_dirty_ac (dir)
    in ()

{-
clean_entry_cog: (VfsInode, U64, U32, U64) -> R () ()
clean_entry_cog (inode, slot_off, nr_slots, sb) =
  deep_fat_remove_entries_ac (inode, slot_off, nr_slots)
  | Success () -> Success ()
  | Error err_ptr ->
    let _ = fat_msg_ac (sb)
    in Error ()
-}

-- Sets some things to NULL in sinfo - check
fat_remove_entries_cog: (VfsInode, SlotInfo) -> R () ErrPtr
fat_remove_entries_cog (dir, sinfo) =
  let sb = get_sb (dir) ! dir
  and nr_slots = sinfo.nr_slots
  and de = sinfo.de
  and bh = sinfo.bh
  and (de, nr_slots) = del_slots_cog (nr_slots, bh, de)
  and (dir, bh) = mark_buffer_dirty_inode_ac (dir, bh) -- check what is needed
  in is_dirsync_ac (dir)
  | Success dir ->
    let (bh, res) = sync_dirty_buffer_ac (bh)
    in res
    | Success () ->
      let bh = brelse_ac (bh)
      and dir = incr_version (dir)
      in (nr_slots == 0)
      | True ->
        let _ = sync_inode_cog (dir)
        in Success ()
      | False ->
        let slot_off = sinfo.slot_off
        in deep_fat_remove_entries_ac (dir, slot_off, nr_slots)
        | Success dir ->
          let _ = sync_inode_cog (dir)
          in Success ()
        | Error dir ->
          let _ = fat_msg_ac (sb, "Couldn't remove the long name slots")
          and _ = sync_inode_cog (dir)
          in Success ()
    | Error err_ptr ->
      let bh = brelse_ac (bh)
      in Error err_ptr
  | Error dir ->
    let bh = brelse_ac(bh)
    and dir = incr_version (dir)
    in (nr_slots == 0)
    | True ->
      let _ = sync_inode_cog (dir)
      in Success ()
    | False ->
      let slot_off = sinfo.slot_off
      in deep_fat_remove_entries_ac (dir, slot_off, nr_slots)
      | Success dir ->
        let _ = sync_inode_cog (dir)
        in Success ()
      | Error dir ->
        let _ = fat_msg_ac (sb, "Couldn't remove the long name slots")
        and _ = sync_inode_cog (dir)
        in Success ()

-- maybe make this get ipos instead of giving it to it (vfsinode)
fat_hash_cog: U64 -> U64
fat_hash_cog ipos =
  hash_32_ac [U64] (ipos)

fat_dir_hash_cog: VfsInode! -> U64 -- pretty sure this is read only but check
fat_dir_hash_cog inode =
    let logstart = get_logstart (inode)
    in hash_32_ac [U32] (logstart)

fat_detach_cog: VfsInode -> ()
fat_detach_cog (inode) =
  let _ = spinode_lock (inode) ! inode
  and inode = set_ipos (inode, 0)
  and fat_hash = get_fat_hash (inode) ! inode
  and _ = hlist_del_init_ac (fat_hash)
  and _ = spinode_unlock (inode) ! inode
  in is_dir_ac (inode) ! inode
  | True ->
    is_nfs (inode) ! inode
    | True ->
      let _ = spdir_lock (inode) ! inode
      and dir_hash = get_dir_hash (inode) ! inode
      and _ = hlist_del_init_ac (dir_hash)
      and _ = spdir_unlock (inode) ! inode
      in ()
    | False -> ()
  | False -> ()

-- handling overflow - do some error handling here
incr_version: VfsInode -> VfsInode
incr_version inode =
  let version = get_version(inode) ! inode
  and version = version + 1
  in set_version(inode, version)

setup_inode: (VfsInode, VfsDentry!, Time) -> VfsInode
setup_inode (inode, dentry, ts) = -- double check if order of when increasing i_version matters
  let inode = incr_version(inode)
  and inode = set_time(inode, ts)
  and _ = d_instantiate_ac(inode, dentry) !inode
  in inode

fat_fill_inode_ac: (VfsInode, U64) -> R VfsInode (VfsInode, ErrPtr)

-- continue this
{-
fat_fill_inode_cog: (VfsInode, U64) -> R VfsInode (VfsInode, ErrPtr)
fat_fill_inode_cog (inode, de) =
  let sbi = get_sbinfo inode
  and inode = set_ipos (inode, 0)
  and set_init_uid (inode, sbi)
  and set_init_gid (inode, sbi)
  and inode = incr_version (inode)
  and inode = set_init_gen inode
  in fat_fill_dir (inode, de)
  | Success (inode, de) -> -- check if read only for de
    let inode = fat_fill_sys (inode)
    and inode = fat_save_attrs_ac (inode, de)
    and set_init_blocks (inode, sbi)
    and set_init_time ()
  | Error err_ptr -> Error err_ptr
-}

 -- No need for inode - just need its sb
fat_build_inode_cog: (VfsInode, SlotInfo) -> R VfsInode ErrPtr
fat_build_inode_cog (inode, sinfo) =
  let bh = sinfo.bh
  and bh = brelse_ac(bh)
  and sb = get_sb(inode) ! inode
  and i_pos = sinfo.i_pos
  and de = sinfo.de
  and _ = flock_buildinode(sb)
  in fat_iget_ac(sb, i_pos)
  | Success () ->
    new_inode_ac (sb)
    | Success inode ->
      let inode = set_ino(inode, sb) -- check this
      and inode = set_version(inode, 1)
      in fat_fill_inode_ac (inode, de)
      | Success inode ->
        let inode = fat_attach_cog (inode, i_pos) -- check if just read!!
        and inode = insert_inode_hash_ac(inode)
        and _ = funlock_buildinode(sb)
        in is_err(inode)
        | Success inode -> Success inode
        | Error err_ptr -> Error err_ptr
      | Error (inode, err_ptr) ->
        let _ = iput_ac (inode) -- check what this does
        and _ = funlock_buildinode (sb)
        in Error err_ptr
    | Error err_ptr ->
      let _ = funlock_buildinode(sb)
      in Error err_ptr
  | Error err_ptr ->
    let _ = funlock_buildinode(sb)
    in Error err_ptr

fat_sync_inode_cog: VfsInode -> VfsInode
fat_sync_inode_cog inode =
  deep_fat_write_inode_ac (inode, 1)

vfat_add_entry_cog: (VfsInode, U64, U32, U32, Time) -> R (VfsInode, SlotInfo) ErrPtr
vfat_add_entry_cog (dir, qname, is_dir, cluster, ts) =
  vfat_striptail_len_cog (qname) ! qname -- redundant because U64 but keep in mind for later
  | Success len ->
    vfat_build_slots_ac (dir, qname, len, is_dir, cluster, ts)
    | Success (dir, slots, nr_slots) ->
      fat_add_entries_ac (dir, slots, nr_slots)
      | Success sinfo ->
        let dir = set_time (dir, ts)
        in is_dirsync_ac (dir) -- maybe just read? check
        | Success dir ->
          let dir = fat_sync_inode_cog (dir)
          in Success (dir, sinfo)
        | Error dir ->
          let dir = mark_inode_dirty_ac (dir)
          in Success (dir, sinfo)
      | Error err_ptr -> Error err_ptr
    | Error err_ptr -> Error err_ptr
  | Error err_ptr -> Error err_ptr

vfat_create_cog: (VfsInode, VfsDentry!) -> R VfsInode ErrPtr
vfat_create_cog (inode, dentry) =
  let sb = get_sb(inode) ! inode
  and _ = slock (sb)
  and ts = get_current_time () -- ExState
  and name = get_name (dentry) ! dentry
  in vfat_add_entry_cog (inode, name, 0, 0, ts)
  | Success (inode, sinfo) ->
  let inode = incr_version (inode) -- get rid of all parantheses like this
    in fat_build_inode_cog (inode, sinfo)
    | Success inode ->
      let inode = setup_inode(inode, dentry, ts)
      and _ = ulock(sb)
      in Success inode
    | Error err_ptr ->
      let _ = ulock(sb)
      in Error err_ptr
  | Error err ->
    let _ = ulock(sb)
    in Error err

-- vfat_lookup
vfat_find_cog: (VfsInode, U64)! ->  R (VfsInode, SlotInfo) ErrPtr
vfat_find_cog (inode, name) =
  vfat_striptail_len_cog (name) ! name
  | Success len -> fat_search_long_ac (inode, name, len)
  | Error err_ptr -> Error err_ptr

-- fix all the !'s
is_root: VfsDentry -> Bool
is_root dentry =
  let parent = get_parent (dentry) ! dentry
  in (dentry == parent)

vfat_d_anon_disconn_cog: VfsDentry -> Bool
vfat_d_anon_disconn_cog dentry =
  is_root (dentry)
  | True ->
    is_disconnected (dentry) ! dentry
    | True -> True
    | False -> False
  | False -> False

-- fix this to trail the 'and' better
alias_cond: (VfsInode, VfsDentry) -> R (VfsInode, VfsDentry) (VfsInode, VfsDentry)
alias_cond (inode, dentry) =
  let alias = d_find_alias_ac (inode) -- check if read only
  in is_null (alias)
  | True ->
    Error (inode, alias)
  | False ->
    let alias_parent = get_parent (alias) ! alias
    and dentry_parent = get_parent (dentry) ! dentry
    in (alias_parent == dentry_parent)
    | True ->
      vfat_d_anon_disconn_cog (alias) -- check if read only
      | True ->
        Error (inode, alias)
      | False ->
        Success (inode, alias)
    | False ->
      Error (inode, alias)

-- dentry isn't used everywhere here
-- check that you're doing everythign in the original function!!
vfat_lookup_cog: (VfsInode, VfsDentry) -> R VfsDentry ErrPtr -- check if vfs dentry should be banged
vfat_lookup_cog (dir, dentry) =
  let sb = get_sb (dir) ! dir
  and _ = slock(sb)
  and name = get_name (dentry) ! dentry
  in vfat_find_cog (dir, name) !dir !name -- pretty sure this reads
  | Success (dir, sinfo) ->
    --let bh = sinfo.bh
    --and _ = brelse_ac (bh) -- maybe put in fat_ build_inode_cog
    fat_build_inode_cog (dir, sinfo) -- check if error correct
    | Success inode ->
      alias_cond (inode, dentry) !dentry -- if statement
      | Success (inode, alias) ->
        let alias = d_unhashed_ac (alias)
        in is_dir_ac(inode) ! inode
        | True ->
          let _ = iput_ac(inode)
          and _ = ulock (sb)
          in Success alias
        | False ->
          d_move_ac (alias, dentry) ; iput_ac (inode) ; ulock(sb) ; Success alias
          {-let _ = d_move_ac (alias, dentry) -- double check if alias is a vfsdentry
          and _ = iput_ac (inode)
          and _ = ulock (sb) -- remove parantheses
          in Success alias-}
      | Error (inode, alias) ->
        dput_ac (alias) ; ulock(sb) ; is_null(inode)
        | True ->
          let version = get_version (dir)
          and dentry = set_d_time (dentry, version) -- see if you can swap
          and dentry = d_splice_alias_ac(inode, dentry)
          in Success dentry
        | False ->
          let dentry = d_splice_alias_ac (inode, dentry)
          in Success dentry
    | Error err_ptr ->
      let _ = ulock(sb)
      in Error err_ptr
  | Error err_ptr ->
    is_noent(err_ptr)
    | True ->
      let _ = ulock(sb)
      and version = get_version (dir)
      and dentry = set_d_time (dentry, version)
      and dentry = d_splice_alias_ac (0, dentry) -- should be NULL!
      in Success dentry
    | False ->
      let _ = ulock(sb)
      in Error err_ptr

-- vfat_unlink
-- maybe change slotinfo to be a poitner

-- update time only for mtime and atime
-- maybe change result to be R VfsInode ErrPtr later to fit into functional thing

vfat_unlink_cog: (VfsInode, VfsDentry) -> R () ErrPtr -- change returnt ype
vfat_unlink_cog (dir, dentry) =
  let inode = d_inode_ac (dentry)
  and sb = get_sb (dir) ! dir
  and version = get_version (dir) ! dir
  and _ = slock (sb)
  and name = get_name (dentry) ! dentry
  in vfat_find_cog (dir, name)
  | Success (dir, sinfo) ->
    fat_remove_entries_cog (dir, sinfo)
    | Success () ->
      let inode = clear_nlink_ac (inode)
      and inode = update_am_time (inode)
      and _ = fat_detach_cog(inode)
      and dentry = set_d_time (dentry, version) -- FIX THIS! need to rearrange for future purposes re: linearity
      and _ = ulock (sb)
      in Success ()
    | Error err_ptr ->
      let _ = ulock(sb)
      in Error err_ptr
  | Error err_ptr ->
    let _ = ulock(sb)
    in Error err_ptr

-- vfat_mkdir
vfat_mkdir_cog: (VfsInode, VfsDentry) -> R () ErrPtr -- change return type
vfat_mkdir_cog (dir, dentry) =
  let sb = get_sb (dir) ! dir
  and ts = get_current_time ()
  and name = get_name (dentry) ! dentry
  in fat_alloc_new_dir_ac (dir, ts)
  | Success (dir, cluster) -> -- check if read only
    vfat_add_entry_cog (dir, name, 1, cluster, ts)
    | Success (dir, sinfo) ->
      let dir = incr_version (dir)
      and dir = inc_nlink_ac (dir)
      in fat_build_inode_cog (dir, sinfo)
      | Success inode ->
      -- replace with setup inode if possible
        let inode = incr_version (inode)
        and inode = set_nlink_ac (inode, 2) -- if this can be rearranged to be either before or after then do so
        and inode = set_time (inode, ts)
        and _ = d_instantiate_ac (inode, dentry)
        and _ = ulock(sb)
        in Success ()
      | Error err_ptr ->
        let _ = ulock(sb)
        in Error err_ptr
    | Error err_ptr ->
      let _ = fat_free_clusters_ac (dir, cluster) -- LINEARITY WARNING! DIR (in the future be careful)
      and _ = ulock(sb)
      in Error err_ptr
  | Error err_ptr ->
    let _ = ulock(sb)
    in Error err_ptr

-- vfat_rmdir
-- There was an error ONE time when using this. Not sure how to recreate. Need to check.
vfat_rmdir_cog: (VfsInode, VfsDentry) -> R () ErrPtr
vfat_rmdir_cog (dir, dentry) =
  let inode = d_inode_ac (dentry)
  and sb = get_sb (dir) ! dir
  and name = get_name (dentry) ! dentry
  and _ = slock (sb)
  in fat_dir_empty_ac (inode) -- check if read only
  | Success inode ->
    vfat_find_cog (dir, name)
    | Success (dir, sinfo) ->
      fat_remove_entries_cog(dir, sinfo) -- linearity check!!! for future ref
      | Success () ->
        let version = get_version(dir) ! dir
        and _ = drop_nlink_ac(dir)
        and inode = clear_nlink_ac (inode)
        and inode = update_am_time (inode)
        and _ = fat_detach_cog (inode)
        and _ = set_d_time (dentry, version)
        and _ = ulock (sb)
        in Success ()
      | Error err_ptr ->
        let _ = ulock(sb)
        in Error err_ptr
    | Error err_ptr ->
      let _ = ulock(sb)
      in Error err_ptr
  | Error err_ptr ->
    let _ = ulock(sb)
    in Error err_ptr


-- === IN PROGRESS === --

-- deep_fat_remove_entries_cog to replace deep_fat_remove_entries_ac
-- So far kernel crash @ a call to mark_buffer_dirty_inode

{-

get_endpoint_ac: (U64, U64) -> U64
ptr_grq_ac: (U64, U64) -> Bool
slot_offset: (U32, U32, U64) -> U64
delete_first_plus: U64 -> U64
fat_get_entry_ac: (VfsInode, U64, U64, U64) -> R (VfsInode, U64, U64, U64) (VfsInode, ErrPtr)

fix_de_gen: (#{acc: (U32, U64), obsv: U64}) -> GeneratorResult (U32, U64) () (U32, U64) (U32, U64)
fix_de_gen (#{acc = (nr_slots, de), obsv = endp}) =
  let is_grq = ptr_grq_ac (endp, de)
  in (nr_slots > 0 && is_grq)
  | True -> ((nr_slots, de), Yield (nr_slots, de))
  | False -> ((nr_slots, de), Stop (nr_slots, de))

fix_de_cons: (#{obj: (U32, U64), acc: (U32, U64), obsv: U64}) -> ConsumerResult () (U32, U64) (U32, U64)
fix_de_cons (#{obj = (nr_slots, de), acc = _, obsv = endp}) =
  let de = delete_first_plus de -- FIX THIS NAME
  and nr_slots = decrementU32 nr_slots
  in ((nr_slots, de), Next())

fix_de: (U32, U64, U64) -> (U32, U64)
fix_de (nr_slots, de, endp) =
  let iter = iterate [(U32, U64), (), (U32, U64), (U32, U64), U64]
  and ((nr_slots, de), _) = iter (#{
    gen = fix_de_gen,
    cons = fix_de_cons,
    acc = (nr_slots, de),
    obsv = endp
  })
  in (nr_slots, de)

--fix_de: (U32, U64, U64, U64) -> (U32, U64)

-- THIS ACTUALLY AFFECTS VERYTHING!!!! FIX THIS UP all ptrs may be changed
deep_fremove_gen: (#{acc: (U32, VfsInode, U64, U64, U64), obsv : U64!}) -> GeneratorResult (VfsInode, U64, U64, U64) (ErrPtr, VfsInode) (VfsInode) (U32, VfsInode, U64, U64, U64)
deep_fremove_gen (#{acc = (nr_slots, dir, de, bh, pos), obsv = sb}) = -- dont need bh here?
  (nr_slots /= 0)
  | True ->
    fat_get_entry_ac (dir, pos, bh, de) -- bh is null
    | Success (dir, pos, bh, de) ->
      ((nr_slots, dir, de, bh, pos), Yield (dir, pos, bh, de))
    | Error (dir, errptr) ->
      ((nr_slots, dir, de, bh, pos), Return (dir, errptr))
  | False -> ((nr_slots, dir, de, bh, pos), Stop dir)

deep_fremove_cons: (#{obj: (VfsInode, U64, U64, U64), acc: (U32, VfsInode, U64, U64, U64), obsv: U64!}) -> ConsumerResult (ErrPtr, VfsInode) VfsInode (U32, VfsInode, U64, U64, U64)
deep_fremove_cons (#{obj = (dir, pos, de, bh), acc = (nr_slots, _, _, _, _), obsv = sb}) =
  let orig_slots = nr_slots
  and endp = get_endpoint_ac(sb, bh)
  and (nr_slots, de) = fix_de (nr_slots, de, endp) -- name?
  and (dir, bh) = mark_buffer_dirty_inode_ac (dir, bh)
  in is_dirsync_ac (dir)
  | Success dir ->
    let (bh, res) = sync_dirty_buffer_ac bh
    and bh = brelse_ac bh
    in res
    | Success () ->
      let curr_change = slot_offset (orig_slots, nr_slots, de)
      and pos = pos + curr_change
      in ((nr_slots, dir, de, bh, pos), Next ())
    | Error errptr ->
      ((nr_slots, dir, de, bh, pos), Return (errptr, dir))
  | Error dir ->
    let bh = brelse_ac bh
    and curr_change = slot_offset (orig_slots, nr_slots, de)
    and pos = pos + curr_change
    in ((nr_slots, dir, de, bh, pos), Next ())

deep_fat_remove_entries_cog: (VfsInode, U64, U32) -> R VfsInode VfsInode -- change later
deep_fat_remove_entries_cog (dir, pos, nr_slots) =
  let sb = get_sb dir ! dir
  and (bh, de) = (0, 0) -- check
  and iter = iterate [(VfsInode, U64, U64, U64), (ErrPtr, VfsInode), VfsInode, (U32, VfsInode, U64, U64, U64), U64]
  and (_, res) = iter (#{
    gen = deep_fremove_gen,
    cons = deep_fremove_cons,
    acc = (nr_slots, dir, de, bh, pos),
    obsv = sb
  })
  in res
  | Stop inode -> Success inode
  | Return (errptr, inode) -> Error inode -- check if all errors handled (in the calling function)

-}
