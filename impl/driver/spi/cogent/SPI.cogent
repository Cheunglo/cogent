include <gum/common/common.cogent>
include <gum/common/wordarray.cogent>


-- #defines --
-- Command1
spiCmd1Go : U32
spiCmd1Go = 1 << 31

spiCmd1MS : U32
spiCmd1MS = 1 << 30

spiCmd1ModeMask : U32
spiCmd1ModeMask = 0x3

spiCmd1ModeShift : U32
spiCmd1ModeShift = 28

spiCmd1CsSelMask : U32
spiCmd1CsSelMask = 0x3

spiCmd1CsSelShift : U32
spiCmd1CsSelShift = 26

spiCmd1CsPolInactive3 : U32
spiCmd1CsPolInactive3 = 1 << 25

spiCmd1CsPolInactive2 : U32
spiCmd1CsPolInactive2 = 1 << 24

spiCmd1CsPolInactive1 : U32
spiCmd1CsPolInactive1 = 1 << 23

spiCmd1CsPolInactive0 : U32
spiCmd1CsPolInactive0 = 1 << 22

spiCmd1CsSwHw : U32
spiCmd1CsSwHw = 1 >> 21

spiCmd1CsSwVal : U32
spiCmd1CsSwVal = 1 << 20

spiCmd1IdleSdaMask : U32
spiCmd1IdleSdaMask = 0x3

spiCmd1IdleSdaShift : U32
spiCmd1IdleSdaShift = 18

spiCmd1Bidir : U32
spiCmd1Bidir = 1 << 17

spiCmd1LsbiFe : U32
spiCmd1LsbiFe = 1 << 16

spiCmd1LsbyFe : U32
spiCmd1LsbyFe = 1 << 15

spiCmd1BothEnBit : U32
spiCmd1BothEnBit = 1 << 14

spiCmd1BothEnByte : U32
spiCmd1BothEnByte = 1 << 13

spiCmd1RxEn : U32
spiCmd1RxEn = 1 << 12

spiCmd1TxEn : U32
spiCmd1TxEn = 1 << 11

spiCmd1Packed : U32
spiCmd1Packed = 1 << 5

spiCmd1BitLenMask : U32
spiCmd1BitLenMask = 0x1f

spiCmd1BitLenShift : U32
spiCmd1BitLenShift = 0

-- Command2
spiCmd2TxClkTapDelay : U32
spiCmd2TxClkTapDelay = 1 << 6

spiCmd2TxClkTapDelayMask : U32
spiCmd2TxClkTapDelayMask = 0x3f << 6

spiCmd2RxClkTapDelay : U32
spiCmd2RxClkTapDelay = 1 << 0

spiCmd2RxClkTapDelayMask : U32
spiCmd2RxClkTapDelayMask = 0x3f << 0

-- Transfer Status
spiXferStsRdy : U32
spiXferStsRdy = 1 << 30

-- Fifo Status
spiFifoStsCsInactive : U32
spiFifoStsCsInactive = 1 << 31

spiFifoStsFrameEnd : U32
spiFifoStsFrameEnd = 1 << 30

spiFifoStsRxFifoFlush : U32
spiFifoStsRxFifoFlush = 1 << 15

spiFifoStsTxFifoFlush : U32
spiFifoStsTxFifoFlush = 1 << 14

spiFifoStsErr : U32
spiFifoStsErr = 1 << 8

spiFifoStsTxFifoOvf : U32
spiFifoStsTxFifoOvf = 1 << 7

spiFifoStsTxFifoUnr : U32
spiFifoStsTxFifoUnr = 1 << 6

spiFifoStsRxFifoOvf : U32
spiFifoStsRxFifoOvf = 1 << 5

spiFifoStsRxFifoUnr : U32
spiFifoStsRxFifoUnr = 1 << 4

spiFifoStsTxFifoFull : U32
spiFifoStsTxFifoFull = 1 << 3

spiFifoStsTxFifoEmpty : U32
spiFifoStsTxFifoEmpty = 1 << 2

spiFifoStsRxFifoFull : U32
spiFifoStsRxFifoFull = 1 << 1

spiFifoStsRxFifoEmpty : U32
spiFifoStsRxFifoEmpty = 1 << 0

-- SPI CS Timing
csSetupTime0Shift : U32
csSetupTime0Shift = 4

csHoldTime0Shift : U32
csHoldTime0Shift = 0

-- DMA CTL
spiIeRx : U32
spiIeRx = 1 << 29

spiIeTx : U32
spiIeTx = 1 << 28


clkTapDelay : U32
clkTapDelay = 0x1f

csSetupTime : U32
csSetupTime = 0xf

csHoldTime : U32
csHoldTime = 0xf

fifoSize : U32
fifoSize = 64

-- Abstract Types --
-- Type for the memory mapped registers.
type SpiRegs

-- Type for the SPI slave config struct
-- In the future we may turn this into a non-abstract type but for now
-- this is sufficient.
type SpiSlaveCfg

-- Abstract type for void* token
type Token

-- Function pointers
-- We will call wrapper functions that will return SysState as the following
-- are void function pointers.

-- Type of the chip selection function.
type CsFn

-- Type of the callback function.
type CbFn

type SpiBusWrapper

-- Cogent types --
-- Register names.
type SpiRegsField = 
    < Command1 
    | Command2 
    | Timing1 
    | Timing2 
    | XferStatus
    | FifoStatus
    | TxData
    | RxData
    | TxFifo
    | RxFifo
    | DmaCtl
    | DmaBlk
    | SpareCtl
    >

-- SPI chip selection states
type SpiCsState =
    < SpiCsAssert
    | SpiCsRelax
    >

-- SPI struct
type SpiBus =
    { regs : SpiRegs
    , clockMode : U32
    , inProgress : Bool
    , txBuffer : (WordArray U8)!
    , rxBuffer : WordArray U8  -- can be empty
    , rxCnt : U32
    , chipSelect: Option (#CsFn)
    , callBack : #CbFn
    , token : Token
    , currSlave : SpiSlaveCfg
    , wrapper : SpiBusWrapper
    }
type SpiBusInit = SpiBus take(regs, chipSelect)
type SpiBusNoSlave = SpiBus take(currSlave)
type SpiBusSetup = SpiBus take(txBuffer, rxBuffer, rxCnt, callBack, token)

type SpiXferArgs = 
    (SysState
    , SpiBusSetup
    , (WordArray U8)!
    , WordArray U8
    , U32
    , Option (#CbFn)
    , Token)

type SpiXferRet =
    Result 
        (SysState, SpiBus, U32) 
        (SysState, SpiBusSetup, U32, WordArray U8, Token)

-- FFI --
-- Set the GPIO pins if the default chip selection is overwritten
type ChipSelection =
    #{ state : SysState
     , chipSelect : #CsFn
     , slave : SpiSlaveCfg!
     , csState : SpiCsState
     }
doChipSelection : ChipSelection -> SysState

-- Handle the callback
type CallBack = #{ state : SysState, spiBus : SpiBus, res: Result U32 U32 } 
doCallBack : CallBack -> SysState

-- Return the value of the register 'field' and the register set
type RegsGet = #{ regs : SpiRegs, field : SpiRegsField }
getRegister : RegsGet -> (SpiRegs, U32)

-- Set the value of the register 'field' to 'val' and return the register set
type RegsPut = #{ regs : SpiRegs, field : SpiRegsField, val : U32 }
putRegister : RegsPut -> SpiRegs

-- "Static" Cogent functions --
-- Read or flush 1 item from the "rxfifo" queue
readOrFlushRx : Seq32_body (WordArray U8, SpiRegs) () ()
readOrFlushRx #{acc, obsv, idx} = 
    let (w, r) = acc
    and (r', v) = getRegister #{regs = r, field = RxFifo}
    -- Note that if the 'idx' is out of range, the word array is returned
    -- unchanged
    and w' = wordarray_put2 #{ arr = w, idx = idx, val = u32_to_u8 (v .&. 0xff) }
    in ((w', r'), Iterate ())

-- Either write the 'idx' element from the transfer buffer 'obsv' if the
-- 'idx' is in range, or write 0 to the "txfifo" queue
writeTx : Seq32_body SpiRegs (WordArray U8) ()
writeTx #{acc, obsv, idx} =
    -- Note that wordarray_get will return 0 if 'idx' is out of range
    let v = wordarray_get (obsv, idx)
    and r = putRegister #{ regs = acc, field = TxFifo, val = upcast v }
    in (r, Iterate ())

-- Either flush or receive the data from the "rxfifo" queue and set the relevant
-- registers to signal the end of the transaction and call the call back function
finishSpiTransfer : (SysState, SpiBus) -> SysState
finishSpiTransfer (s0, b0) = 
    let b1 { rxBuffer = rx0,
             regs = r0 } = b0
    and size = (wordarray_length b1.txBuffer) + b1.rxCnt !b1
    -- Read or flush the "rxfifo" queue
    and ((rx1, r1), _) = seq32 #{ frm = 0, to = size, step = 1, f = readOrFlushRx,
        acc = (rx0, r0), obsv = () }
    and (r2, xferStat) = getRegister #{ regs = r1, field = XferStatus }
    and r3 = putRegister # { regs = r2, field = XferStatus,
        val = xferStat .|. spiXferStsRdy }
    and b2 = b1 { inProgress = False }
    and cs = b2.chipSelect !b2
    and s1 =
        cs | Some c ->
            let s1' = doChipSelection #{ state = s0, chipSelect = c, 
                slave = b2.currSlave, csState = SpiCsAssert } !b2
            in s1'
           | None -> s0
    and b3 = b2 { rxBuffer = rx1, regs = r3 }
    in doCallBack #{ state = s1, spiBus = b3, res = Success size }

-- Write the transfer buffer to the "txfifo" queue and set the relevant registers
-- to start the transaction
startSpiTransfer : (SysState, SpiBus) -> (SysState, SpiBus)
startSpiTransfer (s0, b0) =
    let b1 { regs = r0 } = b0
    and cs = b1.chipSelect !b1
    and s1 =
        cs | Some c ->
            let s1' = doChipSelection #{ state = s0, chipSelect = c, 
                slave = b1.currSlave, csState = SpiCsAssert } !b1
            in s1'
           | None -> s0
    and size = (wordarray_length b1.txBuffer) + b1.rxCnt !b1
    and r1 = putRegister #{ regs = r0, field = DmaBlk, val = size - 1 }
    -- Write to the "txfifo" queue
    and (r2, _) = seq32 #{ frm = 0, to = size, step = 1, f = writeTx, acc = r1,
        obsv = b1.txBuffer } !b1
    and (r3, cmd1) = getRegister #{ regs = r2, field = Command1 }
    and r4 = putRegister #{ regs = r3, field = Command1, 
        val = cmd1 .|. spiCmd1Go }
    and b2 = b1 { regs = r4 }
    in (s1, b2)

-- Visible Cogent Functions --
-- Handle the SPI IRQ. If the device is ready, finish the transaction, otherwise
-- cancel the transaction
spiHandleIrq : (SysState, SpiBus) -> SysState
spiHandleIrq (s0, b0) =
    let b1 { regs = r0 } = b0
    and (r1, xferStat0) = getRegister #{ regs = r0, field = XferStatus }
    in if (xferStat0 .&. spiXferStsRdy) /= 0
        then let b2 = b1 { regs = r1 } in finishSpiTransfer (s0, b2)
        else
            let (r2, cmd1) = getRegister #{ regs = r1, field = Command1 }
            and r3 = putRegister #{ regs = r2, field = Command1,
                val = cmd1 .&. (complement spiCmd1Go) }
            and (r4, fifoStat) = getRegister # { regs = r3, field = FifoStatus }
            and r5 = putRegister #{ regs = r4, field = FifoStatus,
                val = fifoStat .|. spiFifoStsRxFifoFlush 
                    .|. spiFifoStsTxFifoFlush }
            and (r6, xferStat1) = getRegister #{ regs = r5, field = XferStatus }
            and r7 = putRegister #{ regs = r6, field = XferStatus,
                val = xferStat1 .|. spiXferStsRdy }
            and b3 = b1 { inProgress = False, regs = r7 }
            and cs = b3.chipSelect !b3
            and s1 = 
                cs | Some c ->
                    let s1' = doChipSelection #{ state = s0, chipSelect = c, 
                        slave = b3.currSlave, csState = SpiCsAssert } !b3
                    in s1'
                   | None -> s0
            in doCallBack #{ state = s1, spiBus = b3, res = Error 1}

-- Set up the SPI transaction and then begin the transfer
spiXfer : SpiXferArgs -> SpiXferRet 
spiXfer (s0, b0, txB, rxB, rxS, mcb, tok) = 
    mcb | None -> Error (s0, b0, 3, rxB, tok)
        | Some cb ->
            let b1 { inProgress = p} = b0
            and b2 = b1 { inProgress = p }
            and size = (wordarray_length txB) + rxS
            in 
                if | p -> Error (s0, b2, 1, rxB, tok)
                   | size > fifoSize -> Error (s0, b2, 2, rxB, tok)
                   | else ->
                        let b3 = b2 { txBuffer = txB, rxBuffer = rxB, rxCnt = rxS,
                            callBack = cb, token = tok }
                        and (s1, b4) = startSpiTransfer (s0, b3)
                        in Success (s1, b4, 0)

-- Choose the slave for the SPI transaction
spiPrepareTransfer : (SpiBusNoSlave, SpiSlaveCfg) -> SpiBus
spiPrepareTransfer (b0, slave) =
    let b1 = b0 { currSlave = slave }
    in b1

tegraSpiInit : (SpiBusInit, SpiRegs, Option (#CsFn)) -> SpiBus
tegraSpiInit (b0, r0, mcs) =
    let fifoStatus = spiFifoStsRxFifoFlush .|. 
        spiFifoStsTxFifoFlush .|.
        spiFifoStsErr .|.
        spiFifoStsTxFifoOvf .|.
        spiFifoStsTxFifoUnr .|.
        spiFifoStsRxFifoOvf .|.
        spiFifoStsRxFifoUnr
    and r1 = putRegister #{ regs = r0, field = FifoStatus, val = fifoStatus }
    and (r2, cmd10) = getRegister #{ regs = r1, field = Command1 }
    and cmd11 = cmd10 .|.
        (b0.clockMode << spiCmd1ModeShift) .|.
        spiCmd1TxEn .|.
        spiCmd1RxEn .|.
        ((8 - 1) << spiCmd1BitLenShift) !b0
    and cmd12 =
        mcs | None -> cmd11
            | _ -> cmd11 .|. spiCmd1CsSwHw
    and r3 = putRegister #{ regs = r2, field = Command1, val = cmd12 }
    and (r4, cmd2) = getRegister #{ regs = r3, field = Command2 }
    and r5 = putRegister #{ regs = r4, field = Command2, 
        val = cmd2 .|. (clkTapDelay .&. spiCmd2RxClkTapDelayMask) }
    and (r6, timing1) = getRegister #{ regs = r5, field = Timing1 }
    and r7 = putRegister #{ regs = r6, field = Timing1, 
        val = timing1 .|. (csSetupTime << csSetupTime0Shift) .|.
            (csHoldTime << csHoldTime0Shift) }
    and (r8, dmaCtl) = getRegister #{ regs = r7, field = DmaCtl }
    and r9 = putRegister #{ regs = r8, field = DmaCtl,
        val = dmaCtl .|. spiIeRx .|. spiIeTx }
    and (r10, xferStatus) = getRegister #{ regs = r9, field = XferStatus }
    and r11 = putRegister #{ regs = r10, field = XferStatus,
        val = xferStatus .|. spiXferStsRdy }
    and b1 = b0 { regs = r11, chipSelect = mcs }
    in b1
