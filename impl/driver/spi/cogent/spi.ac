$esc:(#include <stdio.h>)
$esc:(#include <stdbool.h>)
$esc:(#include <platsupport/spi.h>)

typedef void* SysState;

typedef volatile spi_regs* SpiRegs;

typedef spi_slave_config_t* SpiSlaveCfg;

typedef void* Token;

typedef spi_chipselect_fn CsFn;

typedef spi_callback_fn CbFn;

#include "generated.c"
#include <gum/anti/common.ac>
#include <gum/anti/wordarray.ac>
#include <gum/anti/seq.ac>

#define FIFO_SIZE 64

struct spi_regs {
    volatile uint32_t command1;       /* 000:SPI_COMMAND1 register */
    volatile uint32_t command2;       /* 004:SPI_COMMAND2 register */
    volatile uint32_t timing1;        /* 008:SPI_CS_TIM1 register */
    volatile uint32_t timing2;        /* 00c:SPI_CS_TIM2 register */
    volatile uint32_t xfer_status;    /* 010:SPI_TRANS_STATUS register */
    volatile uint32_t fifo_status;    /* 014:SPI_FIFO_STATUS register */
    volatile uint32_t tx_data;        /* 018:SPI_TX_DATA register */
    volatile uint32_t rx_data;        /* 01c:SPI_RX_DATA register */
    volatile uint32_t dma_ctl;        /* 020:SPI_DMA_CTL register */
    volatile uint32_t dma_blk;        /* 024:SPI_DMA_BLK register */
    PAD_STRUCT_BETWEEN(0x24, 0x108, uint32_t);
    volatile uint32_t tx_fifo;        /* 108:SPI_FIFO1 register */
    PAD_STRUCT_BETWEEN(0x108, 0x188, uint32_t);
    volatile uint32_t rx_fifo;        /* 188:SPI_FIFO2 register */
    volatile uint32_t spare_ctl;      /* 18c:SPI_SPARE_CTRL register */
};

static $ty:(#(WordArray U8)) _tx[] = {
    [SPI0] = { .len = 0, .values = NULL }
};

static $ty:(#(WordArray U8)) _rx[] = {
    [SPI0] = { .len = 0, .values = NULL }
};

uint32_t spi_controller_offsets[] = {
    [SPI0] = SPI0_OFFSET
};

static spi_bus_t _spi[] = {
    [SPI0] = { .regs = NULL, .clockMode = 0, .txBuffer = &_tx[SPI0], .rxBuffer = &_rx[SPI0] },
};



// FFI

$ty:(SysState) $id:doChipSelection($ty:(ChipSelection) args) {
    switch (args.csState.tag) 
    {
        case TAG_ENUM_SpiCsAssert:
            (args.chipSelect)(args.slave, SPI_CS_ASSERT);
            break;
        default:
            (args.chipSelect)(args.slave, SPI_CS_RELAX);
    }
    return args.state;
}

$ty:(SysState) $id:doCallBack($ty:(CallBack) args) {
    switch (args.res.tag)
    {
        case TAG_ENUM_Succes:
            ((args.spiBus)->callBack)(args.spiBus, args.res.Success, (args.spiBus)->token);
            break
        default:
            ((args.spiBus)->callBack)(args.spiBus, args.res.Error * -1, (args.spiBus)->token);
    }
    return args.state;
}

$ty:((SpiRegs, U32)) $id:getRegister($ty:(RegsGet) args) {
    $ty:((SpiRegs, U32)) ret;
    ret.p1 = args.regs;
    switch (args.field)
    {
        case TAG_ENUM_Command1:
            ret.p2 = (args.regs)->command1;
            break;
        case TAG_ENUM_Command2:
            ret.p2 = (args.regs)->command2;
            break;
        case TAG_ENUM_Timing1:
            ret = (args.regs)->timing1;
            break;
        case TAG_ENUM_Timing2:
            ret = (args.regs)->timing2;
            break;
        case TAG_ENUM_XferStatus:
            ret = (args.regs)->xfer_status;
            break;
        case TAG_ENUM_FifoStatus:
            ret = (args.regs)->fifo_status;
            break;
        case TAG_ENUM_TxData:
            ret = (args.regs)->tx_data;
            break;
        case TAG_ENUM_RxData:
            ret = (args.regs)->Rx_data;
            break;
        case TAG_ENUM_DmaCtl:
            ret = (args.regs)->dma_ctl;
            break;
        case TAG_ENUM_DmaBlk:
            ret = (args.regs)->dma_blk;
            break;
        case TAG_ENUM_TxFifo:
            ret = (args.regs)->tx_fifo;
            break;
        case TAG_ENUM_RxFifo:
            ret = (args.regs)->Rx_fifo;
            break;
        default:
            ret = (args.regs)->spare_ctl;
    }
    return ret;
}

$ty:(SpiRegs) $id:putRegister($ty:(RegsPut) args) {
    switch (args.field)
    {
        case TAG_ENUM_Command1:
            (args.regs)->command1 = args.val;
            break;
        case TAG_ENUM_Command2:
            (args.regs)->command2 = args.val;
            break;
        case TAG_ENUM_Timing1:
            (args.regs)->timing1 = args.val;
            break;
        case TAG_ENUM_Timing2:
            (args.regs)->timing2 = args.val;
            break;
        case TAG_ENUM_XferStatus:
            (args.regs)->xfer_status = args.val;
            break;
        case TAG_ENUM_FifoStatus:
            (args.regs)->fifo_status = args.val;
            break;
        case TAG_ENUM_TxData:
            (args.regs)->tx_data = args.val;
            break;
        case TAG_ENUM_RxData:
            (args.regs)->Rx_data = args.val;
            break;
        case TAG_ENUM_DmaCtl:
            (args.regs)->dma_ctl = args.val;
            break;
        case TAG_ENUM_DmaBlk:
            (args.regs)->dma_blk = args.val;
            break;
        case TAG_ENUM_TxFifo:
            (args.regs)->tx_fifo = args.val;
            break;
        case TAG_ENUM_RxFifo:
            (args.regs)->Rx_fifo = args.val;
            break;
        default:
            (args.regs)->spare_ctl = args.val;
    }
    return args.regs;
}

int tegra_spi_init(enum spi_id id, volatile void* base,
            spi_chipselect_fn cs_func, mux_sys_t* mux_sys, 
            clock_sys_t* clock_sys, spi_bus_t** ret_spi_bus)
{
    $ty:(SpiBusInit) args; 
    args.p1 = &_spi[id];
    if (cs_func != NULL) {
        args.p3.tag = TAG_ENUM_Some;
        args.p3.Some = cs_func;
    } else {
        args.p3.tag = TAG_ENUM_None;
    }
    args.p2 = base + spi_controller_offsets[id];

    *ret_spi_bus = $exp:(tegraSpiInit)(args);
    return 0;
}

void spi_handle_irq(spi_bus_t *spi_bus) {
    $ty:((SysState, SpiBus)) args = { .p1 = NULL, .p2 = spi_bus };
    $exp:(spiHandleIrq)(args);
}

int spi_xfer(spi_bus_t* spi_bus, const void* txdata, size_t txcnt, 
        void* rxdata, size_t rxcnt, spi_callback_fn cb, void* token) {
    // Hack to ensure that the values of txcnt and rxcnt are not larger than 32-bits
    $ty:(U32) max = ~0;
    if (txcnt + rxcnt > max) {
        ZF_LOGE("SPI transaction size (%d) exceeds FIFO size (%d)", txcnt + rxcnt, FIFO_SIZE);
        return -2;
    }
    // Just a hack to get the buffers in the right form
    // Note we assume that the word arrays meta data can be modified
    // even if the function fails
    (spi_bus->txBuffer).len = (int) txcnt;
    (spi_bus->txBuffer).values = ($ty:(U8)*) txdata;
    if (rxdata != NULL) {
        (spi_bus->rxBuffer).len = (int) (rxcnt + txcnt);
        (spi_bus->rxBuffer).values = ($ty:(U8)*) rxdata;
    } else {
        (spi_bus->rxBuffer).len = 0;
        (spi_bus->rxBuffer).values = NULL;
    }
    $ty:(SpiXferArgs) = args;
    args.p1 = NULL;
    args.p2 = spi_bus;
    args.p3 = spi_bus->txBuffer;
    args.p4 = spi_bus->rxBuffer;
    args.p5 = ($ty:(U32)) rxcnt;
    // Hack to model NULL pointers in Cogent
    if (cb == NULL) {
        args.p6.tag = TAG_ENUM_None;
    } else {
        args.p6.tag = TAG_ENUM_Some;
        args.p6.Some = cb;
    }
    args.p7 = token;

    // Note we don't actually care about the pointers in C since
    // linear types don't exist
    $ty:(SpiXferRet) ret = $exp:(spiXfer)(args);

    if (ret.tag == TAG_ENUM_Success)
        return 0;

    switch (ret.Error.p3) {
        case 1:
            ZF_LOGE("SPI transaction in progress");
            return -1;
        case 2:
            ZF_LOGE("SPI transaction size (%d) exceeds FIFO size (%d)", txcnt + rxcnt, FIFO_SIZE);
            return -2;
        default:
            ZF_LOGE("Synchronous SPI transactions are not implemented");
            return -3;
    }
}

void
spi_prepare_transfer(spi_bus_t* spi_bus, const spi_slave_config_t* cfg)
{
    // TODO: implement support for multiple slaves
    $ty:((SpiBusNoSlave, SpiSlaveCfg)) args = { .p1 = spi_bus, .p2 = cfg };
    $exp:(spiPrepareTransfer)(args);
}
