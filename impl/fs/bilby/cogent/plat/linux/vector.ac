$ty:(R (SysState, Vector) SysState) new_vector ($ty:((SysState, U32)) args)
{
    $ty:(R (SysState, Vector) SysState) ret;

    ret.Success.p2 = kmalloc($exp:bilbyFsObjDentarrHeaderSize + args.p2);
    if (ret.Success.p2 == NULL) {
        ret.tag = TAG_ENUM_Error;
        ret.Error = args.p1;
    } else {
        ret.tag = TAG_ENUM_Success;
        ret.Success.p1 = args.p1;
    }
    return ret;
}

$ty:(SysState) free_vector ($ty:((SysState, Vector)) args)
{
    kfree (args.p2);
    return args.p1;
}

$ty:(U32) size_vector ($ty:(VectorHeader!) args)
{
    $ty:(ObjDentarr!) dentarr = ($ty:(ObjDentarr!))args;
    return size_ObjDentarr (dentarr);
}

$ty:(U32) size_header ($ty:(()) args)
{
    return $exp:bilbyFsObjDentarrHeaderSize;
}

$ty:(VectorHeader!) vector_header ($ty:(Vector!) args)
{
    return args;
}

$ty:(U32) size_entry ($ty:(ObjDentry!) args)
{
    return (size_ObjDentry (args));
}

$ty:(FocusVectorFRet ()) dentarr_del_dentry_vector ($ty:(FocusVectorFArg () CString!) args)
{
    $ty:(FocusVectorFRet ()) ret;

    char* name = args.obsv->values;
    $ty:(ObjDentarr) hd = args.hd;
    $ty:(U32) size = size_ObjDentarr (hd);
    void* uvec = args.uvec;
    void* fvec = args.fvec;

    // copy
    $ty:(ObjDentarr) copy_dentarr = hd;
    copy_dentarr = kmalloc (size);
    if (!copy_dentarr) {
        return ret;  // TODO: should signal failure.
    }

    memcpy (copy_dentarr, hd, size);  // copy the contents

    // lookup
    $ty:(ObjDentry) de = ($ty:(ObjDentry)) copy_dentarr->entries;
    $ty:(ObjDentry) nde = ($ty:(ObjDentry))((void*) de + de->nlen);
    while (strcmp(de->name, name)) {
        de = nde;
        nde = ($ty:(ObjDentry))((void*) de + de->nlen);
    }

    // delete
    $ty:(U32) offs = (void*) nde - (void*) hd;  // the offset from the beginning of dentarr to nde
    $ty:(U32) rest = size - offs;  // the length from nde to the end of dentarr
    memcpy ((void*) uvec + offs, nde, rest);

    kfree (copy_dentarr);

    ret.hd = hd;
    ret.uvec = uvec;
    ret.fvec = fvec;
    ret.res = $exp:(());
    
    return ret;
}

$ty:(Vector) deserialise_vector ($ty:((Vector, Buffer!, BufOffs, U32)) args)
{
    memcpy(args.p1, (void*)args.p2->data->values + args.p3, args.p4);
    return args.p1;
}

$ty:(Buffer) serialise_vector ($ty:((Buffer, BufOffs, Vector!)) args)
{
    memcpy ((void*) args.p1->data->values + args.p2, args.p3, size_vector (vector_header (args.p3)));
    return args.p1;
}

