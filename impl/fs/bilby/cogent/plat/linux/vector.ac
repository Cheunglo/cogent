$ty:(R (SysState, Vector) SysState) new_vector ($ty:((SysState, U32)) args)
{
    $ty:(R (SysState, Vector) SysState) ret;
    $ty:(U32) size = $exp:vector_header_size + args.p2;

    bilbyfs_debug ("new_vector: size=%u\n", size);

    ret.Success.p2 = kmalloc(size);
    if (ret.Success.p2 == NULL) {
        ret.tag = TAG_ENUM_Error;
        ret.Error = args.p1;
    } else {
        ret.tag = TAG_ENUM_Success;
        ret.Success.p1 = args.p1;
    }
    return ret;
}

$ty:(SysState) free_vector ($ty:((SysState, Vector)) args)
{
    kfree (args.p2);
    return args.p1;
}

$ty:(U32) vector_size ($ty:(VectorHeader!) args)
{
    $ty:(ObjDentarr!) dentarr = ($ty:(ObjDentarr!))args;
    $ty:(U32) size = size_ObjDentarr (dentarr);
    bilbyfs_debug ("vector_size: size=%u\n", size);
    return size;
}

$ty:(U32) vector_nb_entries ($ty:(VectorHeader!) args)
{
    $ty:(U32) nb = (($ty:(ObjDentarr!))args)->nb_dentry;
    return nb;
}

$ty:(VectorHeader!) vector_header ($ty:(Vector!) args)
{
    return ($ty:(VectorHeader!)) args;
}

$ty:(FocusVectorFRet ()) dentarr_del_dentry_vector ($ty:(FocusVectorFArg () CString!) args)
{
    $ty:(FocusVectorFRet ()) ret;

    char* name = args.obsv->values;
    $ty:(ObjDentarr) hd = args.hd;
    $ty:(U32) size = vector_size (hd) - $exp:vector_header_size;
    bilbyfs_debug ("dentarr_del_dentry_vector: size=%u\n", size);
    void* uvec = args.uvec;
    void* fvec = args.fvec;

    if (size == 0) {
       bilbyfs_debug ("dentarr_del_dentry_vector: size==0 should not happen!\n");
       ret.hd = hd;
       ret.uvec = uvec;
       ret.fvec = fvec;
       ret.res = $exp:(());
       return ret;
    }

    // copy
    char* copy_entries = kmalloc (size);  // only copy the body, not the header.
    if (!copy_entries) {
        bilbyfs_debug ("dentarr_del_dentry_vector: allocation failed!\n");
        return ret;  // TODO: should signal failure.
    }

    memcpy (copy_entries, uvec, size);  // copy the contents

    // lookup
    $ty:(ObjDentry) de = ($ty:(ObjDentry)) copy_entries;  // point to the head of the copy
    $ty:(ObjDentry) nde = ($ty:(ObjDentry))((void*) de + $exp:bilbyFsObjDentryHeaderSize + de->nlen); // point to the next dentry
    $ty:(U32) rest = size - ($exp:bilbyFsObjDentryHeaderSize + de->nlen); // the size from the dentry after the deleted one to the end.
    char* to_paste = uvec;  // a pointer to the original dentry vector where the tail will be copied back.
    while (strncmp(de->name, name, de->nlen)) {
        to_paste = to_paste + $exp:bilbyFsObjDentryHeaderSize + de->nlen;  // move by the size of this dentry
        de = nde;
        $ty:(U32) dentry_size = $exp:bilbyFsObjDentryHeaderSize + de->nlen;  // size of the next dentry
        // there must be a next if the dentry with the name hasn't been found.
        nde = ($ty:(ObjDentry))((void*) de + dentry_size);
        rest -= dentry_size;
    }

    // copy the tail back
    memcpy ((void*) to_paste, nde, rest);

    kfree (copy_entries);

    ret.hd = hd;
    ret.uvec = uvec;
    ret.fvec = (void*) to_paste + rest;
    ret.res = $exp:(());
    
    return ret;
}

$ty:(Vector) deserialise_vector ($ty:((Vector, Buffer!, BufOffs, U32)) args)
{
    memcpy(args.p1, (void*)args.p2->data->values + args.p3, args.p4);
    return args.p1;
}

$ty:(Buffer) serialise_vector ($ty:((Buffer, BufOffs, Vector!)) args)
{
    memcpy ((void*) args.p1->data->values + args.p2, args.p3, vector_size (vector_header (args.p3)));
    return args.p1;
}

