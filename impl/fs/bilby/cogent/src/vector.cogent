
type Vector = ObjDentarr

type VectorHeader
-- type VectorBody
type VectorUsed  -- start of the entries array (BItem)
type VectorFree  -- where the free space starts (BTail)

type FocusVectorFArg a b = #{hd : VectorHeader, uvec : VectorUsed, fvec : VectorFree, acc : a, obsv : b}
type FocusVectorFRet r   = #{hd : VectorHeader, uvec : VectorUsed, fvec : VectorFree, res : r}

type FocusVectorRoFArg a b = #{hd : VectorHeader!, uvec : VectorUsed!, fvec : VectorFree!, acc : a, obsv : b}
type FocusVectorRoFRet r   = #{hd : VectorHeader!, uvec : VectorUsed!, fvec : VectorFree!, res : r}

-- The second argument is the size of the flexible field.
new_vector : (SysState, U32) -> R (SysState, Vector) SysState
free_vector : (SysState, Vector) -> SysState

vector_size : VectorHeader! -> U32
vector_nb_entries : VectorHeader! -> U32

-- These following interface functions aren't abstract.
-- vector_max_nb_entries : U32
-- vector_header_size : U32
-- vector_entry_size : Entry! -> U32

vector_header : Vector! -> VectorHeader!

focus_vector : all (a :< E, b :< DS, r :< E).
               #{ vec : Vector
                , acc : a
                , obsv : b
                , f : FocusVectorFArg a b -> FocusVectorFRet r
                } -> (r, Vector)

focus_vector_ro : all (a :< E, b :< DS, r :< E).
                  #{ vec : Vector!
                   , acc : a
                   , obsv : b
                   , f : FocusVectorRoFArg a b -> FocusVectorRoFRet r
                   } -> r

vector_next : (VectorUsed, VectorFree!) -> <This VectorUsed | Next VectorUsed>
vector_next_ro : (VectorUsed!, VectorFree!) -> <NoMore | Next (VectorUsed!)>


type Entry = ObjDentry

vector_read : VectorUsed! -> Entry!

-- This function curretly doesn't not change the header to keep things in sync.
-- It's left to be the responsibility of the user.
vector_append : #{hd : VectorHeader!, uvec : VectorUsed, fvec : VectorFree, obj : Entry!}
             -> #{suc : Bool, uvec : VectorUsed, fvec : VectorFree}


vector_header_size : U32
vector_header_size = bilbyFsObjDentarrHeaderSize

vector_max_nb_entries : U32
vector_max_nb_entries = bilbyFsMaxNbDentarrEntries 

vector_entry_size : Entry! -> U32
vector_entry_size dentry = size_ObjDentry dentry

serialise_vector : (Buffer, BufOffs, Vector!) -> Buffer
deserialise_vector : (Vector, Buffer!, BufOffs, U32) -> Vector
