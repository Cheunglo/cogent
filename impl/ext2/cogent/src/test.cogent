--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

-- allocation paths and inodes, in order:
-- file /a => ino 12
-- dir  /b => ino 2049
-- dir  /c => ino 4097 -- ACTUALLY 2050 since we don't allocate a block yet
-- file /d => ino 13
--
-- file /b/e => ino 2050 -- ACTUALLY 2051 since 2050 is currently taken (see above)
-- dir  /f
--
--------------------------------
-- below are wishlist:
-- file /b/f => ino 2051
-- dir  /b/g => ino 2052
--
-- file /c/h => ino 4098
-- dir  /c/i => ino 4099
-- dir  /c/i/j => ino 4100
-- sym  /c/i/k => ino 4101

-- just allocate everything and free it
-- there is another function for adding stuff to directories
{-
const_NUM_TEST_INODES: U32
const_NUM_TEST_INODES = 6

test_allocation: (SysState, FsState, Array VfsInode, VfsInode!) -> RR (SysState, FsState, Array VfsInode) () ()
test_allocation (ex, state, arr, root) =
  let ((ex, state), res) = ext2_inode_create (ex, state, root, 420 .|. vfs_type_reg) -- 644 in octal
  in res
  | Success inode_a =>
    -- put it
    let actual_ino = vfs_inode_get_ino (inode_a) !inode_a
    and ((ex, arr), _) = array_replace [VfsInode] #{ arr, idx = 0, elem = inode_a, f = vfs_inode_put_tuple, ex }
    
    -- check it
    and correct_ino:U32 = 12
    in if actual_ino == correct_ino then
      -- make next
      let ((ex, state), res) = ext2_inode_create (ex, state, root, 493 .|. vfs_type_dir) -- 755 in octal
      in res
      | Success inode_b =>
        -- don't put it since we need it later
        let actual_ino = vfs_inode_get_ino (inode_b) !inode_b

        -- check it
        and correct_ino:U32 = 2049
        in if actual_ino == correct_ino then
          -- make next
          let ((ex, state), res) = ext2_inode_create (ex, state, root, 493 .|. vfs_type_dir) -- 755 in octal
          in res
          | Success inode_c =>
            -- put it
            let actual_ino = vfs_inode_get_ino (inode_c) !inode_c
            and ((ex, arr), _) = array_replace [VfsInode] #{ arr, idx = 2, elem = inode_c, f = vfs_inode_put_tuple, ex }

            -- check it
            --and correct_ino:U32 = 4097
            and correct_ino:U32 = 2050 -- TODO: make this 4097 when we test mkdir
            in if actual_ino == correct_ino then
              -- make next
              let ((ex, state), res) = ext2_inode_create (ex, state, root, 420 .|. vfs_type_reg) -- 644 in octal
              in res
              | Success inode_d =>
                -- put it
                let actual_ino = vfs_inode_get_ino (inode_d) !inode_d
                and ((ex, arr), _) = array_replace [VfsInode] #{ arr, idx = 3, elem = inode_d, f = vfs_inode_put_tuple, ex }

                -- check it
                and correct_ino:U32 = 13
                in if actual_ino == correct_ino then
                  -- make next
                  let ((ex, state), res) = ext2_inode_create (ex, state, inode_b, 420 .|. vfs_type_reg) !inode_b -- parent is b
                  in res
                  | Success inode_e =>
                    -- put it and b from earlier
                    let actual_ino = vfs_inode_get_ino (inode_e) !inode_e
                    and ((ex, arr), _) = array_replace [VfsInode] #{ arr, idx = 1, elem = inode_b, f = vfs_inode_put_tuple, ex }
                    and ((ex, arr), _) = array_replace [VfsInode] #{ arr, idx = 4, elem = inode_e, f = vfs_inode_put_tuple, ex }

                    -- check it
                    --and correct_ino:U32 = 2050
                    and correct_ino:U32 = 2051 -- TODO: fix when above TODO is fixed.
                    in if actual_ino == correct_ino then
                      let ((ex, state), res) = ext2_inode_create (ex, state, root, 493 .|. vfs_type_dir)
                      in res
                      | Success inode_f =>
                        -- put it
                        let actual_ino = vfs_inode_get_ino (inode_f) !inode_f
                        and ((ex, arr), _) = array_replace [VfsInode] #{ arr, idx = 5, elem = inode_f, f = vfs_inode_put_tuple, ex }

                        -- check it
                        and correct_ino:U32 = 4097
                        in if actual_ino == correct_ino then
                          -- done!
                          ((ex, state, arr), Success ())
                        else
                          let _ = _cogent_log (dbg_EXT2_TEST, "inode f ino was ")
                          and _ = _cogent_log_u32 (dbg_EXT2_TEST, actual_ino)
                          and _ = _cogent_log (dbg_EXT2_TEST, ", not ")
                          and _ = _cogent_log_u32 (dbg_EXT2_TEST, correct_ino)
                          and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                          in ((ex, state, arr), Error ())
                      | Error e ->
                        let _ = _cogent_log (dbg_EXT2_TEST, "allocation of inode f failed with error ")
                        and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
                        and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                        in ((ex, state, arr), Error ())
                    else
                      let _ = _cogent_log (dbg_EXT2_TEST, "inode e ino was ")
                      and _ = _cogent_log_u32 (dbg_EXT2_TEST, actual_ino)
                      and _ = _cogent_log (dbg_EXT2_TEST, ", not ")
                      and _ = _cogent_log_u32 (dbg_EXT2_TEST, correct_ino)
                      and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                      in ((ex, state, arr), Error ())
                  | Error e ->
                    let _ = _cogent_log (dbg_EXT2_TEST, "allocation of inode e failed with error ")
                    and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
                    and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                    and ex = vfs_inode_put_tuple (ex, inode_b)

                    in ((ex, state, arr), Error ())
                else
                  let _ = _cogent_log (dbg_EXT2_TEST, "inode d ino was ")
                  and _ = _cogent_log_u32 (dbg_EXT2_TEST, actual_ino)
                  and _ = _cogent_log (dbg_EXT2_TEST, ", not ")
                  and _ = _cogent_log_u32 (dbg_EXT2_TEST, correct_ino)
                  and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                  and ex = vfs_inode_put_tuple (ex, inode_b)

                  in ((ex, state, arr), Error ())
              | Error e ->
                let _ = _cogent_log (dbg_EXT2_TEST, "allocation of inode d failed with error ")
                and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
                and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                and ex = vfs_inode_put_tuple (ex, inode_b)

                in ((ex, state, arr), Error ())
            else
              let _ = _cogent_log (dbg_EXT2_TEST, "inode c ino was ")
              and _ = _cogent_log_u32 (dbg_EXT2_TEST, actual_ino)
              and _ = _cogent_log (dbg_EXT2_TEST, ", not ")
              and _ = _cogent_log_u32 (dbg_EXT2_TEST, correct_ino)
              and _ = _cogent_log (dbg_EXT2_TEST, "\n")

              and ex = vfs_inode_put_tuple (ex, inode_b)

              in ((ex, state, arr), Error ())
          | Error e ->
            let _ = _cogent_log (dbg_EXT2_TEST, "allocation of inode c failed with error ")
            and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
            and _ = _cogent_log (dbg_EXT2_TEST, "\n")

            and ex = vfs_inode_put_tuple (ex, inode_b)

            in ((ex, state, arr), Error ())
        else
          let _ = _cogent_log (dbg_EXT2_TEST, "inode b ino was ")
          and _ = _cogent_log_u32 (dbg_EXT2_TEST, actual_ino)
          and _ = _cogent_log (dbg_EXT2_TEST, ", not ")
          and _ = _cogent_log_u32 (dbg_EXT2_TEST, correct_ino)
          and _ = _cogent_log (dbg_EXT2_TEST, "\n")

          and ex = vfs_inode_put_tuple (ex, inode_b)

          in ((ex, state, arr), Error ())
      | Error e ->
        let _ = _cogent_log (dbg_EXT2_TEST, "allocation of inode b failed with error ")
        and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
        and _ = _cogent_log (dbg_EXT2_TEST, "\n")

        in ((ex, state, arr), Error ())
    else
      let _ = _cogent_log (dbg_EXT2_TEST, "inode a ino was ")
      and _ = _cogent_log_u32 (dbg_EXT2_TEST, actual_ino)
      and _ = _cogent_log (dbg_EXT2_TEST, ", not ")
      and _ = _cogent_log_u32 (dbg_EXT2_TEST, correct_ino)
      and _ = _cogent_log (dbg_EXT2_TEST, "\n")

      in ((ex, state, arr), Error ())
  | Error e ->
    let _ = _cogent_log (dbg_EXT2_TEST, "allocation of inode a failed with error ")
    and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
    and _ = _cogent_log (dbg_EXT2_TEST, "\n")

    in ((ex, state, arr), Error ())

type GroupDescState = #{
  free_blocks: U16,
  free_inodes: U16,
  dir_count: U16
}

test_state_compare: (GroupDescState, Ext2GroupDescriptor) -> Bool
test_state_compare (mem, disk) =
  mem.free_blocks == disk.free_block_count &&
  mem.free_inodes == disk.free_inode_count &&
  mem.dir_count == disk.directory_count

-- group desc 3-15 should have 2048 free inodes, 7932 free blocks, 0 dirs
-- group desc 15 has one less free block
test_state_was_ok: Seq32_body (SysState, FsState) () ()
test_state_was_ok #{ acc = (ex, state), obsv, idx } =
  let free_blocks = 7932
  and free_blocks = if idx == 15 then free_blocks - 1 else free_blocks

  and default_state = #{ free_blocks, free_inodes = 2048, dir_count = u8_to_u16 0 }
  and (ex, state, res) = test_state_check (ex, state, default_state, idx)

  in if res then ((ex, state), Iterate ()) else ((ex, state), Break ())

test_state_check: (SysState, FsState, GroupDescState, U32) -> (SysState, FsState, Bool)
test_state_check (ex, state, check_state, idx) =
  let ((ex, state), res) = group_desc_from_block_group (ex, state, idx)
  in res
  | Success group_desc =>
    if test_state_compare (check_state, group_desc) then
      (ex, state, True)
    else
      let _ = _cogent_log (dbg_EXT2_TEST, "group desc ")
      and _ = _cogent_log_u32 (dbg_EXT2_TEST, idx )
      and _ = _cogent_log (dbg_EXT2_TEST, " didn't match default state!\n")
      in (ex, state, False)
  | Error () ->
    let _ = _cogent_log (dbg_EXT2_TEST, "failed to lookup group desc ")
    and _ = _cogent_log_u32 (dbg_EXT2_TEST, idx )
    and _ = _cogent_log (dbg_EXT2_TEST, "\n")
    in (ex, state, False)

test_state: (SysState, FsState, GroupDescState, GroupDescState, GroupDescState) -> RR (SysState, FsState) () ()
test_state (ex, state, a, b, c) =
  let ngroups = state.group_count !state
  and _ = _cogent_assert (ngroups >= 3)

  -- check the first 3, since they will change
  and (ex, state, res) = test_state_check (ex, state, a, 0)
  and (ex, state, res) = if res then test_state_check (ex, state, b, 1) else (ex, state, res)
  and (ex, state, res) = if res then test_state_check (ex, state, c, 2) else (ex, state, res)

  -- check the rest
  in if res then
    let ((ex, state), res) = seq32 [(SysState, FsState), (), ()] #{
      frm  = 3,
      to   = ngroups,
      step = 1,
      f    = test_state_was_ok,
      acc  = (ex, state),
      obsv = () }
    in res
    | Iterate () ->
      ((ex, state), Success ())
    | Break () ->
      ((ex, state), Error ())
  else
    ((ex, state), Error ())

test_initial_state: (SysState, FsState) -> RR (SysState, FsState) () ()
test_initial_state (ex, state) =
  let group_0 = #{ free_blocks = 7919, free_inodes = 2037, dir_count = u8_to_u16 2 }
  and group_1 = #{ free_blocks = 7932, free_inodes = 2048, dir_count = u8_to_u16 0 }
  and group_2 = #{ free_blocks = 7932, free_inodes = 2048, dir_count = u8_to_u16 0 }

  -- TODO: also test initial directory contents are correct, as are inode sizes
  in test_state (ex, state, group_0, group_1, group_2)

test_post_alloc_state: (SysState, FsState) -> RR (SysState, FsState) () ()
test_post_alloc_state (ex, state) = 
  let group_0 = #{ free_blocks = 7919, free_inodes = 2035, dir_count = u8_to_u16 2 } -- 2 allocs (2x file)
  and group_1 = #{ free_blocks = 7932, free_inodes = 2045, dir_count = u8_to_u16 2 } -- 3 allocs (2x dir, 1x file)
  and group_2 = #{ free_blocks = 7932, free_inodes = 2047, dir_count = u8_to_u16 1 } -- 1 allocs (1x dir)

  in test_state (ex, state, group_0, group_1, group_2)

test_path_one2: (SysState, FsState, Path, U32, VfsInode) -> (SysState, FsState, Path, VfsInode, Bool)
test_path_one2 (ex, state, path, blk, inode) =
  let depth = path.depth !path
  and boundary = path.boundary !path

  and (ex, res) = chain_from_path (ex, path, inode, depth) !inode
  in res
  | Success (chain, maybe_partial) ->
    maybe_partial
    | Some partial_idx ->
      let _ = _cogent_assert (partial_idx == 0) !chain
      and _ = _cogent_assert (chain.indirect_count == 1) !chain

      -- okay, find the goal to the indirect
      and (chain, maybe_indirect) = chain_take_indirect (chain, partial_idx)
      in maybe_indirect
      | Some indirect ->
        let _ = _cogent_assert (indirect.blockptr == 0) !indirect
        and _ = _cogent_assert (indirect.offset == 0) !indirect
        --and _ = _cogent_assert (chain.indirect_count == 0) !chain

        and goal = ext2_find_goal (state, inode, blk, indirect) !inode !state !indirect
        and (ex, chain) = chain_put_indirect (ex, chain, indirect, partial_idx)
        --and _ = _cogent_assert (chain.indirect_count == 1) !chain

        and _ = _cogent_assert (goal == 0)

        -- from fsop_get_block:
        and unallocated_in_chain = chain.path.depth - partial_idx !chain
        and indirect_blocks = unallocated_in_chain - 1
        and count = chain_blocks_to_allocate (chain, indirect_blocks, 1, boundary) !chain -- max_mappable == 1

        -- should be 1 unallocated, 0 indirect, 1 direct
        and _ = _cogent_assert (unallocated_in_chain == 1)
        and _ = _cogent_assert (indirect_blocks == 0)
        and _ = _cogent_assert (count == 1)

        -- let's allocate (just 1 block for now)
        and ((ex, state, chain, inode), res) = chain_alloc (ex, state, chain, inode, indirect_blocks, goal, 1, partial_idx)
        in res
        | Success count ->
          let _ = _cogent_assert (count == 1)
          --and _ = _cogent_assert (chain_was_full (chain)) !chain -- FIXME
          and _ = _cogent_assert (chain.indirect_count == 1) !chain

          and (chain, maybe_indirect) = chain_pop_indirect (chain)
          in maybe_indirect
          | Some indirect ->
            -- with goal of 0, should work upwards to first free block 274 (presumably 5% for super + root dir + lost+found)
            let _ = _cogent_assert (indirect.blockptr == 274) !indirect
            and _ = _cogent_assert (indirect.offset == 0) !indirect 
            and _ = _cogent_assert (chain.indirect_count == 0) !chain

            and ex = indirect_destroy (ex, indirect)
            and (ex, path) = chain_free (ex, chain)
            in (ex, state, path, inode, True)
          | None () ->
            let _ = _cogent_log (dbg_EXT2_TEST, "test_path_one2: indirect fell off chain (2)\n")
            and (ex, path) = chain_free (ex, chain)
            in (ex, state, path, inode, False)
        | Error e ->
          let _ = _cogent_log (dbg_EXT2_TEST, "test_path_one2: allocation failed\n")
          and (ex, path) = chain_free (ex, chain)
          in (ex, state, path, inode, False)
      | None () ->
        let _ = _cogent_log (dbg_EXT2_TEST, "test_path_one2: indirect fell off chain (1)\n")
        and (ex, path) = chain_free (ex, chain)
        in (ex, state, path, inode, False)
    | None () ->
      let _ = _cogent_log (dbg_EXT2_TEST, "test_path_one2: was full path, should have been\n")
      and (ex, path) = chain_free (ex, chain)
      in (ex, state, path, inode, False)
  | Error path ->
    let _ = _cogent_log (dbg_EXT2_TEST, "test_path_one2: failed to create chain from path\n")
    in (ex, state, path, inode, False)

check_blockContents_f: Seq32_body () (OSBuffer, U32) ()
check_blockContents_f #{ acc, obsv = (buf, val), idx } =
  osbuffer_deserialise_Ple32 (buf, idx)
  | Success (val', _) => if val == val' then ((), Iterate ()) else
    let _ = _cogent_log (dbg_EXT2_TEST, "check_blockContents_f: buf val ")
    and _ = _cogent_log_u32 (dbg_EXT2_TEST, val')
    and _ = _cogent_log (dbg_EXT2_TEST, " != chek val ")
    and _ = _cogent_log_u32 (dbg_EXT2_TEST, val)
    and _ = _cogent_log (dbg_EXT2_TEST, " at offset ")
    and _ = _cogent_log_u32 (dbg_EXT2_TEST, idx )
    and _ = _cogent_log (dbg_EXT2_TEST, "\n")
    in ((), Break ())
  | Error () ->
    let _ = _cogent_log (dbg_EXT2_TEST, "check_blockContents_f: could not deserialise from offset ")
    and _ = _cogent_log_u32 (dbg_EXT2_TEST, idx)
    and _ = _cogent_log (dbg_EXT2_TEST, "\n")
    in ((), Break ())

check_blockContents: (OSBuffer!, U32, U32, U32) -> Bool
check_blockContents (buf, frm_idx, to_idx, val) =
  let (_, res) = seq32 [(), (OSBuffer, U32), ()] #{
    frm   = frm_idx * 4,
    to    = to_idx * 4,
    step  = 4,
    f     = check_blockContents_f,
    acc   = (),
    obsv  = (buf, val)
  }

  in res
  | Iterate () -> True
  | Break () -> False

test_path_two2: (SysState, FsState, Path, U32, VfsInode) -> (SysState, FsState, Path, VfsInode, Bool)
test_path_two2 (ex, state, path, blk, inode) =
  let depth = path.depth !path
  and boundary = path.boundary !path

  and _ = _cogent_log (dbg_EXT2_TEST, "== inode before: ==\n")
  and _ = dump_inode (inode) !inode

  and (ex, res) = chain_from_path (ex, path, inode, depth) !inode
  in res
  | Success (chain, maybe_partial) ->
    maybe_partial
    | Some partial_idx ->
      let _ = _cogent_assert (partial_idx == 0) !chain
      and _ = _cogent_assert (chain.indirect_count == 1) !chain -- not 2, since the unallocated one doesnt' go in chain

      -- okay, find the goal to the indirect
      and (chain, maybe_indirect) = chain_take_indirect (chain, partial_idx)
      in maybe_indirect
      | Some indirect ->
        let _ = _cogent_assert (indirect.blockptr == 0) !indirect
        and _ = _cogent_assert (indirect.offset == 12) !indirect -- const_singleIndirectIdx
        and _ = _cogent_assert (chain.indirect_count == 0) !chain

        and goal = ext2_find_goal (state, inode, blk, indirect) !inode !state !indirect
        and (ex, chain) = chain_put_indirect (ex, chain, indirect, partial_idx)
        and _ = _cogent_assert (chain.indirect_count == 1) !chain

        and _ = _cogent_assert (goal == 0)

        -- from fsop_get_block:
        and unallocated_in_chain = chain.path.depth - partial_idx !chain
        and indirect_blocks = unallocated_in_chain - 1
        and count = chain_blocks_to_allocate (chain, indirect_blocks, 1, boundary) !chain -- max_mappable == 1

        -- should be 2 unallocated, 1 indirect, 1 direct
        and _ = _cogent_assert (unallocated_in_chain == 2)
        and _ = _cogent_assert (indirect_blocks == 1)
        and _ = _cogent_assert (count == 1)

        -- let's allocate (just 1 block for now)
        and ((ex, state, chain, inode), res) = chain_alloc (ex, state, chain, inode, indirect_blocks, goal, 1, partial_idx)
        in res
        | Success count ->
          let _ = _cogent_assert (count == 1) -- 2 would've allocated, but only 1 direct
          and _ = _cogent_assert (chain.indirect_count == 2) !chain

          and (chain, maybe_indirect) = chain_pop_indirect (chain)
          in maybe_indirect
          | Some indirect ->
            let _ = _cogent_assert (indirect.blockptr == 276) !indirect
            and _ = _cogent_assert (indirect.offset == 1) !indirect 
            and _ = _cogent_assert (chain.indirect_count == 1) !chain

            and (ex, chain) = chain_push_indirect (ex, chain, indirect)

            and (chain, maybe_indirect) = chain_take_indirect (chain, partial_idx)
            in maybe_indirect
            | Some indirect =>
              let _ = _cogent_assert (indirect.blockptr == 275) !indirect
              and _ = _cogent_assert (indirect.offset == 12) !indirect -- const_singleIndirectIdx

              and ((ex, indirect, inode), res) = indirect_splice (ex, indirect, inode, blk, count, indirect_blocks)

              -- put indirect back
              and (ex, chain) = chain_put_indirect (ex, chain, indirect, partial_idx)
              in res
              | Success () =>
                let indirect_blockptr = chain_peek_indirect_blockptr (chain) !chain
                
                and _ = _cogent_assert (indirect_blockptr == 276)

                and _ = _cogent_log (dbg_EXT2_TEST, "== inode after: ==\n")
                and _ = dump_inode (inode) !inode

                and (ex, res) = ext2_get_block (ex, 275)
                in res
                | Success buf ->
                  if check_blockContents (buf, 0, 1, 0) !buf then -- before
                    if check_blockContents (buf, 1, 2, 276) !buf then -- blockptr
                      if check_blockContents (buf, 2, const_blockSize >> 2, 0) !buf then -- after
                        let (ex, path) = chain_free (ex, chain)
                        and ex = osbuffer_destroy (ex, buf)
                        in (ex, state, path, inode, True)
                      else 
                        let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: part after blockptr was non-zero\n")
                        and (ex, path) = chain_free (ex, chain)
                        and ex = osbuffer_destroy (ex, buf)
                        in (ex, state, path, inode, False)
                    else
                      let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: blockptr in indirect was not correct\n")
                      and (ex, path) = chain_free (ex, chain)
                      and ex = osbuffer_destroy (ex, buf)
                      in (ex, state, path, inode, False)
                  else
                    let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: part before blockptr was non-zero\n")
                    and (ex, path) = chain_free (ex, chain)
                    and ex = osbuffer_destroy (ex, buf)
                    in (ex, state, path, inode, False)
                | Error () ->
                  let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: failed to alloc OSBuffer\n")
                  and (ex, path) = chain_free (ex, chain)
                  in (ex, state, path, inode, False)
              | Error e ->
                let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: cannot put back final indirect with err ")
                and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
                and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                and (ex, path) = chain_free (ex, chain)
                in (ex, state, path, inode, False)
            | None () ->
              let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: indirect fell off chain (3)\n")
              and (ex, path) = chain_free (ex, chain)
              in (ex, state, path, inode, False)
          | None () ->
            let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: indirect fell off chain (2)\n")
            and (ex, path) = chain_free (ex, chain)
            in (ex, state, path, inode, False)
        | Error e ->
          let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: allocation failed\n")
          and (ex, path) = chain_free (ex, chain)
          in (ex, state, path, inode, False)
      | None () ->
        let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: indirect fell off chain (1)\n")
        and (ex, path) = chain_free (ex, chain)
        in (ex, state, path, inode, False)
    | None () ->
      let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: was full path, should't be\n")
      and (ex, path) = chain_free (ex, chain)
      in (ex, state, path, inode, False)
  | Error path ->
    let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2: failed to create chain from path\n")
    in (ex, state, path, inode, False)

test_path_three2: (SysState, FsState, Path, U32, VfsInode) -> (SysState, FsState, Path, VfsInode, Bool)
test_path_three2 (ex, state, path, blk, inode) =
  let depth = path.depth !path
  and boundary = path.boundary !path

  -- TODO: check path (should be offsets 14, 0, 0, 1)

  and _ = _cogent_log (dbg_EXT2_TEST, "== inode before: ==\n")
  and _ = dump_inode (inode) !inode

  and (ex, res) = chain_from_path (ex, path, inode, depth) !inode
  in res
  | Success (chain, maybe_partial) ->
    maybe_partial
    | Some partial_idx ->
      let _ = _cogent_assert (partial_idx == 0) !chain
      and _ = _cogent_assert (chain.indirect_count == 1) !chain -- not 3, since the unallocated ones don't go in chain

      -- okay, find the goal to the indirect
      and (chain, maybe_indirect) = chain_take_indirect (chain, partial_idx)
      in maybe_indirect
      | Some indirect ->
        let _ = _cogent_assert (indirect.blockptr == 0) !indirect
        and _ = _cogent_assert (indirect.offset == 14) !indirect -- const_tripleIndirectIdx
        and _ = _cogent_assert (chain.indirect_count == 0) !chain

        and goal = ext2_find_goal (state, inode, blk, indirect) !inode !state !indirect
        and (ex, chain) = chain_put_indirect (ex, chain, indirect, partial_idx)
        and _ = _cogent_assert (chain.indirect_count == 1) !chain

        and _ = _cogent_assert (goal == 275) -- last indirect

        -- from fsop_get_block:
        and unallocated_in_chain = chain.path.depth - partial_idx !chain
        and indirect_blocks = unallocated_in_chain - 1
        and count = chain_blocks_to_allocate (chain, indirect_blocks, 1, boundary) !chain -- max_mappable == 1

        -- should be 4 unallocated, 3 indirect, 1 direct
        and _ = _cogent_assert (unallocated_in_chain == 4)
        and _ = _cogent_assert (indirect_blocks == 3)
        and _ = _cogent_assert (count == 1)

        -- let's allocate (just 1 block for now)
        and ((ex, state, chain, inode), res) = chain_alloc (ex, state, chain, inode, indirect_blocks, goal, 1, partial_idx)
        in res
        | Success count ->
          let _ = _cogent_assert (count == 1) -- 4 would've allocated, but only 1 direct
          and _ = _cogent_assert (chain.indirect_count == 4) !chain

          and (chain, maybe_indirect) = chain_pop_indirect (chain)
          in maybe_indirect
          | Some indirect ->
            let _ = _cogent_assert (indirect.blockptr == 280) !indirect
            and _ = _cogent_assert (indirect.offset == 1) !indirect
            and _ = _cogent_assert (chain.indirect_count == 3) !chain

            and (ex, chain) = chain_push_indirect (ex, chain, indirect)

            -- where we spliced:
            and (chain, maybe_indirect) = chain_take_indirect (chain, partial_idx)
            in maybe_indirect
            | Some indirect =>
              let _ = _cogent_assert (indirect.blockptr == 277) !indirect 
              and _ = _cogent_assert (indirect.offset == 14) !indirect -- const_tripleIndirectIdx

              and ((ex, indirect, inode), res) = indirect_splice (ex, indirect, inode, blk, count, indirect_blocks)

              -- put indirect back
              and (ex, chain) = chain_put_indirect (ex, chain, indirect, partial_idx)
              in res
              | Success () =>
                let indirect_blockptr = chain_peek_indirect_blockptr (chain) !chain
                
                and _ = _cogent_assert (indirect_blockptr == 280)

                and _ = _cogent_log (dbg_EXT2_TEST, "== inode after: ==\n")
                and _ = dump_inode (inode) !inode

                and (ex, res) = ext2_get_block (ex, 279)
                in res
                | Success buf ->
                  if check_blockContents (buf, 0, 1, 0) !buf then -- before
                    if check_blockContents (buf, 1, 2, 280) !buf then -- blockptr
                      if check_blockContents (buf, 2, const_blockSize >> 2, 0) !buf then -- after
                        -- check its parent
                        let ex = osbuffer_destroy (ex, buf)
                        and (ex, res) = ext2_get_block (ex, 278)
                        in res
                        | Success buf ->
                          if check_blockContents (buf, 0, 1, 279) !buf then -- blockptr
                            if check_blockContents (buf, 1, const_blockSize >> 2, 0) !buf then -- after
                              -- check ITS parent
                              let ex = osbuffer_destroy (ex, buf)
                              and (ex, res) = ext2_get_block (ex, 277)
                              in res
                              | Success buf ->
                                if check_blockContents (buf, 0, 1, 278) !buf then -- blockptr
                                  if check_blockContents (buf, 1, const_blockSize >> 2, 0) !buf then -- after
                                    -- check we were in the inode OK
                                    let ok = wordarray_get [BlockPtr] (inode.fs.block_pointers, 14) == 277 &&
                                             wordarray_get [BlockPtr] (inode.fs.block_pointers, 13) == 0   &&
                                             wordarray_get [BlockPtr] (inode.fs.block_pointers, 12) == 275 &&
                                             wordarray_get [BlockPtr] (inode.fs.block_pointers, 0)  == 0 !inode

                                    in if ok then
                                      let (ex, path) = chain_free (ex, chain)
                                      and ex = osbuffer_destroy (ex, buf)
                                      in (ex, state, path, inode, True)
                                    else
                                      let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: inode blockptrs were corrupted\n")
                                      and (ex, path) = chain_free (ex, chain)
                                      and ex = osbuffer_destroy (ex, buf)
                                      in (ex, state, path, inode, False)
                                  else
                                    let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: part after blockptr1 was non-zero\n")
                                    and (ex, path) = chain_free (ex, chain)
                                    and ex = osbuffer_destroy (ex, buf)
                                    in (ex, state, path, inode, False)
                                else
                                  let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: blockptr in indirect1 was not correct\n")
                                  and (ex, path) = chain_free (ex, chain)
                                  and ex = osbuffer_destroy (ex, buf)
                                  in (ex, state, path, inode, False)
                              | Error () ->
                                let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: failed to alloc OSBuffer\n")
                                and (ex, path) = chain_free (ex, chain)
                                in (ex, state, path, inode, False)
                            else
                              let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: part after blockptr2 was non-zero\n")
                              and (ex, path) = chain_free (ex, chain)
                              and ex = osbuffer_destroy (ex, buf)
                              in (ex, state, path, inode, False)
                          else
                            let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: blockptr in indirect2 was not correct\n")
                            and (ex, path) = chain_free (ex, chain)
                            and ex = osbuffer_destroy (ex, buf)
                            in (ex, state, path, inode, False)
                        | Error () ->
                          let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: failed to alloc OSBuffer\n")
                          and (ex, path) = chain_free (ex, chain)
                          in (ex, state, path, inode, False)
                      else 
                        let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: part after blockptr3 was non-zero\n")
                        and (ex, path) = chain_free (ex, chain)
                        and ex = osbuffer_destroy (ex, buf)
                        in (ex, state, path, inode, False)
                    else
                      let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: blockptr in indirect3 was not correct\n")
                      and (ex, path) = chain_free (ex, chain)
                      and ex = osbuffer_destroy (ex, buf)
                      in (ex, state, path, inode, False)
                  else
                    let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: part before blockptr3 was non-zero\n")
                    and (ex, path) = chain_free (ex, chain)
                    and ex = osbuffer_destroy (ex, buf)
                    in (ex, state, path, inode, False)
                | Error () ->
                  let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: failed to alloc OSBuffer\n")
                  and (ex, path) = chain_free (ex, chain)
                  in (ex, state, path, inode, False)
              | Error e ->
                let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: cannot put back final indirect with err ")
                and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
                and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                and (ex, path) = chain_free (ex, chain)
                in (ex, state, path, inode, False)
            | None () ->
              let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: indirect fell off chain (3)\n")
              and (ex, path) = chain_free (ex, chain)
              in (ex, state, path, inode, False)
          | None () ->
            let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: indirect fell off chain (2)\n")
            and (ex, path) = chain_free (ex, chain)
            in (ex, state, path, inode, False)
        | Error e ->
          let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: allocation failed\n")
          and (ex, path) = chain_free (ex, chain)
          in (ex, state, path, inode, False)
      | None () ->
        let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: indirect fell off chain (1)\n")
        and (ex, path) = chain_free (ex, chain)
        in (ex, state, path, inode, False)
    | None () ->
      let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: was full path, should't be\n")
      and (ex, path) = chain_free (ex, chain)
      in (ex, state, path, inode, False)
  | Error path ->
    let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2: failed to create chain from path\n")
    in (ex, state, path, inode, False)

test_path_one: (SysState, FsState, VfsInode) -> RR (SysState, FsState, VfsInode) () ()
test_path_one (ex, state, inode) =
  -- what we're going to do is to do ~basically~ what fsop_get_block would do in the case of creating a
  -- block, but assert things as we go with regards to inode 12

  let blk:U32 = 0
  and (ex, res) = path_new_from_block (ex, blk)
  in res
  | Success path ->
    let _ = _cogent_assert (path.depth == 1) !path
    -- TODO: what is boundary here? 11?

    and (ex, state, path, inode, res) = test_path_one2 (ex, state, path, blk, inode)
    and ex = path_destroy (ex, path)

    in if res then
      let blk:U32 = 13 -- single indirect
      and (ex, res) = path_new_from_block (ex, blk)
      in res
      | Success path ->
        let _ = _cogent_assert (path.depth == 2) !path

        and (ex, state, path, inode, res) = test_path_two2 (ex, state, path, blk, inode)
        and ex = path_destroy (ex, path)
        in if res then
          let blk:U32 = 65804 + 1 -- triple indirect
          and (ex, res) = path_new_from_block (ex, blk)
          in res
          | Success path ->
            let _ = _cogent_assert (path.depth == 4) !path

            and (ex, state, path, inode, res) = test_path_three2 (ex, state, path, blk, inode)
            and ex = path_destroy (ex, path)
            in if res then
              ((ex, state, inode), Success ())
            else
              let _ = _cogent_log (dbg_EXT2_TEST, "test_path_three2 failed\n")
              in ((ex, state, inode), Error ())
          | Error () ->
            let _ = _cogent_log (dbg_EXT2_TEST, "could not create path 3\n")
            in ((ex, state, inode), Error ())
        else
          let _ = _cogent_log (dbg_EXT2_TEST, "test_path_two2 failed\n")
          in ((ex, state, inode), Error ())
      | Error () ->
        let _ = _cogent_log (dbg_EXT2_TEST, "could not create path 2\n")
        in ((ex, state, inode), Error ())
    else
      let _ = _cogent_log (dbg_EXT2_TEST, "test_path_one2 failed\n")
      in ((ex, state, inode), Error ())
  | Error () ->
    let _ = _cogent_log (dbg_EXT2_TEST, "could not create path\n")
    in ((ex, state, inode), Error ())

test_dir_add_remove: (SysState, FsState, VfsInode) -> RR (SysState, FsState, VfsInode) () ()
--test_dir_add_remove (ex, state, root) =
--  -- make our test dir first
--  let ((ex, state, root), res) = fsop_dir_mkdir (ex, state, root, "dirtest", 511) -- mode 777
--  in res
--  | Success dir_inode ->

--  | Error e ->
--    let _ = _cogent_log (dbg_EXT2_TEST, "test_dir_add_remove: mkdir returned err ")
--    and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
--    and _ = _cogent_log (dbg_EXT2_TEST, "\n")

--    in ((ex, state, root), Error ())
test_dir_add_remove (ex, state, inode) = ((ex, state, inode), Success ())

test_block_was_free: (SysState, FsState, BlockPtr) -> (SysState, FsState, Bool)
test_block_was_free (ex, state, blk) =
  let block_group = (blk - state.super.first_data_block) / state.super.blocks_per_group !state
  and ((ex, state), res) = group_desc_and_buf_from_block_group (ex, state, block_group)
  in res
  | Success (group_desc, group_desc_buf) ->
    let grp_target_blk = ((blk - state.super.first_data_block)) % state.super.blocks_per_group !state
    and ((ex, state), res) = get_block_bitmap (ex, state, group_desc.block_bitmap)
    in res 
    | Success (bitmap_buf) ->
      osbuffer_test_bit (bitmap_buf, grp_target_blk) !bitmap_buf
      | False ->
        let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
        and ex = osbuffer_destroy (ex, bitmap_buf)
        in (ex, state, True)
      | _ ->
        let _ = _cogent_log (dbg_EXT2_TEST, "test_block_was_free: bit " )
        and _ = _cogent_log_u32 (dbg_EXT2_TEST, grp_target_blk)
        and _ = _cogent_log (dbg_EXT2_TEST, " for block ")
        and _ = _cogent_log_u32 (dbg_EXT2_TEST, blk )
        and _ = _cogent_log (dbg_EXT2_TEST, " was set when it was free'd\n")

        and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
        and ex = osbuffer_destroy (ex, bitmap_buf)

        in (ex, state, False)
    | Error () ->
      let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
      in (ex, state, False)
  | Error () ->
    (ex, state, False)



test_free_one: (SysState, FsState, VfsInode, VfsInode!) -> RR (SysState, FsState) () ()
test_free_one (ex, state, inode, root) =
  let (ex, state, inode_t) = fsop_inode_evict (ex, state, inode, True)

  -- at this point, the blocks should have been free'd, but the inode itself
  -- is still allocated

  and (ex, state, was_free) = test_block_was_free (ex, state, 275)
  in if was_free then
    let (ex, state, was_free) = test_block_was_free (ex, state, 276)
    in if was_free then
      let (ex, state, was_free) = test_block_was_free (ex, state, 277)
      in if was_free then
        let (ex, state, was_free) = test_block_was_free (ex, state, 278)
        in if was_free then
          let (ex, state, was_free) = test_block_was_free (ex, state, 279)
          in if was_free then
            let (ex, state, was_free) = test_block_was_free (ex, state, 280)
            in if was_free then
              -- TODO: it would be nice to put back fs, do a quick allocation and
              -- see if we end up with 275 being allocated back to us again

              -- TODO: also check free block counts etc

              -- okay, now try to free the inode itself
              let (ex, state, inode_t) = fsop_inode_free (ex, state, inode_t)
              and ex = vfs_inode_put_taken #{ ex, inode = inode_t }

              -- TODO: check free inode counts

              -- easy way to check, do another alloc and see if it overlapped ino
              and ((ex, state), res) = ext2_inode_create (ex, state, root, 420 .|. vfs_type_reg) -- 644 in octal
              in res
              | Success inode_a =>
                -- put it
                let actual_ino = vfs_inode_get_ino (inode_a) !inode_a
                in if actual_ino == 12 then
                  -- awesome, try a block allocation -- TODO: try this

                  let ex = vfs_inode_put_tuple (ex, inode_a)
                  in ((ex, state), Success ())
                else
                  let _ = _cogent_log (dbg_EXT2_TEST, "test_free_one: new inode had ino ")
                  and _ = _cogent_log_u32 (dbg_EXT2_TEST, actual_ino)
                  and _ = _cogent_log (dbg_EXT2_TEST, " rather than expected ino ")
                  and _ = _cogent_log_u32 (dbg_EXT2_TEST, 12)
                  and _ = _cogent_log (dbg_EXT2_TEST, "\n")

                  and ex = vfs_inode_put_tuple (ex, inode_a)
                  in ((ex, state), Error ())
              | Error e ->
                let _ = _cogent_log (dbg_EXT2_TEST, "test_free_one: failed to alloc new inode with err ")
                and _ = _cogent_log_u32 (dbg_EXT2_TEST, e)
                and _ = _cogent_log (dbg_EXT2_TEST, "\n")
                in ((ex, state), Error ())
            else
              let _ = _cogent_log (dbg_EXT2_TEST, "test_free_one: block 280 was not free\n")
              and ex = vfs_inode_put_taken #{ ex, inode = inode_t }
              in ((ex, state), Error ())
          else
            let _ = _cogent_log (dbg_EXT2_TEST, "test_free_one: block 279 was not free\n")
            and ex = vfs_inode_put_taken #{ ex, inode = inode_t }
            in ((ex, state), Error ())
        else
          let _ = _cogent_log (dbg_EXT2_TEST, "test_free_one: block 278 was not free\n")
          and ex = vfs_inode_put_taken #{ ex, inode = inode_t }
          in ((ex, state), Error ())
      else
        let _ = _cogent_log (dbg_EXT2_TEST, "test_free_one: block 277 was not free\n")
        and ex = vfs_inode_put_taken #{ ex, inode = inode_t }
        in ((ex, state), Error ())
    else
      let _ = _cogent_log (dbg_EXT2_TEST, "test_free_one: block 276 was not free\n")
      and ex = vfs_inode_put_taken #{ ex, inode = inode_t }
      in ((ex, state), Error ())
  else
    let _ = _cogent_log (dbg_EXT2_TEST, "test_free_one: block 275 was not free\n")
    and ex = vfs_inode_put_taken #{ ex, inode = inode_t }
    in ((ex, state), Error ())

fsop_run_tests: (SysState, FsState, VfsInode) -> RR (SysState, FsState, VfsInode) () ()
fsop_run_tests (ex, state, root) =
  -- check initial block groups
  let ((ex, state), res) = test_initial_state (ex, state)
  in res
  | Success () ->
    array_create [VfsInode] (ex, const_NUM_TEST_INODES)
    | Success (ex, inodes) =>
      let ((ex, state, inodes), res) = test_allocation (ex, state, inodes, root) !root
      in res
      | Success () ->
        let (inodes, maybe_first_inode) = array_remove [VfsInode] (inodes, 0)
        and ex = array_free [VfsInode] #{ arr = inodes, f = vfs_inode_put_tuple, ex }

        in maybe_first_inode
        | Some first_inode ->
          -- make sure all the block groups are OK still
          let ((ex, state), res) = test_post_alloc_state (ex, state)
          in res
          | Success () ->
            let ((ex, state, first_inode), res) = test_path_one (ex, state, first_inode)
            in res
            | Success () ->
              -- test freeing
              let ((ex, state), res) = test_free_one (ex, state, first_inode, root) !root
              in res
              | Success () ->
                test_dir_add_remove (ex, state, root)
              | Error () ->
                let _ = _cogent_log (dbg_EXT2_TEST, "failed to free first inode correctly\n")
                in ((ex, state, root), Error ())
            | Error () ->
              let _ = _cogent_log (dbg_EXT2_TEST, "failed to write blocks to first inode\n")
              and ex = vfs_inode_put_tuple (ex, first_inode)
              in ((ex, state, root), Error ())
          | Error () ->
            let _ = _cogent_log (dbg_EXT2_TEST, "failed to verify post-allocation blockgroup states\n")
            and ex = vfs_inode_put_tuple (ex, first_inode)
            in ((ex, state, root), Error ())
        | None () ->
          let _ = _cogent_log (dbg_EXT2_TEST, "first inode was not in array anymore; bug in test\n")
          in ((ex, state, root), Error ())
      | Error () ->
        let _ = _cogent_log (dbg_EXT2_TEST, "failed allocation test\n")

        and ex = array_free [VfsInode] #{ arr = inodes, f = vfs_inode_put_tuple, ex }
        in ((ex, state, root), Error ())
    | Error ex ->
      let _ = _cogent_log (dbg_EXT2_TEST, "failed to allocate initial inodes array\n")
      in ((ex, state, root), Error ())
  | Error () ->
    let _ = _cogent_log (dbg_EXT2_TEST, "failed to verify initial blockgroup states\n")
    in ((ex, state, root), Error ())
-}

fsop_run_tests: (SysState, FsState, VfsInode) -> RR (SysState, FsState, VfsInode) () ()
fsop_run_tests (ex, state, root) = ((ex, state, root), Success ())